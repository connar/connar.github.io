<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>API Hashing - Extensive breakdown | Journal of Connar</title>
<meta name="keywords" content="API Hashing, Windows API">
<meta name="description" content="Intro
As mentioned in the Exploring PEB struct and its fields post, we will now see how to to use a technique known as API Hashing. API hashing is a technique used in malware to identify API functions by their hash value from their names or other attributes. This hash value can then be used instead of the function names or other attributes to enumerate, rehash, compare and use functions based on the hash value. This way, direct calls by function names is avoided and thus leads to fewer detection rates. More specifically, it is used to make the work of analysts harder since names of WINAPI functions or DLL&rsquo;s won&rsquo;t show in string commands or tools like CFF Explorer, so the intentions of the executable won&rsquo;t be so clear from the beginning.">
<meta name="author" content="connar, r4sti">
<link rel="canonical" href="http://localhost:1313/posts/apihashing/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.1665878c578779cd11d4dc626b2c0e032a8b9c1dcf7d37f819200b4bc208b6a7.css" integrity="sha256-FmWHjFeHec0R1NxiaywOAyqLnB3PfTf4GSALS8IItqc=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/apihashing/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Journal of Connar (Alt + H)">Journal of Connar</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/mychallenges/" title="My Challenges">
                    <span>My Challenges</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/training/" title="Training">
                    <span>Training</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      API Hashing - Extensive breakdown
    </h1>
    <div class="post-meta"><span title='2024-06-06 20:03:02 +0200 CEST'>June 6, 2024</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;connar, r4sti

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#intro" aria-label="Intro">Intro</a></li>
                <li>
                    <a href="#how-it-works" aria-label="How it works">How it works</a></li>
                <li>
                    <a href="#examples" aria-label="Examples">Examples</a></li>
                <li>
                    <a href="#runtime-resolution" aria-label="Runtime Resolution">Runtime Resolution</a></li>
                <li>
                    <a href="#code" aria-label="Code">Code</a><ul>
                        
                <li>
                    <a href="#checking-for-dll-argument" aria-label="Checking for DLL argument">Checking for DLL argument</a></li>
                <li>
                    <a href="#loading-the-dll-in-memory" aria-label="Loading the DLL in memory">Loading the DLL in memory</a></li>
                <li>
                    <a href="#api-hashing---finding-the-function-via-hash" aria-label="API Hashing - Finding the function via hash">API Hashing - Finding the function via hash</a><ul>
                        
                <li>
                    <a href="#hash-function" aria-label="Hash function">Hash function</a></li>
                <li>
                    <a href="#getprocaddressh---load-hash-compare-repeat" aria-label="GetProcAddressH - Load, Hash, Compare, Repeat">GetProcAddressH - Load, Hash, Compare, Repeat</a></li></ul>
                </li>
                <li>
                    <a href="#api-hashing---finding-the-dll-via-hash" aria-label="API Hashing - Finding the DLL via hash">API Hashing - Finding the DLL via hash</a><ul>
                        
                <li>
                    <a href="#code-additions" aria-label="Code additions">Code additions</a><ul>
                        
                <li>
                    <a href="#specifying-the-hash" aria-label="Specifying the Hash">Specifying the Hash</a></li>
                <li>
                    <a href="#check-if-user32dll-is-loaded" aria-label="Check if USER32.DLL is loaded">Check if USER32.DLL is loaded</a></li>
                <li>
                    <a href="#getmodulehandleh" aria-label="GetModuleHandleH">GetModuleHandleH</a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#whats-next" aria-label="What&rsquo;s next">What&rsquo;s next</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="intro">Intro<a hidden class="anchor" aria-hidden="true" href="#intro">#</a></h2>
<p>As mentioned in the <b><i>Exploring PEB struct and its fields</i></b> post, we will now see how to to use a technique known as API Hashing. API hashing is a technique used in malware to identify API functions by their hash value from their names or other attributes. This hash value can then be used instead of the function names or other attributes to enumerate, rehash, compare and use functions based on the hash value. This way, direct calls by function names is avoided and thus leads to fewer detection rates. More specifically, it is used to make the work of analysts harder since names of WINAPI functions or DLL&rsquo;s won&rsquo;t show in string commands or tools like CFF Explorer, so the intentions of the executable won&rsquo;t be so clear from the beginning.</p>
<h2 id="how-it-works">How it works<a hidden class="anchor" aria-hidden="true" href="#how-it-works">#</a></h2>
<p>A hash function is applied to the API function name. For example, a simple hash function might take the string <code>CreateFileA</code> and produce a hash value such as <code>0xA1B2C3D4</code>. It will then load all loaded functions of the desired DLL, hash them and compare the result with the target hash. If there is a match, a handle to this address will be returned and invoked through a custom defined structure of the desired function.</p>
<h2 id="examples">Examples<a hidden class="anchor" aria-hidden="true" href="#examples">#</a></h2>
<p>Let&rsquo;s preview the final result of the application of this technique to an executable that simple uses MessageBox to show a message on the screen. Running the program before this technique would showcase this:</p>
<p><img loading="lazy" src="/posts/apihashing/apihashing4.png" alt="before apihashing"  />
</p>
<p>Loading the same exe to CFF explorer, we see it uses USER32DLL to utilize the MessageBox function:</p>
<p><img loading="lazy" src="/posts/apihashing/apihashing5.png" alt="CFF before apihashing"  />
</p>
<p>Now, let&rsquo;s observe the output of the same program but modified into using API Hashing instead:</p>
<p><img loading="lazy" src="/posts/apihashing/apihashing6.png" alt="after apihashing"  />
</p>
<p>And again, loading to CFF explorer, wee see that indeed the USER32.DLL has disappeared:</p>
<p><img loading="lazy" src="/posts/apihashing/apihashing7.png" alt="after apihashing CFF"  />
</p>
<h2 id="runtime-resolution">Runtime Resolution<a hidden class="anchor" aria-hidden="true" href="#runtime-resolution">#</a></h2>
<p>When the program runs, it will compare the hash values of available API functions with the precomputed hash values. When a match is found, the corresponding function is called, thus avoiding the direct call (hardcoded use) of the name.</p>
<p>In the following code that will be showcased, we will break down how to find all the functions inside a given DLL and loop through them until we get a hit for a hash value comparison. The hash we will be comparing with will be that of the MessageBoxA, and when the match will be found, we will call this function.</p>
<h2 id="code">Code<a hidden class="anchor" aria-hidden="true" href="#code">#</a></h2>
<p>We will explain one part at a time, slowly building up the code that will execute a MessageBoxA function without using the direct name.</p>
<h3 id="checking-for-dll-argument">Checking for DLL argument<a hidden class="anchor" aria-hidden="true" href="#checking-for-dll-argument">#</a></h3>
<p>The executable will take as argument the DLL that we want the MessageBoxA function from, and specifically the user32.dll. So our code starts by checking if an argument has been given and if so, it stores it in a variable:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">wchar_t</span><span style="color:#f92672">*</span> argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wprintf</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;Usage: %s &lt;target_dll_name&gt;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Get the DLL passed as argument, for example user32.dll
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">wchar_t</span><span style="color:#f92672">*</span> targetDllName <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* -- more -- */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="loading-the-dll-in-memory">Loading the DLL in memory<a hidden class="anchor" aria-hidden="true" href="#loading-the-dll-in-memory">#</a></h3>
<p>After the Dll argument has been given, we check with <code>GetModuleHandleA</code> if the DLL is already loaded in memory. If not, <code>GetModuleHandleA</code> will have returned NULL and so we will use <code>LoadLibraryA</code> to load this DLL in memory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">wchar_t</span><span style="color:#f92672">*</span> argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wprintf</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;Usage: %s &lt;target_dll_name&gt;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Get the DLL passed as argument, for example user32.dll
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">wchar_t</span><span style="color:#f92672">*</span> targetDllName <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Get a handle for this dll
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    HMODULE hModule_of_arg_dll <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetModuleHandleA</span>((LPCSTR)targetDllName);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// If it is not loaded in memory, load it now
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (hModule_of_arg_dll <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        hModule_of_arg_dll <span style="color:#f92672">=</span> <span style="color:#a6e22e">LoadLibraryA</span>(targetDllName);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We cast the targetDllName to (LPCSTR) since the GetModuleHandleA accepts this type of parameter:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">GetModuleHandleA</span>(
</span></span><span style="display:flex;"><span>    _In_opt_ LPCSTR lpModuleName
</span></span><span style="display:flex;"><span>    );
</span></span></code></pre></div><p><strong>We can always CTRL+click on the function&rsquo;s name to see its definition and type parameters.</strong></p>
<h3 id="api-hashing---finding-the-function-via-hash">API Hashing - Finding the function via hash<a hidden class="anchor" aria-hidden="true" href="#api-hashing---finding-the-function-via-hash">#</a></h3>
<p>Now this is the part of the juicy code that enumerates through all the DLL&rsquo;s functions and searches for a hash match. In this code, we pre-computed the hash value of the MessageBoxA function of user32.dll. So we basically pass the user32.dll as parameter to the program, and then program tries to find a match of a function inside user32.dll whose hash is the same as the precomputed hardcoded one we compare with.</p>
<p>Let&rsquo;s start analyzing. We first call the GetProcAddressH which is a custom function that passes as arguments the handle of the previously loaded DLL, and the hash of the MessageBoxA (MessageBoxA_HASH) we precomputed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define MessageBoxA_HASH    0xF10E27CA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>PfnMessageBoxA)(HWND, LPCSTR, LPCSTR, UINT);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">wchar_t</span><span style="color:#f92672">*</span> argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wprintf</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;Usage: %s &lt;target_dll_name&gt;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Get the DLL passed as argument, for example user32.dll
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">wchar_t</span><span style="color:#f92672">*</span> targetDllName <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Get a handle for this dll
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    HMODULE hModule_of_arg_dll <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetModuleHandleA</span>((LPCSTR)targetDllName);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// If it is not loaded in memory, load it now
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (hModule_of_arg_dll <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        hModule_of_arg_dll <span style="color:#f92672">=</span> <span style="color:#a6e22e">LoadLibraryA</span>(targetDllName);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Getting the address of MessageBoxA function using GetProcAddressH
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PfnMessageBoxA pMessageBoxA <span style="color:#f92672">=</span> (PfnMessageBoxA)<span style="color:#a6e22e">GetProcAddressH</span>(hModule_of_arg_dll, MessageBoxA_HASH);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pMessageBoxA <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] Couldn&#39;t Find Address Of Specified Function </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>We also cast to PfnMessageBoxA. This is because our GetProcAddressH as we will see shortly returns a pointer to the address of the matching hashed function. So since we get back a pointer to an address, we cast to the corresponding type of data this address contains, which is of fnMessageBoxA type.</p>
<p>One side note here is that the PfnMessageBoxA is not the actual MessageBox. The actual MessageBox has the following struct:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">MessageBox</span>(
</span></span><span style="display:flex;"><span>  [in, optional] HWND    hWnd,
</span></span><span style="display:flex;"><span>  [in, optional] LPCTSTR lpText,
</span></span><span style="display:flex;"><span>  [in, optional] LPCTSTR lpCaption,
</span></span><span style="display:flex;"><span>  [in]           UINT    uType
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>so we just defined our own same data struct.</p>
<h4 id="hash-function">Hash function<a hidden class="anchor" aria-hidden="true" href="#hash-function">#</a></h4>
<p>Before we finally dive into the GetProcAddressH to see the process of API Hashing, let&rsquo;s see the hash function that will be used first:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;winternl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define INITIAL_SEED	7	
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Generate JenkinsOneAtATime32Bit hashes from Ascii input string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>UINT32 <span style="color:#a6e22e">HashStringJenkinsOneAtATime32BitA</span>(_In_ PCHAR String)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    SIZE_T Index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    UINT32 Hash <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    SIZE_T Length <span style="color:#f92672">=</span> <span style="color:#a6e22e">lstrlenA</span>(String);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (Index <span style="color:#f92672">!=</span> Length)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Hash <span style="color:#f92672">+=</span> String[Index<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>        Hash <span style="color:#f92672">+=</span> Hash <span style="color:#f92672">&lt;&lt;</span> INITIAL_SEED;
</span></span><span style="display:flex;"><span>        Hash <span style="color:#f92672">^=</span> Hash <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">6</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Hash <span style="color:#f92672">+=</span> Hash <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    Hash <span style="color:#f92672">^=</span> Hash <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">11</span>;
</span></span><span style="display:flex;"><span>    Hash <span style="color:#f92672">+=</span> Hash <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">15</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Hash;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define HASHA(API) (HashStringJenkinsOneAtATime32BitA((PCHAR) API))
</span></span></span></code></pre></div><p>This is just one hash function that can be used. It was taken from <a href="https://github.com/vxunderground/VX-API/blob/main/VX-API/HashStringDjb2.cpp">the VX Underground repo</a>. You could use whatever function you want.</p>
<p>We also define a shorter name for this function, HASHA, which takes as a parameter the API (the function) that the code will hash. We also cast the parameter (API) to (PCHAR) since the <code>HashStringJenkinsOneAtATime32BitA</code> takes as a parameter a (PCHAR) string.</p>
<h4 id="getprocaddressh---load-hash-compare-repeat">GetProcAddressH - Load, Hash, Compare, Repeat<a hidden class="anchor" aria-hidden="true" href="#getprocaddressh---load-hash-compare-repeat">#</a></h4>
<p>The code responsible for loading the functions of the given dll, hashing them and comparing with the hardcoded precomputed value, is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>FARPROC <span style="color:#a6e22e">GetProcAddressH</span>(HMODULE hModule, DWORD dwApiNameHash) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (hModule <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> dwApiNameHash <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PBYTE pBase <span style="color:#f92672">=</span> (PBYTE)hModule;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PIMAGE_DOS_HEADER         pImgDosHdr <span style="color:#f92672">=</span> (PIMAGE_DOS_HEADER)pBase;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pImgDosHdr<span style="color:#f92672">-&gt;</span>e_magic <span style="color:#f92672">!=</span> IMAGE_DOS_SIGNATURE)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PIMAGE_NT_HEADERS         pImgNtHdrs <span style="color:#f92672">=</span> (PIMAGE_NT_HEADERS)(pBase <span style="color:#f92672">+</span> pImgDosHdr<span style="color:#f92672">-&gt;</span>e_lfanew);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pImgNtHdrs<span style="color:#f92672">-&gt;</span>Signature <span style="color:#f92672">!=</span> IMAGE_NT_SIGNATURE)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    IMAGE_OPTIONAL_HEADER     ImgOptHdr <span style="color:#f92672">=</span> pImgNtHdrs<span style="color:#f92672">-&gt;</span>OptionalHeader;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PIMAGE_EXPORT_DIRECTORY   pImgExportDir <span style="color:#f92672">=</span> (PIMAGE_EXPORT_DIRECTORY)(pBase <span style="color:#f92672">+</span> ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PDWORD  FunctionNameArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNames);
</span></span><span style="display:flex;"><span>    PDWORD  FunctionAddressArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfFunctions);
</span></span><span style="display:flex;"><span>    PWORD   FunctionOrdinalArray <span style="color:#f92672">=</span> (PWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNameOrdinals);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (DWORD i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> pImgExportDir<span style="color:#f92672">-&gt;</span>NumberOfFunctions; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        CHAR<span style="color:#f92672">*</span> pFunctionName <span style="color:#f92672">=</span> (CHAR<span style="color:#f92672">*</span>)(pBase <span style="color:#f92672">+</span> FunctionNameArray[i]);
</span></span><span style="display:flex;"><span>        PVOID	pFunctionAddress <span style="color:#f92672">=</span> (PVOID)(pBase <span style="color:#f92672">+</span> FunctionAddressArray[FunctionOrdinalArray[i]]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Hashing every function name pFunctionName
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// If both hashes are equal then we found the function we want 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (dwApiNameHash <span style="color:#f92672">==</span> <span style="color:#a6e22e">HASHA</span>(pFunctionName)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> pFunctionAddress;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This code, besides the hashing part, mostly does checks on the PE fields to make sure everything is correct before continuing. This is usually what malwares do to make sure they will definitely run on the victim&rsquo;s machine and would ideally not want to risk running on some error on runtime.</p>
<p>We can break down the checks and make a short introductory on loading a PE file on memory, but a more <a href="%22https://connar.github.io/posts/insideapefile.md%22">in depth post</a> will be posted in the future regarding this.</p>
<p><strong>To begin with</strong>, we make sure that neither the handle to the DLL&rsquo;s address nor the Hash of the target function that are passed as parameters are null:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>FARPROC <span style="color:#a6e22e">GetProcAddressH</span>(HMODULE hModule, DWORD dwApiNameHash) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (hModule <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> dwApiNameHash <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    PBYTE pBase <span style="color:#f92672">=</span> (PBYTE)hModule;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* -- more -- */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Continuing on</strong>, we cast the pBase (Which is just the handle to the address of the DLL) to <code>PIMAGE_DOS_HEADER</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>FARPROC <span style="color:#a6e22e">GetProcAddressH</span>(HMODULE hModule, DWORD dwApiNameHash) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (hModule <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> dwApiNameHash <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    PBYTE pBase <span style="color:#f92672">=</span> (PBYTE)hModule;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PIMAGE_DOS_HEADER pImgDosHdr <span style="color:#f92672">=</span> (PIMAGE_DOS_HEADER)pBase;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pImgDosHdr<span style="color:#f92672">-&gt;</span>e_magic <span style="color:#f92672">!=</span> IMAGE_DOS_SIGNATURE)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* -- more -- */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Why? Well, the handle just currently points to a memory address. This memory address contains the bytes of the DLL. These bytes are not just &ldquo;bytes&rdquo; but they represent fields of a struct - specifically that of an IMAGE_DOS_HEADER, since DLL&rsquo;s such as EXE start with this struct.<br>
In other words, the address where the pBase has is the memory address of a series of bytes, that when casted to <code>PIMAGE_DOS_HEADER</code> (since this is the appropriate starting struct for a DLL) gives us access to its fields:</p>
<p><img loading="lazy" src="/posts/apihashing/apihashing1.png" alt="does header"  />
</p>
<p>This cast to <code>PIMAGE_DOS_HEADER</code> which is the top header of the DLL gives us all we need to calculate the addresses of the rest of the headers, as we will see shortly.</p>
<p>The code, after casting to the appropriate data structure, checks if the e_magic is equal to IMAGE_DOS_SIGNATURE. The IMAGE_DOS_SIGNATURE is actually <code>MZ</code>, and thus, the e_magic is always <code>MZ</code> for an executable/dll file. The full struct of <code>IMAGE_DOS_HEADER</code> that contains this field is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IMAGE_DOS_HEADER
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     WORD e_magic;
</span></span><span style="display:flex;"><span>     WORD e_cblp;
</span></span><span style="display:flex;"><span>     WORD e_cp;
</span></span><span style="display:flex;"><span>     WORD e_crlc;
</span></span><span style="display:flex;"><span>     WORD e_cparhdr;
</span></span><span style="display:flex;"><span>     WORD e_minalloc;
</span></span><span style="display:flex;"><span>     WORD e_maxalloc;
</span></span><span style="display:flex;"><span>     WORD e_ss;
</span></span><span style="display:flex;"><span>     WORD e_sp;
</span></span><span style="display:flex;"><span>     WORD e_csum;
</span></span><span style="display:flex;"><span>     WORD e_ip;
</span></span><span style="display:flex;"><span>     WORD e_cs;
</span></span><span style="display:flex;"><span>     WORD e_lfarlc;
</span></span><span style="display:flex;"><span>     WORD e_ovno;
</span></span><span style="display:flex;"><span>     WORD e_res[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>     WORD e_oemid;
</span></span><span style="display:flex;"><span>     WORD e_oeminfo;
</span></span><span style="display:flex;"><span>     WORD e_res2[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>     LONG e_lfanew;
</span></span><span style="display:flex;"><span>} IMAGE_DOS_HEADER, <span style="color:#f92672">*</span>PIMAGE_DOS_HEADER;
</span></span></code></pre></div><p><strong>After the validation for the MZ header</strong>, we use the pBase (the base address of our dll) in combination with a field of the <code>IMAGE_DOS_HEADER</code> struct to calculate the VA (Virtual Address) of the IMAGE_NT_HEADERS struct, which is the third header seen in the previous image (&lsquo;NT Headers&rsquo;):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>FARPROC <span style="color:#a6e22e">GetProcAddressH</span>(HMODULE hModule, DWORD dwApiNameHash) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (hModule <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> dwApiNameHash <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    PBYTE pBase <span style="color:#f92672">=</span> (PBYTE)hModule;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PIMAGE_DOS_HEADER pImgDosHdr <span style="color:#f92672">=</span> (PIMAGE_DOS_HEADER)pBase;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pImgDosHdr<span style="color:#f92672">-&gt;</span>e_magic <span style="color:#f92672">!=</span> IMAGE_DOS_SIGNATURE)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PIMAGE_NT_HEADERS pImgNtHdrs <span style="color:#f92672">=</span> (PIMAGE_NT_HEADERS)(pBase <span style="color:#f92672">+</span> pImgDosHdr<span style="color:#f92672">-&gt;</span>e_lfanew);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pImgNtHdrs<span style="color:#f92672">-&gt;</span>Signature <span style="color:#f92672">!=</span> IMAGE_NT_SIGNATURE)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* -- more -- */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The field used here from the <code>IMAGE_DOS_HEADER</code> is the e_lfanew field, which is also known as RVA (Relative Virtual Address). Basically the relationship between the base address, RVA and VA goes as the following:</p>
<ul>
<li><strong>Base address</strong>: This is an address in memory that acts as the starting point. It simply is where something initially was saved at. Here our DLL was loaded at an address which we have stored in our pBase variable.</li>
<li><strong>RVA</strong>: Relative Virtual Address is like an offset of some field of our DLL. Basically, the DLL contains many stucts and instead of storing the address of each one, we just use the base address of our DLL (where it starts) and an offset, which is how far away is from the starting point (baseAddress).</li>
<li><strong>VA</strong>: Virtual Address is the actual address (starting point) of the field/struct we want to land on.</li>
</ul>
<p><strong>In summary: baseAddress + RVA[something] = VA[something]</strong></p>
<p>So, here the e_lfanew is the offset of the DLL&rsquo;s base address to the NT_HEADER struct. By adding the base address of our DLL with this field, we get the VA (actual address) of the NT_HEADER struct that we can now cast to the corresponding type and gain access to its fields.</p>
<p>The struct of the IMAGE_NT_HEADERS is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IMAGE_NT_HEADERS {
</span></span><span style="display:flex;"><span>  DWORD                   Signature;
</span></span><span style="display:flex;"><span>  IMAGE_FILE_HEADER       FileHeader;
</span></span><span style="display:flex;"><span>  IMAGE_OPTIONAL_HEADER32 OptionalHeader;
</span></span><span style="display:flex;"><span>} IMAGE_NT_HEADERS32, <span style="color:#f92672">*</span>PIMAGE_NT_HEADERS32;
</span></span></code></pre></div><p>The Signature we are doing the check with is actually the &lsquo;PE&rsquo; that executables and DLL&rsquo;s have. This is just another check the program does before proceeding forward with the API Hashing.</p>
<p><strong>Moving further</strong>, it is now time to finally get the function names, their addresses and their ordinals (integer numbers representing the functions):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>FARPROC <span style="color:#a6e22e">GetProcAddressH</span>(HMODULE hModule, DWORD dwApiNameHash) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (hModule <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> dwApiNameHash <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PBYTE pBase <span style="color:#f92672">=</span> (PBYTE)hModule;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PIMAGE_DOS_HEADER         pImgDosHdr <span style="color:#f92672">=</span> (PIMAGE_DOS_HEADER)pBase;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pImgDosHdr<span style="color:#f92672">-&gt;</span>e_magic <span style="color:#f92672">!=</span> IMAGE_DOS_SIGNATURE)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PIMAGE_NT_HEADERS         pImgNtHdrs <span style="color:#f92672">=</span> (PIMAGE_NT_HEADERS)(pBase <span style="color:#f92672">+</span> pImgDosHdr<span style="color:#f92672">-&gt;</span>e_lfanew);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pImgNtHdrs<span style="color:#f92672">-&gt;</span>Signature <span style="color:#f92672">!=</span> IMAGE_NT_SIGNATURE)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    IMAGE_OPTIONAL_HEADER     ImgOptHdr <span style="color:#f92672">=</span> pImgNtHdrs<span style="color:#f92672">-&gt;</span>OptionalHeader;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PIMAGE_EXPORT_DIRECTORY   pImgExportDir <span style="color:#f92672">=</span> (PIMAGE_EXPORT_DIRECTORY)(pBase <span style="color:#f92672">+</span> ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PDWORD  FunctionNameArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNames);
</span></span><span style="display:flex;"><span>    PDWORD  FunctionAddressArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfFunctions);
</span></span><span style="display:flex;"><span>    PWORD   FunctionOrdinalArray <span style="color:#f92672">=</span> (PWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNameOrdinals);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* -- more -- */</span>
</span></span></code></pre></div><p>The code continues with using the ImgOptHdr we previously calculated in order to load the necessary fields and structs that contain the information we are aiming for. But what is the ImgOptHdr and what useful info does it contain?<br>
It&rsquo;s struct is the following (IMAGE_OPTIONAL_HEADER):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IMAGE_OPTIONAL_HEADER {
</span></span><span style="display:flex;"><span>  WORD                 Magic;
</span></span><span style="display:flex;"><span>  BYTE                 MajorLinkerVersion;
</span></span><span style="display:flex;"><span>  BYTE                 MinorLinkerVersion;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfCode;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfInitializedData;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfUninitializedData;
</span></span><span style="display:flex;"><span>  DWORD                AddressOfEntryPoint;
</span></span><span style="display:flex;"><span>  DWORD                BaseOfCode;
</span></span><span style="display:flex;"><span>  DWORD                BaseOfData;
</span></span><span style="display:flex;"><span>  DWORD                ImageBase;
</span></span><span style="display:flex;"><span>  DWORD                SectionAlignment;
</span></span><span style="display:flex;"><span>  DWORD                FileAlignment;
</span></span><span style="display:flex;"><span>  WORD                 MajorOperatingSystemVersion;
</span></span><span style="display:flex;"><span>  WORD                 MinorOperatingSystemVersion;
</span></span><span style="display:flex;"><span>  WORD                 MajorImageVersion;
</span></span><span style="display:flex;"><span>  WORD                 MinorImageVersion;
</span></span><span style="display:flex;"><span>  WORD                 MajorSubsystemVersion;
</span></span><span style="display:flex;"><span>  WORD                 MinorSubsystemVersion;
</span></span><span style="display:flex;"><span>  DWORD                Win32VersionValue;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfImage;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfHeaders;
</span></span><span style="display:flex;"><span>  DWORD                CheckSum;
</span></span><span style="display:flex;"><span>  WORD                 Subsystem;
</span></span><span style="display:flex;"><span>  WORD                 DllCharacteristics;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfStackReserve;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfStackCommit;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfHeapReserve;
</span></span><span style="display:flex;"><span>  DWORD                SizeOfHeapCommit;
</span></span><span style="display:flex;"><span>  DWORD                LoaderFlags;
</span></span><span style="display:flex;"><span>  DWORD                NumberOfRvaAndSizes;
</span></span><span style="display:flex;"><span>  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
</span></span><span style="display:flex;"><span>} IMAGE_OPTIONAL_HEADER32, <span style="color:#f92672">*</span>PIMAGE_OPTIONAL_HEADER32;
</span></span></code></pre></div><p>In the code we utilized the DataDirectory table field and specifically the index named &lsquo;IMAGE_DIRECTORY_ENTRY_EXPORT&rsquo;. Taking a look at what the IMAGE_DATA_DIRECTORY struct contains, we see the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IMAGE_DATA_DIRECTORY {
</span></span><span style="display:flex;"><span>  DWORD VirtualAddress;
</span></span><span style="display:flex;"><span>  DWORD Size;
</span></span><span style="display:flex;"><span>} IMAGE_DATA_DIRECTORY, <span style="color:#f92672">*</span>PIMAGE_DATA_DIRECTORY;
</span></span></code></pre></div><p>So basically the DataDirectory field is a table that contains structs with fields a VirtualAddress and Size. In our code we used the index IMAGE_DIRECTORY_ENTRY_EXPORT and that led us to a _IMAGE_DATA_DIRECTORY with a VirtualAddress - since this is what we are taking with the &lsquo;-&gt;&rsquo; symbol - and Size. But why we used the specific index and why does this can be casted back to IMAGE_EXPORT_DIRECTORY?<br>
We simply CTRL+click onto the index and see the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Directory Entries
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   </span><span style="color:#75715e">// Export Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   </span><span style="color:#75715e">// Import Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   </span><span style="color:#75715e">// Resource Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   </span><span style="color:#75715e">// Exception Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   </span><span style="color:#75715e">// Security Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   </span><span style="color:#75715e">// Base Relocation Table
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   </span><span style="color:#75715e">// Debug Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   </span><span style="color:#75715e">// Architecture Specific Data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   </span><span style="color:#75715e">// RVA of GP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_TLS             9   </span><span style="color:#75715e">// TLS Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   </span><span style="color:#75715e">// Load Configuration Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   </span><span style="color:#75715e">// Bound Import Directory in headers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_IAT            12   </span><span style="color:#75715e">// Import Address Table
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   </span><span style="color:#75715e">// Delay Load Import Descriptors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   </span><span style="color:#75715e">// COM Runtime descriptor
</span></span></span></code></pre></div><p>So the IMAGE_DIRECTORY_ENTRY_EXPORT is equal to 0 (the first entry) and it basically points to the Export directory. Awesome! That is the reason we cast the result back to IMAGE_EXPORT_DIRECTORY.</p>
<p>Taking a look at the IMAGE_EXPORT_DIRECTORY struct, we see the following fields:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IMAGE_EXPORT_DIRECTORY {
</span></span><span style="display:flex;"><span>     DWORD   Characteristics;
</span></span><span style="display:flex;"><span>     DWORD   TimeDateStamp;
</span></span><span style="display:flex;"><span>     WORD    MajorVersion;
</span></span><span style="display:flex;"><span>     WORD    MinorVersion;
</span></span><span style="display:flex;"><span>     DWORD   Name;
</span></span><span style="display:flex;"><span>     DWORD   Base;
</span></span><span style="display:flex;"><span>     DWORD   NumberOfFunctions;
</span></span><span style="display:flex;"><span>     DWORD   NumberOfNames;
</span></span><span style="display:flex;"><span>     DWORD   AddressOfFunctions;     <span style="color:#75715e">// RVA from base of image
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     DWORD   AddressOfNames;         <span style="color:#75715e">// RVA from base of image
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     DWORD   AddressOfNameOrdinals;  <span style="color:#75715e">// RVA from base of image
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> };
</span></span></code></pre></div><p>As the comments explain, the AddressOfFunctinos, AddressOfNames and AddressOfNameOrdinals are RVA&rsquo;s from the base address. So this is why we once again use pBase plus these to get the VA (the actual address) of these fields.</p>
<p><strong>Finally</strong>, we loop through the function names and ordinals of each function, hash each one and compare with our target hash:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>FARPROC <span style="color:#a6e22e">GetProcAddressH</span>(HMODULE hModule, DWORD dwApiNameHash) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (hModule <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> dwApiNameHash <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PBYTE pBase <span style="color:#f92672">=</span> (PBYTE)hModule;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PIMAGE_DOS_HEADER         pImgDosHdr <span style="color:#f92672">=</span> (PIMAGE_DOS_HEADER)pBase;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pImgDosHdr<span style="color:#f92672">-&gt;</span>e_magic <span style="color:#f92672">!=</span> IMAGE_DOS_SIGNATURE)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PIMAGE_NT_HEADERS         pImgNtHdrs <span style="color:#f92672">=</span> (PIMAGE_NT_HEADERS)(pBase <span style="color:#f92672">+</span> pImgDosHdr<span style="color:#f92672">-&gt;</span>e_lfanew);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pImgNtHdrs<span style="color:#f92672">-&gt;</span>Signature <span style="color:#f92672">!=</span> IMAGE_NT_SIGNATURE)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    IMAGE_OPTIONAL_HEADER     ImgOptHdr <span style="color:#f92672">=</span> pImgNtHdrs<span style="color:#f92672">-&gt;</span>OptionalHeader;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PIMAGE_EXPORT_DIRECTORY   pImgExportDir <span style="color:#f92672">=</span> (PIMAGE_EXPORT_DIRECTORY)(pBase <span style="color:#f92672">+</span> ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PDWORD  FunctionNameArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNames);
</span></span><span style="display:flex;"><span>    PDWORD  FunctionAddressArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfFunctions);
</span></span><span style="display:flex;"><span>    PWORD   FunctionOrdinalArray <span style="color:#f92672">=</span> (PWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNameOrdinals);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (DWORD i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> pImgExportDir<span style="color:#f92672">-&gt;</span>NumberOfFunctions; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    CHAR<span style="color:#f92672">*</span> pFunctionName <span style="color:#f92672">=</span> (CHAR<span style="color:#f92672">*</span>)(pBase <span style="color:#f92672">+</span> FunctionNameArray[i]);
</span></span><span style="display:flex;"><span>    PVOID	pFunctionAddress <span style="color:#f92672">=</span> (PVOID)(pBase <span style="color:#f92672">+</span> FunctionAddressArray[FunctionOrdinalArray[i]]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Hashing every function name pFunctionName
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// If both hashes are equal then we found the function we want 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (dwApiNameHash <span style="color:#f92672">==</span> <span style="color:#a6e22e">HASHA</span>(pFunctionName)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> pFunctionAddress;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> NULL;
</span></span></code></pre></div><p>Things to note here is that the VA of FunctionNameArray and FunctionAddressArray are arrays that contain RVA&rsquo;s, so that&rsquo;s why we again use pBase for the calculations of the actual addresses.<br>
Finally, we use the hashing of the function&rsquo;s name and comparisson with the target hash.</p>
<p>The full code is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;winternl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define INITIAL_SEED	7	
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Generate JenkinsOneAtATime32Bit hashes from Ascii input string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>UINT32 <span style="color:#a6e22e">HashStringJenkinsOneAtATime32BitA</span>(_In_ PCHAR String)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    SIZE_T Index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    UINT32 Hash <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    SIZE_T Length <span style="color:#f92672">=</span> <span style="color:#a6e22e">lstrlenA</span>(String);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (Index <span style="color:#f92672">!=</span> Length)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Hash <span style="color:#f92672">+=</span> String[Index<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>        Hash <span style="color:#f92672">+=</span> Hash <span style="color:#f92672">&lt;&lt;</span> INITIAL_SEED;
</span></span><span style="display:flex;"><span>        Hash <span style="color:#f92672">^=</span> Hash <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">6</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Hash <span style="color:#f92672">+=</span> Hash <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    Hash <span style="color:#f92672">^=</span> Hash <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">11</span>;
</span></span><span style="display:flex;"><span>    Hash <span style="color:#f92672">+=</span> Hash <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">15</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Hash;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define HASHA(API) (HashStringJenkinsOneAtATime32BitA((PCHAR) API))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MessageBoxA_HASH    0xF10E27CA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>PfnMessageBoxA)(HWND, LPCSTR, LPCSTR, UINT);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>FARPROC <span style="color:#a6e22e">GetProcAddressH</span>(HMODULE hModule, DWORD dwApiNameHash) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (hModule <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> dwApiNameHash <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PBYTE pBase <span style="color:#f92672">=</span> (PBYTE)hModule;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PIMAGE_DOS_HEADER         pImgDosHdr <span style="color:#f92672">=</span> (PIMAGE_DOS_HEADER)pBase;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pImgDosHdr<span style="color:#f92672">-&gt;</span>e_magic <span style="color:#f92672">!=</span> IMAGE_DOS_SIGNATURE)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PIMAGE_NT_HEADERS         pImgNtHdrs <span style="color:#f92672">=</span> (PIMAGE_NT_HEADERS)(pBase <span style="color:#f92672">+</span> pImgDosHdr<span style="color:#f92672">-&gt;</span>e_lfanew);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pImgNtHdrs<span style="color:#f92672">-&gt;</span>Signature <span style="color:#f92672">!=</span> IMAGE_NT_SIGNATURE)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    IMAGE_OPTIONAL_HEADER     ImgOptHdr <span style="color:#f92672">=</span> pImgNtHdrs<span style="color:#f92672">-&gt;</span>OptionalHeader;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PIMAGE_EXPORT_DIRECTORY   pImgExportDir <span style="color:#f92672">=</span> (PIMAGE_EXPORT_DIRECTORY)(pBase <span style="color:#f92672">+</span> ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PDWORD  FunctionNameArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNames);
</span></span><span style="display:flex;"><span>    PDWORD  FunctionAddressArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfFunctions);
</span></span><span style="display:flex;"><span>    PWORD   FunctionOrdinalArray <span style="color:#f92672">=</span> (PWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNameOrdinals);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (DWORD i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> pImgExportDir<span style="color:#f92672">-&gt;</span>NumberOfFunctions; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        CHAR<span style="color:#f92672">*</span> pFunctionName <span style="color:#f92672">=</span> (CHAR<span style="color:#f92672">*</span>)(pBase <span style="color:#f92672">+</span> FunctionNameArray[i]);
</span></span><span style="display:flex;"><span>        PVOID	pFunctionAddress <span style="color:#f92672">=</span> (PVOID)(pBase <span style="color:#f92672">+</span> FunctionAddressArray[FunctionOrdinalArray[i]]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Hashing every function name pFunctionName
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// If both hashes are equal then we found the function we want 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (dwApiNameHash <span style="color:#f92672">==</span> <span style="color:#a6e22e">HASHA</span>(pFunctionName)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> pFunctionAddress;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">wchar_t</span><span style="color:#f92672">*</span> argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wprintf</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;Usage: %s &lt;target_dll_name&gt;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Get the DLL passed as argument, for example user32.dll
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">wchar_t</span><span style="color:#f92672">*</span> targetDllName <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Get a handle for this dll
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    HMODULE hModule_of_arg_dll <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetModuleHandleA</span>((LPCSTR)targetDllName);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// If it is not loaded in memory, load it now
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (hModule_of_arg_dll <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        hModule_of_arg_dll <span style="color:#f92672">=</span> <span style="color:#a6e22e">LoadLibraryA</span>(targetDllName);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Getting the address of MessageBoxA function using GetProcAddressH
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PfnMessageBoxA pMessageBoxA <span style="color:#f92672">=</span> (PfnMessageBoxA)<span style="color:#a6e22e">GetProcAddressH</span>(hModule_of_arg_dll, MessageBoxA_HASH);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pMessageBoxA <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] Couldn&#39;t Find Address Of Specified Function </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Calling MessageBoxA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">pMessageBoxA</span>(NULL, <span style="color:#e6db74">&#34;Avoiding names - executing functions&#34;</span>, <span style="color:#e6db74">&#34;:)&#34;</span>, MB_OK <span style="color:#f92672">|</span> MB_ICONEXCLAMATION);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[#] Press &lt;Enter&gt; To Quit ... &#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">getchar</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and the result upon execution is:<br>
<img loading="lazy" src="/posts/apihashing/apihashing2.png" alt="successful msgbox"  />
</p>
<h3 id="api-hashing---finding-the-dll-via-hash">API Hashing - Finding the DLL via hash<a hidden class="anchor" aria-hidden="true" href="#api-hashing---finding-the-dll-via-hash">#</a></h3>
<p>In the previous code we saw how to load a function via its hash, while giving the name of the dll name we want to use. But what about using the same technique for the dll name itself?<br>
Well, that is exactly what we are going to do. We will a hash both for the DLL name but also with a function within it (just as previously).</p>
<h4 id="code-additions">Code additions<a hidden class="anchor" aria-hidden="true" href="#code-additions">#</a></h4>
<p>Utilizing our previous code, we need to do some small aditions:</p>
<ul>
<li>Specify the Hash value for &ldquo;USER32.DLL&rdquo; hash that we will be comparing with.</li>
<li>Make the necessary checks to see if this dll is loaded to memory before proceeding.</li>
<li>Create our own CreateModuleHandleH function to return a Handle to the specified DLL. The way it will find the DLL will be using API Hashing, as previously.</li>
</ul>
<h5 id="specifying-the-hash">Specifying the Hash<a hidden class="anchor" aria-hidden="true" href="#specifying-the-hash">#</a></h5>
<p>The only line we need for this is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define USER32DLL_HASH      0x81E3778E
</span></span></span></code></pre></div><h5 id="check-if-user32dll-is-loaded">Check if USER32.DLL is loaded<a hidden class="anchor" aria-hidden="true" href="#check-if-user32dll-is-loaded">#</a></h5>
<p>A check we need to do before proceeding is to see if the DLL is loaded and load it to memory. If an error occurs, we stop the execution:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">LoadLibraryA</span>((LPCSTR)targetDllName) <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Failed to load target dll with error %d. Exiting...&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="getmodulehandleh">GetModuleHandleH<a hidden class="anchor" aria-hidden="true" href="#getmodulehandleh">#</a></h5>
<p>Now comes the custom function that will take care of the API Hashing for the DLL name. The full code is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _PEB_LDR_DATA_full
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ULONG Length;
</span></span><span style="display:flex;"><span>    BOOLEAN Initialized;
</span></span><span style="display:flex;"><span>    HANDLE SsHandle;
</span></span><span style="display:flex;"><span>    LIST_ENTRY InLoadOrderModuleList;
</span></span><span style="display:flex;"><span>    LIST_ENTRY InMemoryOrderModuleList;
</span></span><span style="display:flex;"><span>    LIST_ENTRY InInitializationOrderModuleList;
</span></span><span style="display:flex;"><span>    PVOID EntryInProgress;
</span></span><span style="display:flex;"><span>    BOOLEAN ShutdownInProgress;
</span></span><span style="display:flex;"><span>    HANDLE ShutdownThreadId;
</span></span><span style="display:flex;"><span>} PEB_LDR_DATA_full, <span style="color:#f92672">*</span> PPEB_LDR_DATA_full;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// this is the ldr module. Basically it refers to the information of a dll entry to ldr_module_table
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _LDR_MODULE_full {
</span></span><span style="display:flex;"><span>    LIST_ENTRY              InLoadOrderModuleList;
</span></span><span style="display:flex;"><span>    LIST_ENTRY              InMemoryOrderModuleList;
</span></span><span style="display:flex;"><span>    LIST_ENTRY              InInitializationOrderModuleList;
</span></span><span style="display:flex;"><span>    PVOID                   BaseAddress;
</span></span><span style="display:flex;"><span>    PVOID                   EntryPoint;
</span></span><span style="display:flex;"><span>    ULONG                   SizeOfImage;
</span></span><span style="display:flex;"><span>    UNICODE_STRING          FullDllName;
</span></span><span style="display:flex;"><span>    UNICODE_STRING          BaseDllName;
</span></span><span style="display:flex;"><span>    ULONG                   Flags;
</span></span><span style="display:flex;"><span>    SHORT                   LoadCount;
</span></span><span style="display:flex;"><span>    SHORT                   TlsIndex;
</span></span><span style="display:flex;"><span>    LIST_ENTRY              HashTableEntry;
</span></span><span style="display:flex;"><span>    ULONG                   TimeDateStamp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} LDR_MODULE_full, <span style="color:#f92672">*</span> PLDR_MODULE_full;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>HMODULE <span style="color:#a6e22e">GetModuleHandleH</span>(DWORD dwModuleNameHash) {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#ifdef _WIN64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        PPEB pPEB <span style="color:#f92672">=</span> (PPEB)<span style="color:#a6e22e">__readgsqword</span>(<span style="color:#ae81ff">0x60</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        PPEB pPEB <span style="color:#f92672">=</span> (PPEB)<span style="color:#a6e22e">__readfsdword</span>(<span style="color:#ae81ff">0x30</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    PPEB_LDR_DATA_full pLdr <span style="color:#f92672">=</span> pPEB<span style="color:#f92672">-&gt;</span>Ldr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    LIST_ENTRY<span style="color:#f92672">*</span> pListEntry <span style="color:#f92672">=</span> pLdr<span style="color:#f92672">-&gt;</span>InLoadOrderModuleList.Flink;
</span></span><span style="display:flex;"><span>    LIST_ENTRY<span style="color:#f92672">*</span> pListHead <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>pLdr<span style="color:#f92672">-&gt;</span>InLoadOrderModuleList;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (pListEntry <span style="color:#f92672">!=</span> pListHead) {
</span></span><span style="display:flex;"><span>        PLDR_MODULE_full pLdrModule <span style="color:#f92672">=</span> <span style="color:#a6e22e">CONTAINING_RECORD</span>(pListEntry, LDR_MODULE_full, InLoadOrderModuleList);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Print the BaseAddress and BaseDllName
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;BaseAddress: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pLdrModule<span style="color:#f92672">-&gt;</span>BaseAddress);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wprintf</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;BaseDllName: %wZ</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>pLdrModule<span style="color:#f92672">-&gt;</span>BaseDllName);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> dllName[<span style="color:#ae81ff">256</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">snprintf</span>(dllName, <span style="color:#66d9ef">sizeof</span>(dllName), <span style="color:#e6db74">&#34;%wZ&#34;</span>, pLdrModule<span style="color:#f92672">-&gt;</span>BaseDllName);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;HASH: 0x%x </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">HASHA</span>((PCHAR)dllName));
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( <span style="color:#a6e22e">HASHA</span>(dllName) <span style="color:#f92672">==</span> dwModuleNameHash) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">wprintf</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;Target DLL %wZ found at BaseAddress: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>pLdrModule<span style="color:#f92672">-&gt;</span>BaseDllName, pLdrModule<span style="color:#f92672">-&gt;</span>BaseAddress);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> pLdrModule<span style="color:#f92672">-&gt;</span>BaseAddress; <span style="color:#75715e">// Exit the program once the target DLL is found
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Move to the next entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pListEntry <span style="color:#f92672">=</span> pListEntry<span style="color:#f92672">-&gt;</span>Flink;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wprintf</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;Target DLL with hash %s not found</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dwModuleNameHash);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Most of this code has already been shown and explained in the <a href="%22https://connar.github.io/posts/peb/#code-example-2---loaded-dlls%22">Exploring PEB struct and its fields</a> post. We will explain only the new additions.</p>
<p><strong>First off</strong>, we get the current LDR_MODULE and print its hash value:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> dllName[<span style="color:#ae81ff">256</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">snprintf</span>(dllName, <span style="color:#66d9ef">sizeof</span>(dllName), <span style="color:#e6db74">&#34;%wZ&#34;</span>, pLdrModule<span style="color:#f92672">-&gt;</span>BaseDllName);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;HASH: 0x%x </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">HASHA</span>((PCHAR)dllName));
</span></span></code></pre></div><p>We use snprintf to format a unicode string (%wZ) - specifically the pLdrModule-&gt;BaseDllName - to a char* type. What we do is declare a buffer and copy the UNICODE_STRING that has been converted to char* into that buffer.</p>
<p><strong>Then</strong> we simply hash that dllName we just got from the Unicode convertion of the BaseDllName, and compare it with the parameter given to the function, which is the USER32.DLL hash. If there is a match, we return its BaseAddress (the address that this DLL is loaded in memory).</p>
<p>So the whole idea of this function GetModuleHandleH is to loop over all the loaded DLL&rsquo;s from the LDR_MODULE, hash and compare each one to the target hash.</p>
<p>The full code for hashing both the Dll and the target function is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;winternl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define INITIAL_SEED	7	
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Generate JenkinsOneAtATime32Bit hashes from Ascii input string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>UINT32 <span style="color:#a6e22e">HashStringJenkinsOneAtATime32BitA</span>(_In_ PCHAR String)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    SIZE_T Index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    UINT32 Hash <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    SIZE_T Length <span style="color:#f92672">=</span> <span style="color:#a6e22e">lstrlenA</span>(String);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (Index <span style="color:#f92672">!=</span> Length)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Hash <span style="color:#f92672">+=</span> String[Index<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>        Hash <span style="color:#f92672">+=</span> Hash <span style="color:#f92672">&lt;&lt;</span> INITIAL_SEED;
</span></span><span style="display:flex;"><span>        Hash <span style="color:#f92672">^=</span> Hash <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">6</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Hash <span style="color:#f92672">+=</span> Hash <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    Hash <span style="color:#f92672">^=</span> Hash <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">11</span>;
</span></span><span style="display:flex;"><span>    Hash <span style="color:#f92672">+=</span> Hash <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">15</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Hash;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define HASHA(API) (HashStringJenkinsOneAtATime32BitA((PCHAR) API))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define USER32DLL_HASH      0x81E3778E
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MessageBoxA_HASH    0xF10E27CA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>PfnMessageBoxA)(HWND, LPCSTR, LPCSTR, UINT);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// this is the ldr struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _PEB_LDR_DATA_full
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ULONG Length;
</span></span><span style="display:flex;"><span>    BOOLEAN Initialized;
</span></span><span style="display:flex;"><span>    HANDLE SsHandle;
</span></span><span style="display:flex;"><span>    LIST_ENTRY InLoadOrderModuleList;
</span></span><span style="display:flex;"><span>    LIST_ENTRY InMemoryOrderModuleList;
</span></span><span style="display:flex;"><span>    LIST_ENTRY InInitializationOrderModuleList;
</span></span><span style="display:flex;"><span>    PVOID EntryInProgress;
</span></span><span style="display:flex;"><span>    BOOLEAN ShutdownInProgress;
</span></span><span style="display:flex;"><span>    HANDLE ShutdownThreadId;
</span></span><span style="display:flex;"><span>} PEB_LDR_DATA_full, <span style="color:#f92672">*</span> PPEB_LDR_DATA_full;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// this is the ldr module. Basically it refers to the information of a dll entry to ldr_module_table
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _LDR_MODULE_full {
</span></span><span style="display:flex;"><span>    LIST_ENTRY              InLoadOrderModuleList;
</span></span><span style="display:flex;"><span>    LIST_ENTRY              InMemoryOrderModuleList;
</span></span><span style="display:flex;"><span>    LIST_ENTRY              InInitializationOrderModuleList;
</span></span><span style="display:flex;"><span>    PVOID                   BaseAddress;
</span></span><span style="display:flex;"><span>    PVOID                   EntryPoint;
</span></span><span style="display:flex;"><span>    ULONG                   SizeOfImage;
</span></span><span style="display:flex;"><span>    UNICODE_STRING          FullDllName;
</span></span><span style="display:flex;"><span>    UNICODE_STRING          BaseDllName;
</span></span><span style="display:flex;"><span>    ULONG                   Flags;
</span></span><span style="display:flex;"><span>    SHORT                   LoadCount;
</span></span><span style="display:flex;"><span>    SHORT                   TlsIndex;
</span></span><span style="display:flex;"><span>    LIST_ENTRY              HashTableEntry;
</span></span><span style="display:flex;"><span>    ULONG                   TimeDateStamp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} LDR_MODULE_full, <span style="color:#f92672">*</span> PLDR_MODULE_full;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>FARPROC <span style="color:#a6e22e">GetProcAddressH</span>(HMODULE hModule, DWORD dwApiNameHash) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (hModule <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> dwApiNameHash <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PBYTE pBase <span style="color:#f92672">=</span> (PBYTE)hModule;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PIMAGE_DOS_HEADER         pImgDosHdr <span style="color:#f92672">=</span> (PIMAGE_DOS_HEADER)pBase;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pImgDosHdr<span style="color:#f92672">-&gt;</span>e_magic <span style="color:#f92672">!=</span> IMAGE_DOS_SIGNATURE)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PIMAGE_NT_HEADERS         pImgNtHdrs <span style="color:#f92672">=</span> (PIMAGE_NT_HEADERS)(pBase <span style="color:#f92672">+</span> pImgDosHdr<span style="color:#f92672">-&gt;</span>e_lfanew);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pImgNtHdrs<span style="color:#f92672">-&gt;</span>Signature <span style="color:#f92672">!=</span> IMAGE_NT_SIGNATURE)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    IMAGE_OPTIONAL_HEADER     ImgOptHdr <span style="color:#f92672">=</span> pImgNtHdrs<span style="color:#f92672">-&gt;</span>OptionalHeader;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PIMAGE_EXPORT_DIRECTORY   pImgExportDir <span style="color:#f92672">=</span> (PIMAGE_EXPORT_DIRECTORY)(pBase <span style="color:#f92672">+</span> ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PDWORD  FunctionNameArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNames);
</span></span><span style="display:flex;"><span>    PDWORD  FunctionAddressArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfFunctions);
</span></span><span style="display:flex;"><span>    PWORD   FunctionOrdinalArray <span style="color:#f92672">=</span> (PWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNameOrdinals);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (DWORD i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> pImgExportDir<span style="color:#f92672">-&gt;</span>NumberOfFunctions; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        CHAR<span style="color:#f92672">*</span> pFunctionName <span style="color:#f92672">=</span> (CHAR<span style="color:#f92672">*</span>)(pBase <span style="color:#f92672">+</span> FunctionNameArray[i]);
</span></span><span style="display:flex;"><span>        PVOID	pFunctionAddress <span style="color:#f92672">=</span> (PVOID)(pBase <span style="color:#f92672">+</span> FunctionAddressArray[FunctionOrdinalArray[i]]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Hashing every function name pFunctionName
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// If both hashes are equal then we found the function we want 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (dwApiNameHash <span style="color:#f92672">==</span> <span style="color:#a6e22e">HASHA</span>(pFunctionName)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> pFunctionAddress;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>HMODULE <span style="color:#a6e22e">GetModuleHandleH</span>(DWORD dwModuleNameHash) {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#ifdef _WIN64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        PPEB pPEB <span style="color:#f92672">=</span> (PPEB)<span style="color:#a6e22e">__readgsqword</span>(<span style="color:#ae81ff">0x60</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        PPEB pPEB <span style="color:#f92672">=</span> (PPEB)<span style="color:#a6e22e">__readfsdword</span>(<span style="color:#ae81ff">0x30</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    PPEB_LDR_DATA_full pLdr <span style="color:#f92672">=</span> pPEB<span style="color:#f92672">-&gt;</span>Ldr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    LIST_ENTRY<span style="color:#f92672">*</span> pListEntry <span style="color:#f92672">=</span> pLdr<span style="color:#f92672">-&gt;</span>InLoadOrderModuleList.Flink;
</span></span><span style="display:flex;"><span>    LIST_ENTRY<span style="color:#f92672">*</span> pListHead <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>pLdr<span style="color:#f92672">-&gt;</span>InLoadOrderModuleList;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (pListEntry <span style="color:#f92672">!=</span> pListHead) {
</span></span><span style="display:flex;"><span>        PLDR_MODULE_full pLdrModule <span style="color:#f92672">=</span> <span style="color:#a6e22e">CONTAINING_RECORD</span>(pListEntry, LDR_MODULE_full, InLoadOrderModuleList);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Print the BaseAddress and BaseDllName
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;BaseAddress: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pLdrModule<span style="color:#f92672">-&gt;</span>BaseAddress);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wprintf</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;BaseDllName: %wZ</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>pLdrModule<span style="color:#f92672">-&gt;</span>BaseDllName);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> dllName[<span style="color:#ae81ff">256</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">snprintf</span>(dllName, <span style="color:#66d9ef">sizeof</span>(dllName), <span style="color:#e6db74">&#34;%wZ&#34;</span>, pLdrModule<span style="color:#f92672">-&gt;</span>BaseDllName);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;HASH: 0x%x </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">HASHA</span>((PCHAR)dllName));
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( <span style="color:#a6e22e">HASHA</span>(dllName) <span style="color:#f92672">==</span> dwModuleNameHash) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">wprintf</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;Target DLL %wZ found at BaseAddress: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>pLdrModule<span style="color:#f92672">-&gt;</span>BaseDllName, pLdrModule<span style="color:#f92672">-&gt;</span>BaseAddress);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> pLdrModule<span style="color:#f92672">-&gt;</span>BaseAddress; <span style="color:#75715e">// Exit the program once the target DLL is found
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Move to the next entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pListEntry <span style="color:#f92672">=</span> pListEntry<span style="color:#f92672">-&gt;</span>Flink;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wprintf</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;Target DLL with hash %s not found</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dwModuleNameHash);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">wchar_t</span><span style="color:#f92672">*</span> argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wprintf</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;Usage: %s &lt;target_dll_name&gt;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Get the DLL passed as argument, for example user32.dll
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">wchar_t</span><span style="color:#f92672">*</span> targetDllName <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Make sure target Dll is loaded before proceeding to enumerate its functions.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">LoadLibraryA</span>((LPCSTR)targetDllName) <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Failed to load target dll with error %d. Exiting...&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    HMODULE hModule_of_arg_dll <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetModuleHandleH</span>(USER32DLL_HASH);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Getting the address of MessageBoxA function using GetProcAddressH
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PfnMessageBoxA pMessageBoxA <span style="color:#f92672">=</span> (PfnMessageBoxA)<span style="color:#a6e22e">GetProcAddressH</span>(hModule_of_arg_dll, MessageBoxA_HASH);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pMessageBoxA <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] Couldn&#39;t Find Address Of Specified Function </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Calling MessageBoxA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">pMessageBoxA</span>(NULL, <span style="color:#e6db74">&#34;Avoiding names - executing functions&#34;</span>, <span style="color:#e6db74">&#34;:)&#34;</span>, MB_OK <span style="color:#f92672">|</span> MB_ICONEXCLAMATION);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[#] Press &lt;Enter&gt; To Quit ... &#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">getchar</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Executing the code outputs the following:</p>
<p><img loading="lazy" src="/posts/apihashing/apihashing3.png" alt="dll api hashing"  />
</p>
<h2 id="whats-next">What&rsquo;s next<a hidden class="anchor" aria-hidden="true" href="#whats-next">#</a></h2>
<p>Here we just made 2/3 custom functions:</p>
<ul>
<li>GetModuleHandleH</li>
<li>GetProcAddressH</li>
</ul>
<p>In the future we will see how to make a custom LoadLibraryH function to apply another API Hashing layer instead of loading the DLL with its plain name.</p>
<p><strong>References</strong></p>
<blockquote>
    <ul>
        <li> [1] <a href="https://www.ired.team/offensive-security/defense-evasion/windows-api-hashing-in-malware">Read Team Notes: <i>Windows API Hashing in Malware</i></a></li>
        <li> [2] <a href="https://maxkersten.nl/binary-analysis-course/malware-snippets/api-hashing/">Max Kersten: <i>API Hashing</i></a></li>
        <li> [3] <a href="https://blog.christophetd.fr/dll-unlinking/">Christophe Tafani-Dereeper: <i>Hiding in Plain Sight: Unlinking Malicious DLLs from the PEB</i></a></li>
        <li> [3] <a href="https://wirediver.com/windows-peb-parsing-a-binary-with-no-imports/">WireDiver: <i>Windows PEB parsing – A binary with no imports</i></a></li>
        <li> [4] <a href="https://gbmaster.wordpress.com/2012/03/02/on-the-road-of-hiding-peb-pe-format-handling-and-dll-loading-homemade-apis-part-2/">GB_MASTER: <i>ON THE ROAD OF HIDING… PEB, PE FORMAT HANDLING AND DLL LOADING HOMEMADE APIS – PART 2</i></a></li>
<p></i></a></li>
</ul></p>
</blockquote>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/api-hashing/">API Hashing</a></li>
      <li><a href="http://localhost:1313/tags/windows-api/">Windows API</a></li>
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Journal of Connar</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
