<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Exploring PEB struct and its fields | Journal of Connar</title>
<meta name="keywords" content="PEB, LDR, Windows API">
<meta name="description" content=" 
Intro
This is the first post of the malware series that me and my friend @r4sti will be starting. We basically started learning malware concepts, dev and windows internals, and I will keep track of what we learn - like the rest of the things in this blog:)
Special thanks to him cause he is basically teaching me 70% of this stuff lol.">
<meta name="author" content="connar, r4sti">
<link rel="canonical" href="http://localhost:1313/posts/peb/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6da9a63d25a9608bca2f7f907a030e887a7dd3c3f3918e4cc113129361414bda.css" integrity="sha256-bammPSWpYIvKL3&#43;QegMOiHp908PzkY5MwRMSk2FBS9o=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/peb/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Journal of Connar (Alt + H)">Journal of Connar</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/mychallenges/" title="My Challenges">
                    <span>My Challenges</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/training/" title="Training">
                    <span>Training</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Exploring PEB struct and its fields
    </h1>
    <div class="post-meta"><span title='2024-05-11 20:03:02 +0200 CEST'>May 11, 2024</span>&nbsp;·&nbsp;20 min&nbsp;·&nbsp;connar, r4sti

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#intro" aria-label="Intro">Intro</a></li>
                <li>
                    <a href="#what-is-peb" aria-label="What is PEB">What is PEB</a></li>
                <li>
                    <a href="#theory-compared-to-a-real-world-sample" aria-label="Theory compared to a real world sample">Theory compared to a real world sample</a></li>
                <li>
                    <a href="#code-examples" aria-label="Code examples">Code examples</a><ul>
                        
                <li>
                    <a href="#code-example-1---isbeingdebugged" aria-label="Code example 1 - IsBeingDebugged">Code example 1 - IsBeingDebugged</a><ul>
                        
                <li>
                    <a href="#reading-the-peb" aria-label="Reading the PEB">Reading the PEB</a></li>
                <li>
                    <a href="#first-method" aria-label="First method">First method</a></li>
                <li>
                    <a href="#second-method" aria-label="Second method">Second method</a></li>
                <li>
                    <a href="#running-the-code" aria-label="Running the code">Running the code</a></li></ul>
                </li>
                <li>
                    <a href="#code-example-2---loaded-dlls" aria-label="Code example 2 - Loaded DLLs">Code example 2 - Loaded DLLs</a><ul>
                        
                <li>
                    <a href="#reading-the-peb-and-its-ldr-field" aria-label="Reading the PEB and its Ldr field">Reading the PEB and its Ldr field</a></li>
                <li>
                    <a href="#reading-ldr-inloadordermodulelists-fields" aria-label="Reading Ldr-&gt;InLoadOrderModuleList&rsquo;s fields">Reading Ldr-&gt;InLoadOrderModuleList&rsquo;s fields</a></li>
                <li>
                    <a href="#looping-through-all-loaded-dlls" aria-label="Looping through all loaded DLL&rsquo;s">Looping through all loaded DLL&rsquo;s</a></li>
                <li>
                    <a href="#printing-the-addresses-and-dlls" aria-label="Printing the addresses and DLL&rsquo;s">Printing the addresses and DLL&rsquo;s</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#peb-in-depth---x64dbg" aria-label="PEB in depth - x64dbg">PEB in depth - x64dbg</a><ul>
                        
                <li>
                    <a href="#peb-baseaddress" aria-label="PEB BaseAddress">PEB BaseAddress</a><ul>
                        
                <li>
                    <a href="#imagebaseaddress" aria-label="ImageBaseAddress">ImageBaseAddress</a></li>
                <li>
                    <a href="#ldr" aria-label="Ldr">Ldr</a></li>
                <li>
                    <a href="#flink-and-blink-pointers-of-the-list-head" aria-label="Flink and Blink Pointers of the List Head">Flink and Blink Pointers of the List Head</a></li></ul>
                </li>
                <li>
                    <a href="#whats-next" aria-label="What&rsquo;s next">What&rsquo;s next</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><style>
	fieldset {
		background: url('/img/test.gif') no-repeat center center;
		background-size: cover;
		border: 1px solid #ccc;
		padding: 10px;
		position: relative;
		z-index: 2;
		color: #dcdcdc;
		font-weight: 500;
	}
</style> 
<h2 id="intro">Intro<a hidden class="anchor" aria-hidden="true" href="#intro">#</a></h2>
<p>This is the first post of the malware series that me and my friend @r4sti will be starting. We basically started learning malware concepts, dev and windows internals, and I will keep track of what we learn - like the rest of the things in this blog:)<br>
<small><i>Special thanks to him cause he is basically teaching me 70% of this stuff lol.</i></small></p>
<p>So in this post, we will dive into:</p>
<ul>
<li>What is PEB</li>
<li>Theory compared to a real world sample</li>
<li>Code examples
<ul>
<li>IsBeingDebugged</li>
<li>Loaded DLLs</li>
</ul>
</li>
<li>PEB in depth - x64dbg</li>
<li>How it can be abused (dll-unlinking)</li>
</ul>
<h2 id="what-is-peb">What is PEB<a hidden class="anchor" aria-hidden="true" href="#what-is-peb">#</a></h2>
<p>The Process Environment Block (PEB) is a vital structure in the Windows operating system, residing in user-mode memory and accessible by the corresponding process.</p>
<p>Although primarily intended for use by the operating system, the PEB contains a wealth of information about the running process. This includes data on whether the process is being debugged, details on the modules loaded into memory, and the command line used to invoke the process. Due to the critical nature of this information, adversaries have several opportunities to exploit the PEB for malicious purposes.</p>
<p>The PEB structure based on microsoft, has the following struct:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _PEB {
</span></span><span style="display:flex;"><span>  BYTE                          Reserved1[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>  BYTE                          BeingDebugged;
</span></span><span style="display:flex;"><span>  BYTE                          Reserved2[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>  PVOID                         Reserved3[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>  PPEB_LDR_DATA                 Ldr;
</span></span><span style="display:flex;"><span>  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
</span></span><span style="display:flex;"><span>  PVOID                         Reserved4[<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>  PVOID                         AtlThunkSListPtr;
</span></span><span style="display:flex;"><span>  PVOID                         Reserved5;
</span></span><span style="display:flex;"><span>  ULONG                         Reserved6;
</span></span><span style="display:flex;"><span>  PVOID                         Reserved7;
</span></span><span style="display:flex;"><span>  ULONG                         Reserved8;
</span></span><span style="display:flex;"><span>  ULONG                         AtlThunkSListPtr32;
</span></span><span style="display:flex;"><span>  PVOID                         Reserved9[<span style="color:#ae81ff">45</span>];
</span></span><span style="display:flex;"><span>  BYTE                          Reserved10[<span style="color:#ae81ff">96</span>];
</span></span><span style="display:flex;"><span>  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
</span></span><span style="display:flex;"><span>  BYTE                          Reserved11[<span style="color:#ae81ff">128</span>];
</span></span><span style="display:flex;"><span>  PVOID                         Reserved12[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>  ULONG                         SessionId;
</span></span><span style="display:flex;"><span>} PEB, <span style="color:#f92672">*</span>PPEB;
</span></span></code></pre></div><p>but truth is, there is a bigger, undocumented struct of PEB, which contains a lot more information about this Windows structure. Based on the <a href="https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FProcess%2FPEB.html">NTAPI undocumented functions</a>, the full structure of PEB is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _PEB {
</span></span><span style="display:flex;"><span>  BOOLEAN                 InheritedAddressSpace;
</span></span><span style="display:flex;"><span>  BOOLEAN                 ReadImageFileExecOptions;
</span></span><span style="display:flex;"><span>  BOOLEAN                 BeingDebugged;
</span></span><span style="display:flex;"><span>  BOOLEAN                 Spare;
</span></span><span style="display:flex;"><span>  HANDLE                  Mutant;
</span></span><span style="display:flex;"><span>  PVOID                   ImageBaseAddress;
</span></span><span style="display:flex;"><span>  PPEB_LDR_DATA           LoaderData;
</span></span><span style="display:flex;"><span>  PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
</span></span><span style="display:flex;"><span>  PVOID                   SubSystemData;
</span></span><span style="display:flex;"><span>  PVOID                   ProcessHeap;
</span></span><span style="display:flex;"><span>  PVOID                   FastPebLock;
</span></span><span style="display:flex;"><span>  PPEBLOCKROUTINE         FastPebLockRoutine;
</span></span><span style="display:flex;"><span>  PPEBLOCKROUTINE         FastPebUnlockRoutine;
</span></span><span style="display:flex;"><span>  ULONG                   EnvironmentUpdateCount;
</span></span><span style="display:flex;"><span>  PPVOID                  KernelCallbackTable;
</span></span><span style="display:flex;"><span>  PVOID                   EventLogSection;
</span></span><span style="display:flex;"><span>  PVOID                   EventLog;
</span></span><span style="display:flex;"><span>  PPEB_FREE_BLOCK         FreeList;
</span></span><span style="display:flex;"><span>  ULONG                   TlsExpansionCounter;
</span></span><span style="display:flex;"><span>  PVOID                   TlsBitmap;
</span></span><span style="display:flex;"><span>  ULONG                   TlsBitmapBits[<span style="color:#ae81ff">0x2</span>];
</span></span><span style="display:flex;"><span>  PVOID                   ReadOnlySharedMemoryBase;
</span></span><span style="display:flex;"><span>  PVOID                   ReadOnlySharedMemoryHeap;
</span></span><span style="display:flex;"><span>  PPVOID                  ReadOnlyStaticServerData;
</span></span><span style="display:flex;"><span>  PVOID                   AnsiCodePageData;
</span></span><span style="display:flex;"><span>  PVOID                   OemCodePageData;
</span></span><span style="display:flex;"><span>  PVOID                   UnicodeCaseTableData;
</span></span><span style="display:flex;"><span>  ULONG                   NumberOfProcessors;
</span></span><span style="display:flex;"><span>  ULONG                   NtGlobalFlag;
</span></span><span style="display:flex;"><span>  BYTE                    Spare2[<span style="color:#ae81ff">0x4</span>];
</span></span><span style="display:flex;"><span>  LARGE_INTEGER           CriticalSectionTimeout;
</span></span><span style="display:flex;"><span>  ULONG                   HeapSegmentReserve;
</span></span><span style="display:flex;"><span>  ULONG                   HeapSegmentCommit;
</span></span><span style="display:flex;"><span>  ULONG                   HeapDeCommitTotalFreeThreshold;
</span></span><span style="display:flex;"><span>  ULONG                   HeapDeCommitFreeBlockThreshold;
</span></span><span style="display:flex;"><span>  ULONG                   NumberOfHeaps;
</span></span><span style="display:flex;"><span>  ULONG                   MaximumNumberOfHeaps;
</span></span><span style="display:flex;"><span>  PPVOID                  <span style="color:#f92672">*</span>ProcessHeaps;
</span></span><span style="display:flex;"><span>  PVOID                   GdiSharedHandleTable;
</span></span><span style="display:flex;"><span>  PVOID                   ProcessStarterHelper;
</span></span><span style="display:flex;"><span>  PVOID                   GdiDCAttributeList;
</span></span><span style="display:flex;"><span>  PVOID                   LoaderLock;
</span></span><span style="display:flex;"><span>  ULONG                   OSMajorVersion;
</span></span><span style="display:flex;"><span>  ULONG                   OSMinorVersion;
</span></span><span style="display:flex;"><span>  ULONG                   OSBuildNumber;
</span></span><span style="display:flex;"><span>  ULONG                   OSPlatformId;
</span></span><span style="display:flex;"><span>  ULONG                   ImageSubSystem;
</span></span><span style="display:flex;"><span>  ULONG                   ImageSubSystemMajorVersion;
</span></span><span style="display:flex;"><span>  ULONG                   ImageSubSystemMinorVersion;
</span></span><span style="display:flex;"><span>  ULONG                   GdiHandleBuffer[<span style="color:#ae81ff">0x22</span>];
</span></span><span style="display:flex;"><span>  ULONG                   PostProcessInitRoutine;
</span></span><span style="display:flex;"><span>  ULONG                   TlsExpansionBitmap;
</span></span><span style="display:flex;"><span>  BYTE                    TlsExpansionBitmapBits[<span style="color:#ae81ff">0x80</span>];
</span></span><span style="display:flex;"><span>  ULONG                   SessionId;
</span></span><span style="display:flex;"><span>} PEB, <span style="color:#f92672">*</span>PPEB;
</span></span></code></pre></div><h2 id="theory-compared-to-a-real-world-sample">Theory compared to a real world sample<a hidden class="anchor" aria-hidden="true" href="#theory-compared-to-a-real-world-sample">#</a></h2>
<p>What helped us get a better grasp of PEB&rsquo;s fields and how useful this struct can become from a threat actors perspective, is the <a href="%22https://viuleeenz.github.io/posts/2024/02/understanding-peb-and-ldr-structures-using-ida-and-lummastealer/%22">analysis of LummaStealer</a>.</p>
<p>I will input below the part of LummaStealer that utilizes PEB and will break it down part by part:</p>
<p><img alt="LummaStealer" loading="lazy" src="/posts/peb/peb1.png"></p>
<p>On the left we have the original assembly and on the right we have the same part of the code but renamed. We will observe why these parts have been modified as such.<br>
We need to start from the main part of the assembly, which is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>Line <span style="color:#ae81ff">1.</span> mov eax, large fs:<span style="color:#ae81ff">30</span>h		; eax <span style="color:#f92672">=</span> start of PEB structure
</span></span><span style="display:flex;"><span>Line <span style="color:#ae81ff">2.</span> mov eax, [eax<span style="color:#f92672">+</span><span style="color:#ae81ff">0x0c</span>]		    ; eax <span style="color:#f92672">=</span> Ldr (pointer to PEB_LDR_DATA)
</span></span><span style="display:flex;"><span>Line <span style="color:#ae81ff">3.</span> mov esi, [eax<span style="color:#f92672">+</span><span style="color:#ae81ff">0x10</span>]		    ; esi <span style="color:#f92672">=</span> pointer to the head of the doubly linked list InLoadOrderModuleList (<span style="color:#66d9ef">this</span> is a pointer to the first LDR_MODULE)
</span></span><span style="display:flex;"><span>Line <span style="color:#ae81ff">4.</span> mov esi, [esi]			    ; esi <span style="color:#f92672">=</span> stores the first LDR_MODULE
</span></span><span style="display:flex;"><span>Line <span style="color:#ae81ff">5.</span> cmp dword ptr [esi<span style="color:#f92672">+</span><span style="color:#ae81ff">0x18</span>], <span style="color:#ae81ff">0</span>	; esi<span style="color:#f92672">+</span><span style="color:#ae81ff">0x18</span> is the BaseAddress field
</span></span></code></pre></div><p><strong>Line 1</strong>: In line 1 the malware loads the address of the PEB structure by utilizing the fs:30h segment. It uses the fs segment because the code was written for x32 bit architecture. If it was written for x64 bit architecture, it would use the gs:60h segment.</p>
<p><strong>Line 2</strong>: In line 2 it loads the Ldr field from the PEB structure. We can see that it uses [eax+0x0c] to do so (remember that eax has the fs:30h loaded to it, or in other words the PEB struct). To understand why [eax+0x0c] ( or basically PEB[0x0c] ) is landing on the Ldr field, we must observe what exists on the 0x0c offset of the PEB structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _PEB {
</span></span><span style="display:flex;"><span>  BYTE			Reserved1[<span style="color:#ae81ff">2</span>];	<span style="color:#75715e">// offset = 0x00 --&gt; it stores 2 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  BYTE  		BeingDebugged;	<span style="color:#75715e">// offset = 0x02 --&gt; it stores 1 byte
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  BYTE  		Reserved2[<span style="color:#ae81ff">1</span>];	<span style="color:#75715e">// offset = 0x03 --&gt; it stores 1 byte
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  PVOID 		Reserved3[<span style="color:#ae81ff">2</span>];	<span style="color:#75715e">// offset = 0x04 --&gt; it stores 2*4 bytes (PVOID is 4 bytes)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  PPEB_LDR_DATA 	Ldr;		<span style="color:#75715e">// offset = 0x0c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ...
</span></span></code></pre></div><p><strong>Line 3</strong>: From the previous code section, we saw that the malware loaded Ldr by using the offset 0x0c. Then, the line <code>mov edi, [eax + 10h]</code> has been renamed to <code>mov edi, [eax + PEB_LDR_DATA.InLoadOrderModuleList.Blink]</code>. Why is that? Well, eax was previously set to Ldr (<code>mov eax, [eax+0x0c]</code>), and we added the offset 10h (<code>mov esi, [eax+0x10]</code>). So let&rsquo;s simply view the PEB_LDR_DATA struct and see what exists in the 0x10 offset:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _PEB_LDR_DATA
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     DWORD          Length;                             <span style="color:#75715e">// offset = 0x00
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     BYTE           Initialized[<span style="color:#ae81ff">4</span>];                     <span style="color:#75715e">// offset = 0x04
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>          SsHandle;                           <span style="color:#75715e">// offset = 0x08
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     LIST_ENTRY     InLoadOrderModuleList;              <span style="color:#75715e">// offset = 0x0c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#960050;background-color:#1e0010">`</span><span style="color:#f92672">----&gt;</span>           _LIST_ENTRY <span style="color:#f92672">*</span>Flink;             <span style="color:#75715e">// offset = 0x0c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#960050;background-color:#1e0010">`</span><span style="color:#f92672">----&gt;</span>           _LIST_ENTRY <span style="color:#f92672">*</span>Blink;             <span style="color:#75715e">// offset = 0x10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     LIST_ENTRY     InMemoryOrderModuleList;            <span style="color:#75715e">// offset = 0x14
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     LIST_ENTRY     InInitializationOrderModuleList;    <span style="color:#75715e">// offset = 0x1C
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>          EntryInProgress;                    <span style="color:#75715e">// offset = 0x24
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} PEB_LDR_DATA; 
</span></span></code></pre></div><fieldset class="fieldset-wrapper">
	<center><legend><b>Note</b></legend></center><br>
	<p><b>PPEB_LDR_DATA is basically a Pointer to the PEB_LDR_DATA, that's why the PPEB_LDR_DATA Ldr points to the above struct.</b></p>
</fieldset> 
<p>In the <code>_PEB_LDR_DATA</code> struct I have added the contents of the LIST_ENTRY struct (it has two subfields).<br>
We can see that the offset 0x10 is landing inside the <code>InLoadOrderModuleList</code> and specifically in the Blink field. But what is the <code>InLoadOrderModuleList</code> and its <code>Blink</code> and <code>Flink</code> fields&hellip;??!!??<br>
Well, the <code>InLoadOrderModuleList</code> is a double linked list where its elements (<code>Flink</code> and <code>Blink</code>) are pointers to some <code>LDR_MODULE</code> (or as it is <a href="https://www.winehq.org/pipermail/wine-devel/2020-April/165139.html">called today</a> <code>LDR_DATA_TABLE_ENTRY</code>)</p>
<p>To put it simply, when an executable runs, the DLL&rsquo;s it uses are stored in the <code>LDR_MODULE</code> struct. This stuct has the following fields:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _LDR_MODULE {
</span></span><span style="display:flex;"><span>  LIST_ENTRY              InLoadOrderModuleList;            <span style="color:#75715e">// offset = 0x00
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#960050;background-color:#1e0010">`</span><span style="color:#f92672">----&gt;</span>           _LIST_ENTRY <span style="color:#f92672">*</span>Flink;                   <span style="color:#75715e">// offset = 0x00
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#960050;background-color:#1e0010">`</span><span style="color:#f92672">----&gt;</span>           _LIST_ENTRY <span style="color:#f92672">*</span>Blink;                   <span style="color:#75715e">// offset = 0x04
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  LIST_ENTRY              InMemoryOrderModuleList;          <span style="color:#75715e">// offset = 0x08
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  LIST_ENTRY              InInitializationOrderModuleList;  <span style="color:#75715e">// offset = 0x10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  PVOID                   BaseAddress;                      <span style="color:#75715e">// offset = 0x18
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  PVOID                   EntryPoint;                       <span style="color:#75715e">// offset = 0x1c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ULONG                   SizeOfImage;                      <span style="color:#75715e">// offset = 0x20
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UNICODE_STRING          FullDllName;                      <span style="color:#75715e">// offset = 0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UNICODE_STRING          BaseDllName;                      <span style="color:#75715e">// offset = 0x30
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ULONG                   Flags;
</span></span><span style="display:flex;"><span>  SHORT                   LoadCount;
</span></span><span style="display:flex;"><span>  SHORT                   TlsIndex;
</span></span><span style="display:flex;"><span>  LIST_ENTRY              HashTableEntry;
</span></span><span style="display:flex;"><span>  ULONG                   TimeDateStamp;
</span></span><span style="display:flex;"><span>} LDR_MODULE, <span style="color:#f92672">*</span>PLDR_MODULE;
</span></span></code></pre></div><p>All the elements of this list can be parsed with the help of <code>InLoadOrderModuleList</code> and specifically the <code>Blink</code> and <code>Flink</code> fields, which just point to the previous (B-ackwards) and next (F-orward) DLL List entry. A picture that perfectly depicts this is the following:</p>
<p><img alt="LummaStealer" loading="lazy" src="/posts/peb/peb2.jpg"></p>
<fieldset class="fieldset-wrapper">
	<center><legend><b>Note</b></legend></center><br>
	<p><b>The first element of this list has no data section. It only has two pointers (Flink and Blink).</b></p>
</fieldset> 
<p><img alt="LummaStealer" loading="lazy" src="/posts/peb/peb3.png"></p>
<p>The first element of the list is the far left.</p>
<p><strong>Line 4</strong>: So at this point, the malware just loaded LDR through PEB and the esi register (<code>mov esi, [esi]</code>) contains the Blink of the List Head that points to the last <code>LDR_MODULE</code>. By dereferencing <code>esi</code> (<code>[esi]</code>), <code>esi</code> will basically &ldquo;execute&rdquo; the pointing to the previous <code>LDR_MODULE</code>. Now, we have landed on the previous <code>LDR_MODULE</code> and specifically on the <code>Flink</code> field. Why?<br>
By dereferencing <code>esi</code>, we are now refering on the offset 0x00 - the start of where the <code>esi</code> is pointing. But since <code>esi</code> is pointing to the previous <code>LDR_MODULE</code> on offset 0x00, by looking at the <code>LDR_MODULE</code> struct, we see that the offset 0x00 is the <code>InLoadOrderModuleList</code> and specifically the Flink field since it is the first of the <code>InLoadOrderModuleList's</code> subfields (so they have the same offset).</p>
<p><strong>Line 5</strong>: Looking at the LDR_MODULE struct once again, at offset 0x18 we see the BaseAddress field (or DllBase). The check for the BaseAddress is made to make sure no errors have occur and the program won&rsquo;t crash because of perhaps some invalid entry.</p>
<p>So, in order to locate the <code>KERNEL32.DLL</code>, the code loops through all modules of the <code>InLoadOrderModuleList</code> with the help of the <code>Flink</code> and <code>Blink</code> pointers. Every time in the loop, it moves to the next module of the list, storing the <code>Flink</code> pointer that points to the next element of the list.<br>
For each module, it loads its BaseDllName (<code>push dword ptr [esi+30h]</code>) and it checks if it is the <code>KERNEL32.DLL</code>.</p>
<p>Moving forward, <code>esi</code> (since it is now a Double linked list) will eventually end up back in the List Head, which is stored in the <code>edi</code> register. That is why in the code the <code>cmp edi, esi</code> is the loop termination condition.</p>
<p>Finally, after the loop, it takes the base address of the DLL and a hash, where it proceeds to do API hashing.</p>
<h2 id="code-examples">Code examples<a hidden class="anchor" aria-hidden="true" href="#code-examples">#</a></h2>
<p>Now that we have reviewed the part of the malware that utilized PEB and we have become familiar with it, let&rsquo;s start writting some code examples in C and play around with PEB.</p>
<h3 id="code-example-1---isbeingdebugged">Code example 1 - IsBeingDebugged<a hidden class="anchor" aria-hidden="true" href="#code-example-1---isbeingdebugged">#</a></h3>
<p>In this chapter we will write a simple script that uses PEB&rsquo;s isBeingDebugged field to try and see if our running executable is loaded into a debugger or not.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;winternl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">wchar_t</span><span style="color:#f92672">*</span> argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    PPEB pPEB <span style="color:#f92672">=</span> (PPEB)<span style="color:#a6e22e">__readgsqword</span>(<span style="color:#ae81ff">0x60</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// First way: Point to field with -&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    BYTE being_debugged <span style="color:#f92672">=</span> pPEB<span style="color:#f92672">-&gt;</span>BeingDebugged;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;IsBeingDebugged: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, being_debugged);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Second way: Point to field with offset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    DWORD flag <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PBYTE)((PBYTE)pPEB <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x02</span>); <span style="color:#75715e">// we could also use BYTE instead of DWORD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;IsBeingDebugged: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, flag);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here we see two way different ways of getting the IsBeingDebugged field. Let&rsquo;s break them down!</p>
<h4 id="reading-the-peb">Reading the PEB<a hidden class="anchor" aria-hidden="true" href="#reading-the-peb">#</a></h4>
<p>Starting off, we read the PEB struct by using the __readgsqword(0x60) since the system is a x64 one. We then cast the result to (PPEB) type which is basically a pointer that points to the PEB struct.</p>
<h4 id="first-method">First method<a hidden class="anchor" aria-hidden="true" href="#first-method">#</a></h4>
<p>The first method that I personally find the easiest is by using the &lsquo;-&gt;&rsquo; symbol. This way we basically use a struct and point (-&gt;) to the field within it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>PPEB pPEB <span style="color:#f92672">=</span> (PPEB)<span style="color:#a6e22e">__readgsqword</span>(<span style="color:#ae81ff">0x60</span>);            <span style="color:#75715e">// read PEB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>BYTE being_debugged <span style="color:#f92672">=</span> pPEB<span style="color:#f92672">-&gt;</span>BeingDebugged;        <span style="color:#75715e">// point to the field within the PEB struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;IsBeingDebugged: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, being_debugged);  <span style="color:#75715e">// print whether the exe is being debugged
</span></span></span></code></pre></div><h4 id="second-method">Second method<a hidden class="anchor" aria-hidden="true" href="#second-method">#</a></h4>
<p>The second method is a bit trickier since we have to calculate the offset from the struct based on the data types and the size they fill in memory. After we calculate the correct offset, we just do the correct byte casting and print the result:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>PPEB pPEB <span style="color:#f92672">=</span> (PPEB)<span style="color:#a6e22e">__readgsqword</span>(<span style="color:#ae81ff">0x60</span>);                       <span style="color:#75715e">// read PEB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>DWORD flag <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PBYTE)((PBYTE)pPEB <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x02</span>);                   <span style="color:#75715e">// point to the field within the PEB struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;IsBeingDebugged with offset pointer: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, flag);   <span style="color:#75715e">// print whether the exe is being debugged
</span></span></span></code></pre></div><p>In more details, the pPEB is a pointer to the PEB struct. By casting to (PBYTE)pPEB, we can now treat the address of the PEB struct as a sequence of bytes rather than a specific struct.</p>
<p>So, by doing (PBYTE)pPEB + 0x02 we are now pointing to the byte sequence at offset 0x02.</p>
<p>Finally, we use the outer *(PBYTE) to dereference the previous byte address and access the actual bytes inside the address.</p>
<h4 id="running-the-code">Running the code<a hidden class="anchor" aria-hidden="true" href="#running-the-code">#</a></h4>
<p>After running the code in visual studio, we see that the returned value is 0 (False), which means that our executable was not being debugged:<br>
<img alt="not being debugged" loading="lazy" src="/posts/peb/peb4.png"></p>
<p>However, if we run it again using the <em>Local Windows Debugger</em> in VS code, both our methods return 1 (True), which means our executable successfully recognized it was being debugged:<br>
<img alt="being debugged" loading="lazy" src="/posts/peb/peb5.png"></p>
<p>We will later see this in x64dbg were we will dive deeper into other PEB struct fields.</p>
<h3 id="code-example-2---loaded-dlls">Code example 2 - Loaded DLLs<a hidden class="anchor" aria-hidden="true" href="#code-example-2---loaded-dlls">#</a></h3>
<p>Although in the previous example we had direct access to the IsBeingDebugged field of the PEB structure, this will not always be the case. Often times, we will not have direct access to all fields of a struct and thus we will have to define it ourselfs in order to get the desired data.</p>
<p>In this code example, we will see how to land on the LDR struct that exists inside the PEB struct and get the list of loaded modules that our executable is using. The code that does this is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Windows.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;winternl.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _PEB_LDR_DATA_full
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ULONG Length;
</span></span><span style="display:flex;"><span>    BOOLEAN Initialized;
</span></span><span style="display:flex;"><span>    HANDLE SsHandle;
</span></span><span style="display:flex;"><span>    LIST_ENTRY InLoadOrderModuleList;
</span></span><span style="display:flex;"><span>    LIST_ENTRY InMemoryOrderModuleList;
</span></span><span style="display:flex;"><span>    LIST_ENTRY InInitializationOrderModuleList;
</span></span><span style="display:flex;"><span>    PVOID EntryInProgress;
</span></span><span style="display:flex;"><span>    BOOLEAN ShutdownInProgress;
</span></span><span style="display:flex;"><span>    HANDLE ShutdownThreadId;
</span></span><span style="display:flex;"><span>} PEB_LDR_DATA_full, <span style="color:#f92672">*</span> PPEB_LDR_DATA_full;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _LDR_MODULE_full {
</span></span><span style="display:flex;"><span>    LIST_ENTRY              InLoadOrderModuleList;
</span></span><span style="display:flex;"><span>    LIST_ENTRY              InMemoryOrderModuleList;
</span></span><span style="display:flex;"><span>    LIST_ENTRY              InInitializationOrderModuleList;
</span></span><span style="display:flex;"><span>    PVOID                   BaseAddress;
</span></span><span style="display:flex;"><span>    PVOID                   EntryPoint;
</span></span><span style="display:flex;"><span>    ULONG                   SizeOfImage;
</span></span><span style="display:flex;"><span>    UNICODE_STRING          FullDllName;
</span></span><span style="display:flex;"><span>    UNICODE_STRING          BaseDllName;
</span></span><span style="display:flex;"><span>    ULONG                   Flags;
</span></span><span style="display:flex;"><span>    SHORT                   LoadCount;
</span></span><span style="display:flex;"><span>    SHORT                   TlsIndex;
</span></span><span style="display:flex;"><span>    LIST_ENTRY              HashTableEntry;
</span></span><span style="display:flex;"><span>    ULONG                   TimeDateStamp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} LDR_MODULE_full, <span style="color:#f92672">*</span> PLDR_MODULE_full;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">wchar_t</span><span style="color:#f92672">*</span> argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#ifdef _WIN64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        PPEB pPEB <span style="color:#f92672">=</span> (PPEB)<span style="color:#a6e22e">__readgsqword</span>(<span style="color:#ae81ff">0x60</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        PPEB pPEB <span style="color:#f92672">=</span> (PPEB)<span style="color:#a6e22e">__readfsdword</span>(<span style="color:#ae81ff">0x30</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    PPEB_LDR_DATA_full pLdr <span style="color:#f92672">=</span> pPEB<span style="color:#f92672">-&gt;</span>Ldr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Access the InLoadOrderModuleList
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LIST_ENTRY<span style="color:#f92672">*</span> pListEntry <span style="color:#f92672">=</span> pLdr<span style="color:#f92672">-&gt;</span>InLoadOrderModuleList.Flink;
</span></span><span style="display:flex;"><span>    LIST_ENTRY<span style="color:#f92672">*</span> pListHead <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>pLdr<span style="color:#f92672">-&gt;</span>InLoadOrderModuleList;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Traverse the InLoadOrderModuleList and print the BaseAddress and BaseDllName of each module
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (pListEntry <span style="color:#f92672">!=</span> pListHead) {
</span></span><span style="display:flex;"><span>        PLDR_MODULE_full pLdrModule <span style="color:#f92672">=</span> <span style="color:#a6e22e">CONTAINING_RECORD</span>(pListEntry, LDR_MODULE_full, InLoadOrderModuleList);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Print the BaseAddress and BaseDllName
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;BaseAddress: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pLdrModule<span style="color:#f92672">-&gt;</span>BaseAddress);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wprintf</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;BaseDllName: %wZ</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>pLdrModule<span style="color:#f92672">-&gt;</span>BaseDllName);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Move to the next entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pListEntry <span style="color:#f92672">=</span> pListEntry<span style="color:#f92672">-&gt;</span>Flink;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="reading-the-peb-and-its-ldr-field">Reading the PEB and its Ldr field<a hidden class="anchor" aria-hidden="true" href="#reading-the-peb-and-its-ldr-field">#</a></h4>
<p>Let&rsquo;s break down the code. Starting off, we have the following lines of code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#ifdef _WIN64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PPEB pPEB <span style="color:#f92672">=</span> (PPEB)<span style="color:#a6e22e">__readgsqword</span>(<span style="color:#ae81ff">0x60</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PPEB pPEB <span style="color:#f92672">=</span> (PPEB)<span style="color:#a6e22e">__readfsdword</span>(<span style="color:#ae81ff">0x30</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>PPEB_LDR_DATA_full pLdr <span style="color:#f92672">=</span> pPEB<span style="color:#f92672">-&gt;</span>Ldr;
</span></span></code></pre></div><p>Basically, our code checks whether the system is a 64 bit system or a 32 bit system in order to know how to read the PEB struct. You can tell from the way it reads it:</p>
<ul>
<li>__readgsqword(0x60) &ndash;&gt; gsqword and 0x60 offset &ndash;&gt; 64 bit system</li>
<li>__readfsdword(0x30) &ndash;&gt; fsdword and 0x30 offset &ndash;&gt; 32 bit system</li>
</ul>
<p>After the code has recognized the system, it reads the Ldr field of the PEB struct. But wait a minute. Why do we cast the pLdr to a <code>PPEB_LDR_DATA_full</code>? Why didn&rsquo;t we do the same in the IsBeingDebugged example?</p>
<p>Turns out, some Windows structs are not fully documented and thus there are limitations by frameworks such as VS code as to what fields it identifies. So if we were to use the Microsoft&rsquo;s PEB_LDR_DATA struct we would be able to read very limited fields. The PEB_LDR_DATA that Microsoft docs provide is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _PEB_LDR_DATA {
</span></span><span style="display:flex;"><span>  BYTE       Reserved1[<span style="color:#ae81ff">8</span>];
</span></span><span style="display:flex;"><span>  PVOID      Reserved2[<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>  LIST_ENTRY InMemoryOrderModuleList;
</span></span><span style="display:flex;"><span>} PEB_LDR_DATA, <span style="color:#f92672">*</span>PPEB_LDR_DATA;
</span></span></code></pre></div><p>While the full (undocumented) LDR struct is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _PEB_LDR_DATA_full
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ULONG Length;
</span></span><span style="display:flex;"><span>    BOOLEAN Initialized;
</span></span><span style="display:flex;"><span>    HANDLE SsHandle;
</span></span><span style="display:flex;"><span>    LIST_ENTRY InLoadOrderModuleList;
</span></span><span style="display:flex;"><span>    LIST_ENTRY InMemoryOrderModuleList;
</span></span><span style="display:flex;"><span>    LIST_ENTRY InInitializationOrderModuleList;
</span></span><span style="display:flex;"><span>    PVOID EntryInProgress;
</span></span><span style="display:flex;"><span>    BOOLEAN ShutdownInProgress;
</span></span><span style="display:flex;"><span>    HANDLE ShutdownThreadId;
</span></span><span style="display:flex;"><span>} PEB_LDR_DATA_full, <span style="color:#f92672">*</span> PPEB_LDR_DATA_full;
</span></span></code></pre></div><p>And thus this is the one we are using since we later on in the code try to read the <code>InLoadOrderModuleList</code>. Now this explains the one of the two self defined structs we have written in our code.</p>
<p>To summarise before continuing, the code:</p>
<ul>
<li>reads the PEB field depending on the system&rsquo;s architecture.</li>
<li>defines the full LDR struct and proceeds to read and store it in the pLdr variable, which is a pointer pointing at that struct (and all its fields).</li>
</ul>
<h4 id="reading-ldr-inloadordermodulelists-fields">Reading Ldr-&gt;InLoadOrderModuleList&rsquo;s fields<a hidden class="anchor" aria-hidden="true" href="#reading-ldr-inloadordermodulelists-fields">#</a></h4>
<p>Continuing on, we have these two lines of code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Access the InLoadOrderModuleList
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LIST_ENTRY<span style="color:#f92672">*</span> pListEntry <span style="color:#f92672">=</span> pLdr<span style="color:#f92672">-&gt;</span>InLoadOrderModuleList.Flink;
</span></span><span style="display:flex;"><span>LIST_ENTRY<span style="color:#f92672">*</span> pListHead <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>pLdr<span style="color:#f92672">-&gt;</span>InLoadOrderModuleList;
</span></span></code></pre></div><p>After our previous read of the LDR struct, we now try and read its InLoadOrderModuleList&rsquo;s subfields, the Flink and Blink. Why? Well, as we descriped earlier on, the <code>InLoadOrderModuleList</code> contains a list of modules that our executable loads on runtime. This is a double linked list and we can move to the next or previous module (DLL) by using the Flink (Forward) and Blink (Backward) subfields. So this is the reason we read these fields in these lines. More specifically, we:</p>
<ul>
<li>Use the arrow pointing method, which is more easy to use.</li>
<li>For the Blink field, we use the &lsquo;&amp;&rsquo; address symbol for the reason described in the LummaStealer analysis section. As a small reminder, the pListEntry points to the first module in the InLoadOrderModuleList while the pListHead (that uses the &lsquo;&amp;&rsquo; address symbol) points to the head of the list which does not contain any DLL&rsquo;s. It is simply the start of the list as shown in previous pictures. If we were to dereference this address (with a &lsquo;*&rsquo;) then the pListHead would actually use the Flink (which at this point just has its address) and would point to the first DLL loaded in the list - which is exactly what the pListEntry points at. So we just keep its address for the loop comparison instead of the actual DLL it points at.</li>
</ul>
<p>Another reason we need to read the ListEntry and the ListHead is for the following loop, in order to know when we will eventually do a circle and land again on the ListHead.</p>
<h4 id="looping-through-all-loaded-dlls">Looping through all loaded DLL&rsquo;s<a hidden class="anchor" aria-hidden="true" href="#looping-through-all-loaded-dlls">#</a></h4>
<p>After we have successfully located the ListEntry and ListHead, we will start to loop through the list and print each DLL and its address:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">// Traverse the InLoadOrderModuleList and print the BaseAddress and BaseDllName of each module
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (pListEntry <span style="color:#f92672">!=</span> pListHead) {
</span></span><span style="display:flex;"><span>        PLDR_MODULE_full pLdrModule <span style="color:#f92672">=</span> <span style="color:#a6e22e">CONTAINING_RECORD</span>(pListEntry, LDR_MODULE_full, InLoadOrderModuleList);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Print the BaseAddress and BaseDllName
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;BaseAddress: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pLdrModule<span style="color:#f92672">-&gt;</span>BaseAddress);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wprintf</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;BaseDllName: %wZ</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>pLdrModule<span style="color:#f92672">-&gt;</span>BaseDllName);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Move to the next entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pListEntry <span style="color:#f92672">=</span> pListEntry<span style="color:#f92672">-&gt;</span>Flink;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>We can see at the end of the loop that the ListEntry changes to the next loaded DLL by doing <code>pListEntry-&gt;Flink</code> - basically using Flink to go to the next DLL. The loop runs until the pListEntry matches the pListHead we stored previously. This means we have completed the looping of the list and there are no more DLL&rsquo;s loaded in it.</p>
<p>Lastly, the way we load each DLL is by using the <code>CONTAINING_RECORD</code> macro definition. The full definition of this macro is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define CONTAINING_RECORD(address, type, field) ((type *)((PCHAR)(address) - (ULONG_PTR)(&amp;((type *)0)-&gt;field)))
</span></span></span></code></pre></div><ul>
<li><strong>address</strong>: This is the address of the field within the structure. So by using the <code>pListEntry</code>, we pass the pointed to the address of the loaded DLL at that time.</li>
<li><strong>type</strong>: This is the type of the parent structure. Here we passed the <code>LDR_MODULE_full</code> since this is the parent structure that contains the <code>InLoadOrderModuleList</code> subfield that we use to load the DLL&rsquo;s.</li>
<li><strong>field</strong>: This is the subfield we want to use from the parent structure. Here we used the <code>InLoadOrderModuleList</code> since this is the one we utilized to load the DLL&rsquo;s.</li>
</ul>
<p>Basically, <code>pListEntry</code> points to a <code>LIST_ENTRY</code> structure (Flink of the current entry). The macro calculates the address of the <code>LDR_MODULE_full</code> structure by subtracting the offset of the <code>InLoadOrderModuleList</code> field from pListEntry. This gives us a pointer to the <code>LDR_MODULE_full</code> structure containing the <code>LIST_ENTRY</code>. So pListEntry is nothing more than a list element <strong>pointing</strong> to a DLL - it is not the actual DLL. That&rsquo;s why we use CONTAINING_MACRO, to get the actual full DLL struct and then cast to <code>PLDR_MODULE_full</code>, since that&rsquo;s what is returned to us.</p>
<h4 id="printing-the-addresses-and-dlls">Printing the addresses and DLL&rsquo;s<a hidden class="anchor" aria-hidden="true" href="#printing-the-addresses-and-dlls">#</a></h4>
<p>Last but not least, the following two lines handle the printing of the DLL&rsquo;s address and name:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;BaseAddress: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pLdrModule<span style="color:#f92672">-&gt;</span>BaseAddress);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">wprintf</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;BaseDllName: %wZ</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>pLdrModule<span style="color:#f92672">-&gt;</span>BaseDllName);
</span></span></code></pre></div><p>The first print statement just uses %p to print the base address to which the pointer is pointing at.</p>
<p>The second print statement is a bit more complex. Let&rsquo;s break it down:</p>
<ul>
<li>wprintf: This print statement is used for wide-character strings (wchar_t). So the preceding w stands for wide.</li>
<li>L&quot;BaseDllName: %wZ\n&quot;: The L prefix tells the compiler that the string that is about to be print should be treated as a wide-character string (wchar_t). The %wZ when used with wprintf tells the function to format the string as a wide-character string. It is basically a placeholder for wchar_t type strings (wide-character strings).</li>
</ul>
<p>After running the full code we broke down, we will get the following results:</p>
<pre tabindex="0"><code>BaseAddress: 00007FF76D220000
BaseDllName: isBeingDebugged.exe
BaseAddress: 00007FF9AB6B0000
BaseDllName: ntdll.dll
BaseAddress: 00007FF9A97A0000
BaseDllName: KERNEL32.DLL
BaseAddress: 00007FF9A8ED0000
BaseDllName: KERNELBASE.dll
BaseAddress: 00007FF998190000
BaseDllName: VCRUNTIME140D.dll
BaseAddress: 00007FF9850A0000
BaseDllName: ucrtbased.dll
</code></pre><p>In the following section, we will see the same executable in x64dbg and see in action how all these fields show up in a debugger and how to identify them:)</p>
<h2 id="peb-in-depth---x64dbg">PEB in depth - x64dbg<a hidden class="anchor" aria-hidden="true" href="#peb-in-depth---x64dbg">#</a></h2>
<p>Now that we have a fully working executable that enumerates the InLoadModuleList to get the DLLs, let&rsquo;s load it in x64dbg and see the relevant fields while debugging the exe.</p>
<p>We first need to uncheck the System Breakpoint by going to Options-&gt;References:</p>
<p><img alt="x64_1" loading="lazy" src="/posts/peb/peb6.png"></p>
<p>The reason is that the x64dbg would land on the ntdll if we had a system breakpoint checked. For more information regarding this, advise <a href="https://www.youtube.com/watch?v=vdyyg72tc2w">this video from OALABS</a>.</p>
<p>After that, when we load the executable the debugging will start on the target. We then need to locate the invoke main instruction:</p>
<p><img alt="x64_2" loading="lazy" src="/posts/peb/peb7.png"></p>
<p>Going through the instructions, eventually we will find the PEB struct (gs:60h):</p>
<p><img alt="x64_3" loading="lazy" src="/posts/peb/peb8.png"></p>
<p>To go into the full struct, we need to either follow the address loaded to rax (since the PEB is moved to the rax register) or just use CTRL+G and write &ldquo;peb()&rdquo;. Both these are equal and will give/land us to the base address of the PEB:</p>
<p><img alt="x64_4" loading="lazy" src="/posts/peb/peb9.png"></p>
<h3 id="peb-baseaddress">PEB BaseAddress<a hidden class="anchor" aria-hidden="true" href="#peb-baseaddress">#</a></h3>
<p>After we have landed on the base address of the PEB struct, we need to follow this address in the memory dump. We can do this by write clicking&ndash;&gt;Follow in Dump&ndash;&gt;Selected Address. This will lead us to the PEB address, and in the following image we can see some of the most important fields of PEB:</p>
<p><img alt="x64_5" loading="lazy" src="/posts/peb/peb10.png"></p>
<p>As a reference, here is the relevant fields in the PEB struct:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _PEB {
</span></span><span style="display:flex;"><span>  BOOLEAN                 InheritedAddressSpace;
</span></span><span style="display:flex;"><span>  BOOLEAN                 ReadImageFileExecOptions;
</span></span><span style="display:flex;"><span>  BOOLEAN                 BeingDebugged;
</span></span><span style="display:flex;"><span>  BOOLEAN                 Spare;
</span></span><span style="display:flex;"><span>  HANDLE                  Mutant;
</span></span><span style="display:flex;"><span>  PVOID                   ImageBaseAddress;
</span></span><span style="display:flex;"><span>  PPEB_LDR_DATA           LoaderData;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">--</span> more <span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The underlined addresses are of Pointer type. Pointers can also not be underlined if they point to a null reference.</p>
<h4 id="imagebaseaddress">ImageBaseAddress<a hidden class="anchor" aria-hidden="true" href="#imagebaseaddress">#</a></h4>
<p>To land for example in the ImageBaseAddress field - the green address - we just need to highlight the corresponding address (<code>0x00007FF710330000 (big endian)</code>), right click on it and chose Follow QWORD Map-&gt;Dump 2. This will show the MZ header which means it has landed on the exe itself:</p>
<p><img alt="x64_6" loading="lazy" src="/posts/peb/peb11.png"></p>
<h4 id="ldr">Ldr<a hidden class="anchor" aria-hidden="true" href="#ldr">#</a></h4>
<p>To land on the Ldr struct, we need to follow the second pointer highlighted in blue with address <code>0x00007FF9AB81C4</code>. As previously, follow the QWORD in Dump 3. You should see something like the following:</p>
<p><img alt="x64_7" loading="lazy" src="/posts/peb/peb12.png"></p>
<table style='width: 750px'>
    <thead>
        <tr>
            <th style='text-align: center'>Offset</th>
            <th style='text-align: center'>Address</th>
            <th style='text-align: center'>Field</th>
            <th style='text-align: center'>Subfield</th>
            <th style='text-align: center'>Value</th>
        </tr>
    </thead>
    <tbody style='text-align: center'>
        <tr>
            <td><code>0x00</code></td>
            <td rowspan=2><code>0x7FF9AB81C4D0</code></td>
            <td rowspan=2>InLoadOrderModuleList</td>
            <td>Flink</td>
            <td><code>0x000001DEC5D82D40</code></td>
        </tr>
        <tr>
            <td><code>0x08</code></td>
            <td>Blink</td>
            <td><code>0x000001DEC5D8DE30</code></td>
        </tr>
        <tr>
            <td><code>0x10</code></td>
            <td rowspan=2><code>0x7FF9AB81C4E0</code></td>
            <td rowspan=2>InMemoryOrderModuleList</td>
            <td>Flink</td>
            <td><code>0x000001DEC5D82D50</code></td>
        </tr>
        <tr>
            <td><code>0x18</code></td>
            <td>Blink</td>
            <td><code>0x000001DEC5D8DE40</code></td>
        </tr>
        <tr>
            <td><code>0x20</code></td>
            <td rowspan=2><code>0x7FF9AB81C4EF</code></td>
            <td rowspan=2>InInitializationOrderModuleList</td>
            <td>Flink</td>
            <td><code>0x000001DEC5D828D0</code></td>
        </tr>
        <tr>
            <td><code>0x28</code></td>
            <td>Blink</td>
            <td><code>0x000001DEC5D8DC00</code></td>
        </tr>
    </tbody>
</table>
<p>We will only analyze the InLoadOrderModuleList since the rest of the lists follow the same logic. Also, the List Head is contained in these lists.</p>
<h4 id="flink-and-blink-pointers-of-the-list-head">Flink and Blink Pointers of the List Head<a hidden class="anchor" aria-hidden="true" href="#flink-and-blink-pointers-of-the-list-head">#</a></h4>
<p>Let&rsquo;s follow the Flink Pointer of InLoaderModuleList in the address <code>0x000001DEC5D82D40</code> (see the previous table):</p>
<p><img alt="x64_8" loading="lazy" src="/posts/peb/peb13.png"></p>
<p>The InLoadMemoryOrderLinks, InMemoryOrderLinks, InInitializationOrderLinks are of type LIST_ENTRY and they contain just two pointers, a Flink that points to the next element of the list, and a Blink pointing to the previous element of the list.</p>
<p>If we take the address of DllBase (<code>0x00003310F77F0000</code>) in Memory Map of x64dbg, we see that the current element of the LDR_MODULE struct (since we previously followed the flink pointer of InLoadOderModuleList) is actually our executable:</p>
<p><img alt="x64_9" loading="lazy" src="/posts/peb/peb14.png"></p>
<p>The 8 bytes that follow are the entry point of the exe.</p>
<p>If we follow the same process and follow the Flink Pointer of the current module (our exe), it will lead to the next element (module) of the list, which if we follow as previously the DllBase, we will see its the ntdll.</p>
<p>In the same memory map we see these modules, we can actually see the order they have been loaded:</p>
<p><img alt="x64_10" loading="lazy" src="/posts/peb/peb15.png"></p>
<p>In an image @r4sti painted, we can see the logic behind these Flinks we followed:</p>
<p><img alt="x64_11" loading="lazy" src="/posts/peb/peb16.png"></p>
<p>The same idea is applied for the Blink pointer. This would result in us landing in the previous ldr module, where - if you can guess based on the previous image - will be the ucrtbased.dll:</p>
<p><img alt="x64_12" loading="lazy" src="/posts/peb/peb17.png"></p>
<h3 id="whats-next">What&rsquo;s next<a hidden class="anchor" aria-hidden="true" href="#whats-next">#</a></h3>
<p>After we got a grasp of the structures and how to enumerate modules, me and r4sti thought API Hashing would be a good next topic to study. So in the next post I&rsquo;ll share what we learned about how to avoid using direct API DLL names and solely use them by their hash.</p>
<p><strong>References</strong></p>
<blockquote>
    <ul>
        <li> [1] <a href="https://www.cynet.com/attack-techniques-hands-on/defense-evasion-techniques-peb-edition/">Ariel Silver, Automation Engineer: <i>Defense Evasion Techniques – PEB Edition</i></a></li>
        <li> [2] <a href="https://gbmaster.wordpress.com/2012/02/26/on-the-road-of-hiding-peb-pe-format-handling-and-dll-loading-homemade-apis-part-1/">GB_MASTER: <i>WRITTEN BY GB_MASTER FEBRUARY 26, 2012 ON THE ROAD OF HIDING… PEB, PE FORMAT HANDLING AND DLL LOADING HOMEMADE APIS – PART 1</i></a></li>
        <li> [3] <a href="https://malwareandstuff.com/peb-where-magic-is-stored/">hackingump: <i>PEB: Where Magic Is Stored</i></a></li>
        <li> [4] <a href="https://mohamed-fakroud.gitbook.io/red-teamings-dojo/windows-internals/peb">Mohamed Fakroud: <i>Digging into Windows PEB</i></a></li>
    </ul>
</blockquote>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/peb/">PEB</a></li>
      <li><a href="http://localhost:1313/tags/ldr/">LDR</a></li>
      <li><a href="http://localhost:1313/tags/windows-api/">Windows API</a></li>
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Journal of Connar</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
